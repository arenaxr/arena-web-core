!function(){return function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){return o(e[i][1][r]||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}}()({1:[function(require,module,exports){var CANNON=require("cannon-es");require("./src/components/math"),require("./src/components/body/ammo-body"),require("./src/components/body/body"),require("./src/components/body/dynamic-body"),require("./src/components/body/static-body"),require("./src/components/shape/shape"),require("./src/components/shape/ammo-shape"),require("./src/components/ammo-constraint"),require("./src/components/constraint"),require("./src/components/spring"),require("./src/system"),module.exports={registerAll:function(){console.warn("registerAll() is deprecated. Components are automatically registered.")}},window.CANNON=window.CANNON||CANNON},{"./src/components/ammo-constraint":9,"./src/components/body/ammo-body":10,"./src/components/body/body":11,"./src/components/body/dynamic-body":12,"./src/components/body/static-body":13,"./src/components/constraint":14,"./src/components/math":15,"./src/components/shape/ammo-shape":17,"./src/components/shape/shape":18,"./src/components/spring":19,"./src/system":29,"cannon-es":5}],2:[function(require,module,exports){var CANNON=require("cannon-es");CANNON.shape2mesh=function(body){var obj=new THREE.Object3D;function createBufferGeometry(positions,faces){var geometry=new THREE.BufferGeometry;return geometry.setAttribute("position",new THREE.Float32BufferAttribute(positions,3)),geometry.setIndex(faces),geometry.computeBoundingSphere(),geometry}for(var l=0;l<body.shapes.length;l++){var mesh,shape=body.shapes[l];switch(shape.type){case CANNON.Shape.types.SPHERE:var sphere_geometry=new THREE.SphereGeometry(shape.radius,8,8);mesh=new THREE.Mesh(sphere_geometry,this.currentMaterial);break;case CANNON.Shape.types.PARTICLE:mesh=new THREE.Mesh(this.particleGeo,this.particleMaterial);var s=this.settings;mesh.scale.set(s.particleSize,s.particleSize,s.particleSize);break;case CANNON.Shape.types.PLANE:var geometry=new THREE.PlaneGeometry(10,10,4,4);mesh=new THREE.Object3D;var submesh=new THREE.Object3D,ground=new THREE.Mesh(geometry,this.currentMaterial);ground.scale.set(100,100,100),submesh.add(ground),ground.castShadow=!0,ground.receiveShadow=!0,mesh.add(submesh);break;case CANNON.Shape.types.BOX:var box_geometry=new THREE.BoxGeometry(2*shape.halfExtents.x,2*shape.halfExtents.y,2*shape.halfExtents.z);mesh=new THREE.Mesh(box_geometry,this.currentMaterial);break;case CANNON.Shape.types.CONVEXPOLYHEDRON:for(var positions=[],i=0;i<shape.vertices.length;i++){var v=shape.vertices[i];positions.push(v.x,v.y,v.z)}var faces=[];for(i=0;i<shape.faces.length;i++)for(var face=shape.faces[i],a=face[0],j=1;j<face.length-1;j++){var b=face[j],c=face[j+1];faces.push(a,b,c)}var geo=createBufferGeometry(positions,faces);mesh=new THREE.Mesh(geo,this.currentMaterial);break;case CANNON.Shape.types.HEIGHTFIELD:for(var v0=new CANNON.Vec3,v1=new CANNON.Vec3,v2=new CANNON.Vec3,xi=(positions=[],faces=[],0);xi<shape.data.length-1;xi++)for(var yi=0;yi<shape.data[xi].length-1;yi++)for(var k=0;k<2;k++){shape.getConvexTrianglePillar(xi,yi,0===k),v0.copy(shape.pillarConvex.vertices[0]),v1.copy(shape.pillarConvex.vertices[1]),v2.copy(shape.pillarConvex.vertices[2]),v0.vadd(shape.pillarOffset,v0),v1.vadd(shape.pillarOffset,v1),v2.vadd(shape.pillarOffset,v2),positions.push(v0.x,v0.y,v0.z,v1.x,v1.y,v1.z,v2.x,v2.y,v2.z);i=positions.length/3-3;faces.push(i,i+1,i+2)}geometry=createBufferGeometry(positions,faces);mesh=new THREE.Mesh(geometry,this.currentMaterial);break;case CANNON.Shape.types.TRIMESH:for(geometry=new THREE.BufferGeometry,v0=new CANNON.Vec3,v1=new CANNON.Vec3,v2=new CANNON.Vec3,positions=[],faces=[],i=0;i<shape.indices.length/3;i++){shape.getTriangleVertices(i,v0,v1,v2),positions.push(v0.x,v0.y,v0.z,v1.x,v1.y,v1.z,v2.x,v2.y,v2.z);j=positions.length/3-3;faces.push(j,j+1,j+2)}geometry=createBufferGeometry(positions,faces);mesh=new THREE.Mesh(geometry,this.currentMaterial);break;default:throw"Visual type not recognized: "+shape.type}if(mesh.receiveShadow=!0,mesh.castShadow=!0,mesh.children)for(i=0;i<mesh.children.length;i++)if(mesh.children[i].castShadow=!0,mesh.children[i].receiveShadow=!0,mesh.children[i])for(j=0;j<mesh.children[i].length;j++)mesh.children[i].children[j].castShadow=!0,mesh.children[i].children[j].receiveShadow=!0;var o=body.shapeOffsets[l],q=body.shapeOrientations[l];mesh.position.set(o.x,o.y,o.z),mesh.quaternion.set(q.x,q.y,q.z,q.w),obj.add(mesh)}return obj},module.exports=CANNON.shape2mesh},{"cannon-es":5}],3:[function(require,module,exports){AFRAME.registerComponent("stats-panel",{schema:{merge:{type:"boolean",default:!0}},init(){const container=document.querySelector(".rs-container");if(container&&this.data.merge)return void(this.container=container);this.base=document.createElement("div"),this.base.classList.add("rs-base");const body=document.body||document.getElementsByTagName("body")[0];container&&!this.data.merge&&(this.base.style.top="auto",this.base.style.bottom="20px"),body.appendChild(this.base),this.container=document.createElement("div"),this.container.classList.add("rs-container"),this.base.appendChild(this.container)}}),AFRAME.registerComponent("stats-group",{multiple:!0,schema:{label:{type:"string"}},init(){let container;const baseComponent=this.el.components["stats-panel"];(container=baseComponent?baseComponent.container:document.querySelector(".rs-container"))?(this.groupHeader=document.createElement("h1"),this.groupHeader.innerHTML=this.data.label,container.appendChild(this.groupHeader),this.group=document.createElement("div"),this.group.classList.add("rs-group"),this.group.style.flexDirection="column",this.group.style.webKitFlexDirection="column",container.appendChild(this.group)):console.warn("Couldn't find stats container to add stats to.\n                    Add either stats or stats-panel component to a-scene")}}),AFRAME.registerComponent("stats-row",{multiple:!0,schema:{group:{type:"string"},event:{type:"string"},properties:{type:"array"},label:{type:"string"}},init(){const groupComponentName="stats-group__"+this.data.group,groupComponent=this.el.components[groupComponentName]||this.el.sceneEl.components[groupComponentName]||this.el.components["stats-group"]||this.el.sceneEl.components["stats-group"];groupComponent?(this.counter=document.createElement("div"),this.counter.classList.add("rs-counter-base"),groupComponent.group.appendChild(this.counter),this.counterId=document.createElement("div"),this.counterId.classList.add("rs-counter-id"),this.counterId.innerHTML=this.data.label,this.counter.appendChild(this.counterId),this.counterValues={},this.data.properties.forEach(property=>{const counterValue=document.createElement("div");counterValue.classList.add("rs-counter-value"),counterValue.innerHTML="...",this.counter.appendChild(counterValue),this.counterValues[property]=counterValue}),this.updateData=this.updateData.bind(this),this.el.addEventListener(this.data.event,this.updateData),this.splitCache={}):console.warn(`Couldn't find stats group ${groupComponentName}`)},updateData(e){this.data.properties.forEach(property=>{const split=this.splitDot(property);let value=e.detail;for(i=0;i<split.length;i++)value=value[split[i]];this.counterValues[property].innerHTML=value})},splitDot(path){return path in this.splitCache?this.splitCache[path]:(this.splitCache[path]=path.split("."),this.splitCache[path])}}),AFRAME.registerComponent("stats-collector",{multiple:!0,schema:{inEvent:{type:"string"},properties:{type:"array"},outputFrequency:{type:"number",default:100},outEvent:{type:"string"},outputs:{type:"array"},outputToConsole:{type:"string"}},init(){this.statsData={},this.resetData(),this.outputDetail={},this.data.properties.forEach(property=>{this.outputDetail[property]={}}),this.statsReceived=this.statsReceived.bind(this),this.el.addEventListener(this.data.inEvent,this.statsReceived)},resetData(){this.counter=0,this.data.properties.forEach(property=>{this.statsData[property]=[]})},statsReceived(e){this.updateData(e.detail),this.counter++,this.counter===this.data.outputFrequency&&(this.outputData(),this.resetData())},updateData(detail){this.data.properties.forEach(property=>{let value=detail;value=value[property],this.statsData[property].push(value)})},outputData(){this.data.properties.forEach(property=>{this.data.outputs.forEach(output=>{this.outputDetail[property][output]=this.computeOutput(output,this.statsData[property])})}),this.data.outEvent&&this.el.emit(this.data.outEvent,this.outputDetail),this.data.outputToConsole&&console.log(this.data.outputToConsole,this.outputDetail)},computeOutput(outputInstruction,data){const outputInstructions=outputInstruction.split("__");let output;switch(outputInstructions[0]){case"mean":output=data.reduce((a,b)=>a+b,0)/data.length;break;case"max":output=Math.max(...data);break;case"min":output=Math.min(...data);break;case"percentile":const sorted=data.sort((a,b)=>a-b),proportion=+outputInstructions[1].replace("_",".")/100,position=(data.length-1)*proportion,base=Math.floor(position),delta=position-base;output=void 0!==sorted[base+1]?sorted[base]+delta*(sorted[base+1]-sorted[base]):sorted[base]}return output.toFixed(2)}})},{}],4:[function(require,module,exports){THREE.AmmoDebugConstants={NoDebug:0,DrawWireframe:1,DrawAabb:2,DrawFeaturesText:4,DrawContactPoints:8,NoDeactivation:16,NoHelpText:32,DrawText:64,ProfileTimings:128,EnableSatComparison:256,DisableBulletLCP:512,EnableCCD:1024,DrawConstraints:2048,DrawConstraintLimits:4096,FastWireframe:8192,DrawNormals:16384,DrawOnTop:32768,MAX_DEBUG_DRAW_MODE:4294967295},THREE.AmmoDebugDrawer=function(scene,world,options){this.scene=scene,this.world=world,options=options||{},this.debugDrawMode=options.debugDrawMode||THREE.AmmoDebugConstants.DrawWireframe;var drawOnTop=this.debugDrawMode&THREE.AmmoDebugConstants.DrawOnTop||!1,maxBufferSize=options.maxBufferSize||1e6;this.geometry=new THREE.BufferGeometry;var vertices=new Float32Array(3*maxBufferSize),colors=new Float32Array(3*maxBufferSize);this.geometry.setAttribute("position",new THREE.BufferAttribute(vertices,3).setUsage(THREE.DynamicDrawUsage)),this.geometry.setAttribute("color",new THREE.BufferAttribute(colors,3).setUsage(THREE.DynamicDrawUsage)),this.index=0;var material=new THREE.LineBasicMaterial({vertexColors:!0,depthTest:!drawOnTop});this.mesh=new THREE.LineSegments(this.geometry,material),drawOnTop&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.debugDrawer.enable=this.enable.bind(this),this.debugDrawer.disable=this.disable.bind(this),this.debugDrawer.update=this.update.bind(this),this.world.setDebugDrawer(this.debugDrawer)},THREE.AmmoDebugDrawer.prototype=function(){return this.debugDrawer},THREE.AmmoDebugDrawer.prototype.enable=function(){this.enabled=!0,this.scene.add(this.mesh)},THREE.AmmoDebugDrawer.prototype.disable=function(){this.enabled=!1,this.scene.remove(this.mesh)},THREE.AmmoDebugDrawer.prototype.update=function(){this.enabled&&(0!=this.index&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))},THREE.AmmoDebugDrawer.prototype.drawLine=function(from,to,color){const heap=Ammo.HEAPF32,r=heap[(color+0)/4],g=heap[(color+4)/4],b=heap[(color+8)/4],fromX=heap[(from+0)/4],fromY=heap[(from+4)/4],fromZ=heap[(from+8)/4];this.geometry.attributes.position.setXYZ(this.index,fromX,fromY,fromZ),this.geometry.attributes.color.setXYZ(this.index++,r,g,b);const toX=heap[(to+0)/4],toY=heap[(to+4)/4],toZ=heap[(to+8)/4];this.geometry.attributes.position.setXYZ(this.index,toX,toY,toZ),this.geometry.attributes.color.setXYZ(this.index++,r,g,b)},THREE.AmmoDebugDrawer.prototype.drawContactPoint=function(pointOnB,normalOnB,distance,lifeTime,color){const heap=Ammo.HEAPF32,r=heap[(color+0)/4],g=heap[(color+4)/4],b=heap[(color+8)/4],x=heap[(pointOnB+0)/4],y=heap[(pointOnB+4)/4],z=heap[(pointOnB+8)/4];this.geometry.attributes.position.setXYZ(this.index,x,y,z),this.geometry.attributes.color.setXYZ(this.index++,r,g,b);const dx=heap[(normalOnB+0)/4]*distance,dy=heap[(normalOnB+4)/4]*distance,dz=heap[(normalOnB+8)/4]*distance;this.geometry.attributes.position.setXYZ(this.index,x+dx,y+dy,z+dz),this.geometry.attributes.color.setXYZ(this.index++,r,g,b)},THREE.AmmoDebugDrawer.prototype.reportErrorWarning=function(warningString){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(warningString)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))},THREE.AmmoDebugDrawer.prototype.draw3dText=function(location,textString){console.warn("TODO: draw3dText")},THREE.AmmoDebugDrawer.prototype.setDebugMode=function(debugMode){this.debugDrawMode=debugMode},THREE.AmmoDebugDrawer.prototype.getDebugMode=function(){return this.debugDrawMode}},{}],5:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.World=exports.Vec3Pool=exports.Vec3=exports.Trimesh=exports.Transform=exports.Spring=exports.SplitSolver=exports.Sphere=exports.Solver=exports.Shape=exports.SPHSystem=exports.SHAPE_TYPES=exports.SAPBroadphase=exports.RotationalMotorEquation=exports.RotationalEquation=exports.RigidVehicle=exports.RaycastVehicle=exports.RaycastResult=exports.Ray=exports.RAY_MODES=exports.Quaternion=exports.Pool=exports.PointToPointConstraint=exports.Plane=exports.Particle=exports.ObjectCollisionMatrix=exports.Narrowphase=exports.NaiveBroadphase=exports.Material=exports.Mat3=exports.LockConstraint=exports.JacobianElement=exports.HingeConstraint=exports.Heightfield=exports.GridBroadphase=exports.GSSolver=exports.FrictionEquation=exports.EventTarget=exports.Equation=exports.DistanceConstraint=exports.Cylinder=exports.ConvexPolyhedron=exports.ContactMaterial=exports.ContactEquation=exports.Constraint=exports.ConeTwistConstraint=exports.COLLISION_TYPES=exports.Broadphase=exports.Box=exports.Body=exports.BODY_TYPES=exports.BODY_SLEEP_STATES=exports.ArrayCollisionMatrix=exports.AABB=void 0;exports.ObjectCollisionMatrix=class{constructor(){this.matrix={}}get(bi,bj){let{id:i}=bi,{id:j}=bj;if(j>i){const temp=j;j=i,i=temp}return i+"-"+j in this.matrix}set(bi,bj,value){let{id:i}=bi,{id:j}=bj;if(j>i){const temp=j;j=i,i=temp}value?this.matrix[i+"-"+j]=!0:delete this.matrix[i+"-"+j]}reset(){this.matrix={}}setNumObjects(n){}};class Mat3{constructor(elements=[0,0,0,0,0,0,0,0,0]){this.elements=elements}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(vector){const e=this.elements;e[0]=vector.x,e[4]=vector.y,e[8]=vector.z}getTrace(target=new Vec3){const e=this.elements;target.x=e[0],target.y=e[4],target.z=e[8]}vmult(v,target=new Vec3){const e=this.elements,x=v.x,y=v.y,z=v.z;return target.x=e[0]*x+e[1]*y+e[2]*z,target.y=e[3]*x+e[4]*y+e[5]*z,target.z=e[6]*x+e[7]*y+e[8]*z,target}smult(s){for(let i=0;i<this.elements.length;i++)this.elements[i]*=s}mmult(matrix,target=new Mat3){const{elements:elements}=matrix;for(let i=0;i<3;i++)for(let j=0;j<3;j++){let sum=0;for(let k=0;k<3;k++)sum+=elements[i+3*k]*this.elements[k+3*j];target.elements[i+3*j]=sum}return target}scale(vector,target=new Mat3){const e=this.elements,t=target.elements;for(let i=0;3!==i;i++)t[3*i+0]=vector.x*e[3*i+0],t[3*i+1]=vector.y*e[3*i+1],t[3*i+2]=vector.z*e[3*i+2];return target}solve(b,target=new Vec3){const eqns=[];let i,j;for(i=0;i<12;i++)eqns.push(0);for(i=0;i<3;i++)for(j=0;j<3;j++)eqns[i+4*j]=this.elements[i+3*j];eqns[3]=b.x,eqns[7]=b.y,eqns[11]=b.z;let n=3;const k=n;let np;let p;do{if(0===eqns[(i=k-n)+4*i])for(j=i+1;j<k;j++)if(0!==eqns[i+4*j]){np=4;do{eqns[(p=4-np)+4*i]+=eqns[p+4*j]}while(--np);break}if(0!==eqns[i+4*i])for(j=i+1;j<k;j++){const multiplier=eqns[i+4*j]/eqns[i+4*i];np=4;do{eqns[(p=4-np)+4*j]=p<=i?0:eqns[p+4*j]-eqns[p+4*i]*multiplier}while(--np)}}while(--n);if(target.z=eqns[11]/eqns[10],target.y=(eqns[7]-eqns[6]*target.z)/eqns[5],target.x=(eqns[3]-eqns[2]*target.z-eqns[1]*target.y)/eqns[0],isNaN(target.x)||isNaN(target.y)||isNaN(target.z)||target.x===1/0||target.y===1/0||target.z===1/0)throw"Could not solve equation! Got x=["+target.toString()+"], b=["+b.toString()+"], A=["+this.toString()+"]";return target}e(row,column,value){if(void 0===value)return this.elements[column+3*row];this.elements[column+3*row]=value}copy(matrix){for(let i=0;i<matrix.elements.length;i++)this.elements[i]=matrix.elements[i];return this}toString(){let r="";for(let i=0;i<9;i++)r+=this.elements[i]+",";return r}reverse(target=new Mat3){const eqns=[];let i,j;for(i=0;i<18;i++)eqns.push(0);for(i=0;i<3;i++)for(j=0;j<3;j++)eqns[i+6*j]=this.elements[i+3*j];eqns[3]=1,eqns[9]=0,eqns[15]=0,eqns[4]=0,eqns[10]=1,eqns[16]=0,eqns[5]=0,eqns[11]=0,eqns[17]=1;let n=3;const k=n;let np;let p;do{if(0===eqns[(i=k-n)+6*i])for(j=i+1;j<k;j++)if(0!==eqns[i+6*j]){np=6;do{eqns[(p=6-np)+6*i]+=eqns[p+6*j]}while(--np);break}if(0!==eqns[i+6*i])for(j=i+1;j<k;j++){const multiplier=eqns[i+6*j]/eqns[i+6*i];np=6;do{eqns[(p=6-np)+6*j]=p<=i?0:eqns[p+6*j]-eqns[p+6*i]*multiplier}while(--np)}}while(--n);i=2;do{j=i-1;do{const multiplier=eqns[i+6*j]/eqns[i+6*i];np=6;do{eqns[(p=6-np)+6*j]=eqns[p+6*j]-eqns[p+6*i]*multiplier}while(--np)}while(j--)}while(--i);i=2;do{const multiplier=1/eqns[i+6*i];np=6;do{eqns[(p=6-np)+6*i]=eqns[p+6*i]*multiplier}while(--np)}while(i--);i=2;do{j=2;do{if(p=eqns[3+j+6*i],isNaN(p)||p===1/0)throw"Could not reverse! A=["+this.toString()+"]";target.e(i,j,p)}while(j--)}while(i--);return target}setRotationFromQuaternion(q){const x=q.x,y=q.y,z=q.z,w=q.w,x2=x+x,y2=y+y,z2=z+z,xx=x*x2,xy=x*y2,xz=x*z2,yy=y*y2,yz=y*z2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2,e=this.elements;return e[0]=1-(yy+zz),e[1]=xy-wz,e[2]=xz+wy,e[3]=xy+wz,e[4]=1-(xx+zz),e[5]=yz-wx,e[6]=xz-wy,e[7]=yz+wx,e[8]=1-(xx+yy),this}transpose(target=new Mat3){const Mt=target.elements,M=this.elements;for(let i=0;3!==i;i++)for(let j=0;3!==j;j++)Mt[3*i+j]=M[3*j+i];return target}}exports.Mat3=Mat3;class Vec3{constructor(x=0,y=0,z=0){this.x=x,this.y=y,this.z=z}cross(vector,target=new Vec3){const vx=vector.x,vy=vector.y,vz=vector.z,x=this.x,y=this.y,z=this.z;return target.x=y*vz-z*vy,target.y=z*vx-x*vz,target.z=x*vy-y*vx,target}set(x,y,z){return this.x=x,this.y=y,this.z=z,this}setZero(){this.x=this.y=this.z=0}vadd(vector,target){if(!target)return new Vec3(this.x+vector.x,this.y+vector.y,this.z+vector.z);target.x=vector.x+this.x,target.y=vector.y+this.y,target.z=vector.z+this.z}vsub(vector,target){if(!target)return new Vec3(this.x-vector.x,this.y-vector.y,this.z-vector.z);target.x=this.x-vector.x,target.y=this.y-vector.y,target.z=this.z-vector.z}crossmat(){return new Mat3([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const x=this.x,y=this.y,z=this.z,n=Math.sqrt(x*x+y*y+z*z);if(n>0){const invN=1/n;this.x*=invN,this.y*=invN,this.z*=invN}else this.x=0,this.y=0,this.z=0;return n}unit(target=new Vec3){const x=this.x,y=this.y,z=this.z;let ninv=Math.sqrt(x*x+y*y+z*z);return ninv>0?(ninv=1/ninv,target.x=x*ninv,target.y=y*ninv,target.z=z*ninv):(target.x=1,target.y=0,target.z=0),target}length(){const x=this.x,y=this.y,z=this.z;return Math.sqrt(x*x+y*y+z*z)}lengthSquared(){return this.dot(this)}distanceTo(p){const x=this.x,y=this.y,z=this.z,px=p.x,py=p.y,pz=p.z;return Math.sqrt((px-x)*(px-x)+(py-y)*(py-y)+(pz-z)*(pz-z))}distanceSquared(p){const x=this.x,y=this.y,z=this.z,px=p.x,py=p.y,pz=p.z;return(px-x)*(px-x)+(py-y)*(py-y)+(pz-z)*(pz-z)}scale(scalar,target=new Vec3){const x=this.x,y=this.y,z=this.z;return target.x=scalar*x,target.y=scalar*y,target.z=scalar*z,target}vmul(vector,target=new Vec3){return target.x=vector.x*this.x,target.y=vector.y*this.y,target.z=vector.z*this.z,target}addScaledVector(scalar,vector,target=new Vec3){return target.x=this.x+scalar*vector.x,target.y=this.y+scalar*vector.y,target.z=this.z+scalar*vector.z,target}dot(vector){return this.x*vector.x+this.y*vector.y+this.z*vector.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(target=new Vec3){return target.x=-this.x,target.y=-this.y,target.z=-this.z,target}tangents(t1,t2){const norm=this.length();if(norm>0){const n=Vec3_tangents_n,inorm=1/norm;n.set(this.x*inorm,this.y*inorm,this.z*inorm);const randVec=Vec3_tangents_randVec;Math.abs(n.x)<.9?(randVec.set(1,0,0),n.cross(randVec,t1)):(randVec.set(0,1,0),n.cross(randVec,t1)),n.cross(t1,t2)}else t1.set(1,0,0),t2.set(0,1,0)}toString(){return this.x+","+this.y+","+this.z}toArray(){return[this.x,this.y,this.z]}copy(vector){return this.x=vector.x,this.y=vector.y,this.z=vector.z,this}lerp(vector,t,target){const x=this.x,y=this.y,z=this.z;target.x=x+(vector.x-x)*t,target.y=y+(vector.y-y)*t,target.z=z+(vector.z-z)*t}almostEquals(vector,precision=1e-6){return!(Math.abs(this.x-vector.x)>precision||Math.abs(this.y-vector.y)>precision||Math.abs(this.z-vector.z)>precision)}almostZero(precision=1e-6){return!(Math.abs(this.x)>precision||Math.abs(this.y)>precision||Math.abs(this.z)>precision)}isAntiparallelTo(vector,precision){return this.negate(antip_neg),antip_neg.almostEquals(vector,precision)}clone(){return new Vec3(this.x,this.y,this.z)}}exports.Vec3=Vec3,Vec3.ZERO=new Vec3(0,0,0),Vec3.UNIT_X=new Vec3(1,0,0),Vec3.UNIT_Y=new Vec3(0,1,0),Vec3.UNIT_Z=new Vec3(0,0,1);const Vec3_tangents_n=new Vec3,Vec3_tangents_randVec=new Vec3,antip_neg=new Vec3;class AABB{constructor(options={}){this.lowerBound=new Vec3,this.upperBound=new Vec3,options.lowerBound&&this.lowerBound.copy(options.lowerBound),options.upperBound&&this.upperBound.copy(options.upperBound)}setFromPoints(points,position,quaternion,skinSize){const l=this.lowerBound,u=this.upperBound,q=quaternion;l.copy(points[0]),q&&q.vmult(l,l),u.copy(l);for(let i=1;i<points.length;i++){let p=points[i];q&&(q.vmult(p,tmp),p=tmp),p.x>u.x&&(u.x=p.x),p.x<l.x&&(l.x=p.x),p.y>u.y&&(u.y=p.y),p.y<l.y&&(l.y=p.y),p.z>u.z&&(u.z=p.z),p.z<l.z&&(l.z=p.z)}return position&&(position.vadd(l,l),position.vadd(u,u)),skinSize&&(l.x-=skinSize,l.y-=skinSize,l.z-=skinSize,u.x+=skinSize,u.y+=skinSize,u.z+=skinSize),this}copy(aabb){return this.lowerBound.copy(aabb.lowerBound),this.upperBound.copy(aabb.upperBound),this}clone(){return(new AABB).copy(this)}extend(aabb){this.lowerBound.x=Math.min(this.lowerBound.x,aabb.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,aabb.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,aabb.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,aabb.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,aabb.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,aabb.upperBound.z)}overlaps(aabb){const l1=this.lowerBound,u1=this.upperBound,l2=aabb.lowerBound,u2=aabb.upperBound,overlapsX=l2.x<=u1.x&&u1.x<=u2.x||l1.x<=u2.x&&u2.x<=u1.x,overlapsY=l2.y<=u1.y&&u1.y<=u2.y||l1.y<=u2.y&&u2.y<=u1.y,overlapsZ=l2.z<=u1.z&&u1.z<=u2.z||l1.z<=u2.z&&u2.z<=u1.z;return overlapsX&&overlapsY&&overlapsZ}volume(){const l=this.lowerBound,u=this.upperBound;return(u.x-l.x)*(u.y-l.y)*(u.z-l.z)}contains(aabb){const l1=this.lowerBound,u1=this.upperBound,l2=aabb.lowerBound,u2=aabb.upperBound;return l1.x<=l2.x&&u1.x>=u2.x&&l1.y<=l2.y&&u1.y>=u2.y&&l1.z<=l2.z&&u1.z>=u2.z}getCorners(a,b,c,d,e,f,g,h){const l=this.lowerBound,u=this.upperBound;a.copy(l),b.set(u.x,l.y,l.z),c.set(u.x,u.y,l.z),d.set(l.x,u.y,u.z),e.set(u.x,l.y,u.z),f.set(l.x,u.y,l.z),g.set(l.x,l.y,u.z),h.copy(u)}toLocalFrame(frame,target){const corners=transformIntoFrame_corners,a=corners[0],b=corners[1],c=corners[2],d=corners[3],e=corners[4],f=corners[5],g=corners[6],h=corners[7];this.getCorners(a,b,c,d,e,f,g,h);for(let i=0;8!==i;i++){const corner=corners[i];frame.pointToLocal(corner,corner)}return target.setFromPoints(corners)}toWorldFrame(frame,target){const corners=transformIntoFrame_corners,a=corners[0],b=corners[1],c=corners[2],d=corners[3],e=corners[4],f=corners[5],g=corners[6],h=corners[7];this.getCorners(a,b,c,d,e,f,g,h);for(let i=0;8!==i;i++){const corner=corners[i];frame.pointToWorld(corner,corner)}return target.setFromPoints(corners)}overlapsRay(ray){const{direction:direction,from:from}=ray,dirFracX=1/direction.x,dirFracY=1/direction.y,dirFracZ=1/direction.z,t1=(this.lowerBound.x-from.x)*dirFracX,t2=(this.upperBound.x-from.x)*dirFracX,t3=(this.lowerBound.y-from.y)*dirFracY,t4=(this.upperBound.y-from.y)*dirFracY,t5=(this.lowerBound.z-from.z)*dirFracZ,t6=(this.upperBound.z-from.z)*dirFracZ,tmin=Math.max(Math.max(Math.min(t1,t2),Math.min(t3,t4)),Math.min(t5,t6)),tmax=Math.min(Math.min(Math.max(t1,t2),Math.max(t3,t4)),Math.max(t5,t6));return!(tmax<0)&&!(tmin>tmax)}}exports.AABB=AABB;const tmp=new Vec3,transformIntoFrame_corners=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3];class ArrayCollisionMatrix{constructor(){this.matrix=[]}get(bi,bj){let{index:i}=bi,{index:j}=bj;if(j>i){const temp=j;j=i,i=temp}return this.matrix[(i*(i+1)>>1)+j-1]}set(bi,bj,value){let{index:i}=bi,{index:j}=bj;if(j>i){const temp=j;j=i,i=temp}this.matrix[(i*(i+1)>>1)+j-1]=value?1:0}reset(){for(let i=0,l=this.matrix.length;i!==l;i++)this.matrix[i]=0}setNumObjects(n){this.matrix.length=n*(n-1)>>1}}exports.ArrayCollisionMatrix=ArrayCollisionMatrix;class EventTarget{constructor(){}addEventListener(type,listener){void 0===this._listeners&&(this._listeners={});const listeners=this._listeners;return void 0===listeners[type]&&(listeners[type]=[]),listeners[type].includes(listener)||listeners[type].push(listener),this}hasEventListener(type,listener){if(void 0===this._listeners)return!1;const listeners=this._listeners;return!(void 0===listeners[type]||!listeners[type].includes(listener))}hasAnyEventListener(type){if(void 0===this._listeners)return!1;return void 0!==this._listeners[type]}removeEventListener(type,listener){if(void 0===this._listeners)return this;const listeners=this._listeners;if(void 0===listeners[type])return this;const index=listeners[type].indexOf(listener);return-1!==index&&listeners[type].splice(index,1),this}dispatchEvent(event){if(void 0===this._listeners)return this;const listenerArray=this._listeners[event.type];if(void 0!==listenerArray){event.target=this;for(let i=0,l=listenerArray.length;i<l;i++)listenerArray[i].call(this,event)}return this}}exports.EventTarget=EventTarget;class Quaternion{constructor(x=0,y=0,z=0,w=1){this.x=x,this.y=y,this.z=z,this.w=w}set(x,y,z,w){return this.x=x,this.y=y,this.z=z,this.w=w,this}toString(){return this.x+","+this.y+","+this.z+","+this.w}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(vector,angle){const s=Math.sin(.5*angle);return this.x=vector.x*s,this.y=vector.y*s,this.z=vector.z*s,this.w=Math.cos(.5*angle),this}toAxisAngle(targetAxis=new Vec3){this.normalize();const angle=2*Math.acos(this.w),s=Math.sqrt(1-this.w*this.w);return s<.001?(targetAxis.x=this.x,targetAxis.y=this.y,targetAxis.z=this.z):(targetAxis.x=this.x/s,targetAxis.y=this.y/s,targetAxis.z=this.z/s),[targetAxis,angle]}setFromVectors(u,v){if(u.isAntiparallelTo(v)){const t1=sfv_t1,t2=sfv_t2;u.tangents(t1,t2),this.setFromAxisAngle(t1,Math.PI)}else{const a=u.cross(v);this.x=a.x,this.y=a.y,this.z=a.z,this.w=Math.sqrt(u.length()**2*v.length()**2)+u.dot(v),this.normalize()}return this}mult(quat,target=new Quaternion){const ax=this.x,ay=this.y,az=this.z,aw=this.w,bx=quat.x,by=quat.y,bz=quat.z,bw=quat.w;return target.x=ax*bw+aw*bx+ay*bz-az*by,target.y=ay*bw+aw*by+az*bx-ax*bz,target.z=az*bw+aw*bz+ax*by-ay*bx,target.w=aw*bw-ax*bx-ay*by-az*bz,target}inverse(target=new Quaternion){const x=this.x,y=this.y,z=this.z,w=this.w;this.conjugate(target);const inorm2=1/(x*x+y*y+z*z+w*w);return target.x*=inorm2,target.y*=inorm2,target.z*=inorm2,target.w*=inorm2,target}conjugate(target=new Quaternion){return target.x=-this.x,target.y=-this.y,target.z=-this.z,target.w=this.w,target}normalize(){let l=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===l?(this.x=0,this.y=0,this.z=0,this.w=0):(l=1/l,this.x*=l,this.y*=l,this.z*=l,this.w*=l),this}normalizeFast(){const f=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===f?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=f,this.y*=f,this.z*=f,this.w*=f),this}vmult(v,target=new Vec3){const x=v.x,y=v.y,z=v.z,qx=this.x,qy=this.y,qz=this.z,qw=this.w,ix=qw*x+qy*z-qz*y,iy=qw*y+qz*x-qx*z,iz=qw*z+qx*y-qy*x,iw=-qx*x-qy*y-qz*z;return target.x=ix*qw+iw*-qx+iy*-qz-iz*-qy,target.y=iy*qw+iw*-qy+iz*-qx-ix*-qz,target.z=iz*qw+iw*-qz+ix*-qy-iy*-qx,target}copy(quat){return this.x=quat.x,this.y=quat.y,this.z=quat.z,this.w=quat.w,this}toEuler(target,order="YZX"){let heading,attitude,bank;const x=this.x,y=this.y,z=this.z,w=this.w;switch(order){case"YZX":const test=x*y+z*w;if(test>.499&&(heading=2*Math.atan2(x,w),attitude=Math.PI/2,bank=0),test<-.499&&(heading=-2*Math.atan2(x,w),attitude=-Math.PI/2,bank=0),void 0===heading){const sqx=x*x,sqy=y*y,sqz=z*z;heading=Math.atan2(2*y*w-2*x*z,1-2*sqy-2*sqz),attitude=Math.asin(2*test),bank=Math.atan2(2*x*w-2*y*z,1-2*sqx-2*sqz)}break;default:throw new Error("Euler order "+order+" not supported yet.")}target.y=heading,target.z=attitude,target.x=bank}setFromEuler(x,y,z,order="XYZ"){const c1=Math.cos(x/2),c2=Math.cos(y/2),c3=Math.cos(z/2),s1=Math.sin(x/2),s2=Math.sin(y/2),s3=Math.sin(z/2);return"XYZ"===order?(this.x=s1*c2*c3+c1*s2*s3,this.y=c1*s2*c3-s1*c2*s3,this.z=c1*c2*s3+s1*s2*c3,this.w=c1*c2*c3-s1*s2*s3):"YXZ"===order?(this.x=s1*c2*c3+c1*s2*s3,this.y=c1*s2*c3-s1*c2*s3,this.z=c1*c2*s3-s1*s2*c3,this.w=c1*c2*c3+s1*s2*s3):"ZXY"===order?(this.x=s1*c2*c3-c1*s2*s3,this.y=c1*s2*c3+s1*c2*s3,this.z=c1*c2*s3+s1*s2*c3,this.w=c1*c2*c3-s1*s2*s3):"ZYX"===order?(this.x=s1*c2*c3-c1*s2*s3,this.y=c1*s2*c3+s1*c2*s3,this.z=c1*c2*s3-s1*s2*c3,this.w=c1*c2*c3+s1*s2*s3):"YZX"===order?(this.x=s1*c2*c3+c1*s2*s3,this.y=c1*s2*c3+s1*c2*s3,this.z=c1*c2*s3-s1*s2*c3,this.w=c1*c2*c3-s1*s2*s3):"XZY"===order&&(this.x=s1*c2*c3-c1*s2*s3,this.y=c1*s2*c3-s1*c2*s3,this.z=c1*c2*s3+s1*s2*c3,this.w=c1*c2*c3+s1*s2*s3),this}clone(){return new Quaternion(this.x,this.y,this.z,this.w)}slerp(toQuat,t,target=new Quaternion){const ax=this.x,ay=this.y,az=this.z,aw=this.w;let omega,cosom,sinom,scale0,scale1,bx=toQuat.x,by=toQuat.y,bz=toQuat.z,bw=toQuat.w;return(cosom=ax*bx+ay*by+az*bz+aw*bw)<0&&(cosom=-cosom,bx=-bx,by=-by,bz=-bz,bw=-bw),1-cosom>1e-6?(omega=Math.acos(cosom),sinom=Math.sin(omega),scale0=Math.sin((1-t)*omega)/sinom,scale1=Math.sin(t*omega)/sinom):(scale0=1-t,scale1=t),target.x=scale0*ax+scale1*bx,target.y=scale0*ay+scale1*by,target.z=scale0*az+scale1*bz,target.w=scale0*aw+scale1*bw,target}integrate(angularVelocity,dt,angularFactor,target=new Quaternion){const ax=angularVelocity.x*angularFactor.x,ay=angularVelocity.y*angularFactor.y,az=angularVelocity.z*angularFactor.z,bx=this.x,by=this.y,bz=this.z,bw=this.w,half_dt=.5*dt;return target.x+=half_dt*(ax*bw+ay*bz-az*by),target.y+=half_dt*(ay*bw+az*bx-ax*bz),target.z+=half_dt*(az*bw+ax*by-ay*bx),target.w+=half_dt*(-ax*bx-ay*by-az*bz),target}}exports.Quaternion=Quaternion;const sfv_t1=new Vec3,sfv_t2=new Vec3,SHAPE_TYPES=exports.SHAPE_TYPES={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class Shape{constructor(options={}){this.id=Shape.idCounter++,this.type=options.type||0,this.boundingSphereRadius=0,this.collisionResponse=!options.collisionResponse||options.collisionResponse,this.collisionFilterGroup=void 0!==options.collisionFilterGroup?options.collisionFilterGroup:1,this.collisionFilterMask=void 0!==options.collisionFilterMask?options.collisionFilterMask:-1,this.material=options.material?options.material:null,this.body=null}updateBoundingSphereRadius(){throw"computeBoundingSphereRadius() not implemented for shape type "+this.type}volume(){throw"volume() not implemented for shape type "+this.type}calculateLocalInertia(mass,target){throw"calculateLocalInertia() not implemented for shape type "+this.type}calculateWorldAABB(pos,quat,min,max){throw"calculateWorldAABB() not implemented for shape type "+this.type}}exports.Shape=Shape,Shape.idCounter=0,Shape.types=SHAPE_TYPES;class Transform{constructor(options={}){this.position=new Vec3,this.quaternion=new Quaternion,options.position&&this.position.copy(options.position),options.quaternion&&this.quaternion.copy(options.quaternion)}pointToLocal(worldPoint,result){return Transform.pointToLocalFrame(this.position,this.quaternion,worldPoint,result)}pointToWorld(localPoint,result){return Transform.pointToWorldFrame(this.position,this.quaternion,localPoint,result)}vectorToWorldFrame(localVector,result=new Vec3){return this.quaternion.vmult(localVector,result),result}static pointToLocalFrame(position,quaternion,worldPoint,result=new Vec3){return worldPoint.vsub(position,result),quaternion.conjugate(tmpQuat),tmpQuat.vmult(result,result),result}static pointToWorldFrame(position,quaternion,localPoint,result=new Vec3){return quaternion.vmult(localPoint,result),result.vadd(position,result),result}static vectorToWorldFrame(quaternion,localVector,result=new Vec3){return quaternion.vmult(localVector,result),result}static vectorToLocalFrame(position,quaternion,worldVector,result=new Vec3){return quaternion.w*=-1,quaternion.vmult(worldVector,result),quaternion.w*=-1,result}}exports.Transform=Transform;const tmpQuat=new Quaternion;class ConvexPolyhedron extends Shape{constructor(props={}){const{vertices:vertices=[],faces:faces=[],normals:normals=[],axes:axes,boundingSphereRadius:boundingSphereRadius}=props;super({type:Shape.types.CONVEXPOLYHEDRON}),this.vertices=vertices,this.faces=faces,this.faceNormals=normals,0===this.faceNormals.length&&this.computeNormals(),boundingSphereRadius?this.boundingSphereRadius=boundingSphereRadius:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=axes?axes.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const faces=this.faces,vertices=this.vertices,edges=this.uniqueEdges;edges.length=0;const edge=new Vec3;for(let i=0;i!==faces.length;i++){const face=faces[i],numVertices=face.length;for(let j=0;j!==numVertices;j++){const k=(j+1)%numVertices;vertices[face[j]].vsub(vertices[face[k]],edge),edge.normalize();let found=!1;for(let p=0;p!==edges.length;p++)if(edges[p].almostEquals(edge)||edges[p].almostEquals(edge)){found=!0;break}found||edges.push(edge.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let i=0;i<this.faces.length;i++){for(let j=0;j<this.faces[i].length;j++)if(!this.vertices[this.faces[i][j]])throw new Error("Vertex "+this.faces[i][j]+" not found!");const n=this.faceNormals[i]||new Vec3;this.getFaceNormal(i,n),n.negate(n),this.faceNormals[i]=n;const vertex=this.vertices[this.faces[i][0]];if(n.dot(vertex)<0){console.error(".faceNormals["+i+"] = Vec3("+n.toString()+") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");for(let j=0;j<this.faces[i].length;j++)console.warn(".vertices["+this.faces[i][j]+"] = Vec3("+this.vertices[this.faces[i][j]].toString()+")")}}}getFaceNormal(i,target){const f=this.faces[i],va=this.vertices[f[0]],vb=this.vertices[f[1]],vc=this.vertices[f[2]];ConvexPolyhedron.computeNormal(va,vb,vc,target)}clipAgainstHull(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){const WorldNormal=new Vec3;let closestFaceB=-1,dmax=-Number.MAX_VALUE;for(let face=0;face<hullB.faces.length;face++){WorldNormal.copy(hullB.faceNormals[face]),quatB.vmult(WorldNormal,WorldNormal);const d=WorldNormal.dot(separatingNormal);d>dmax&&(dmax=d,closestFaceB=face)}const worldVertsB1=[];for(let i=0;i<hullB.faces[closestFaceB].length;i++){const b=hullB.vertices[hullB.faces[closestFaceB][i]],worldb=new Vec3;worldb.copy(b),quatB.vmult(worldb,worldb),posB.vadd(worldb,worldb),worldVertsB1.push(worldb)}closestFaceB>=0&&this.clipFaceAgainstHull(separatingNormal,posA,quatA,worldVertsB1,minDist,maxDist,result)}findSeparatingAxis(hullB,posA,quatA,posB,quatB,target,faceListA,faceListB){const faceANormalWS3=new Vec3,Worldnormal1=new Vec3,deltaC=new Vec3,worldEdge0=new Vec3,worldEdge1=new Vec3,Cross=new Vec3;let dmin=Number.MAX_VALUE;const hullA=this;if(hullA.uniqueAxes)for(let i=0;i!==hullA.uniqueAxes.length;i++){quatA.vmult(hullA.uniqueAxes[i],faceANormalWS3);const d=hullA.testSepAxis(faceANormalWS3,hullB,posA,quatA,posB,quatB);if(!1===d)return!1;d<dmin&&(dmin=d,target.copy(faceANormalWS3))}else{const numFacesA=faceListA?faceListA.length:hullA.faces.length;for(let i=0;i<numFacesA;i++){const fi=faceListA?faceListA[i]:i;faceANormalWS3.copy(hullA.faceNormals[fi]),quatA.vmult(faceANormalWS3,faceANormalWS3);const d=hullA.testSepAxis(faceANormalWS3,hullB,posA,quatA,posB,quatB);if(!1===d)return!1;d<dmin&&(dmin=d,target.copy(faceANormalWS3))}}if(hullB.uniqueAxes)for(let i=0;i!==hullB.uniqueAxes.length;i++){quatB.vmult(hullB.uniqueAxes[i],Worldnormal1);const d=hullA.testSepAxis(Worldnormal1,hullB,posA,quatA,posB,quatB);if(!1===d)return!1;d<dmin&&(dmin=d,target.copy(Worldnormal1))}else{const numFacesB=faceListB?faceListB.length:hullB.faces.length;for(let i=0;i<numFacesB;i++){const fi=faceListB?faceListB[i]:i;Worldnormal1.copy(hullB.faceNormals[fi]),quatB.vmult(Worldnormal1,Worldnormal1);const d=hullA.testSepAxis(Worldnormal1,hullB,posA,quatA,posB,quatB);if(!1===d)return!1;d<dmin&&(dmin=d,target.copy(Worldnormal1))}}for(let e0=0;e0!==hullA.uniqueEdges.length;e0++){quatA.vmult(hullA.uniqueEdges[e0],worldEdge0);for(let e1=0;e1!==hullB.uniqueEdges.length;e1++)if(quatB.vmult(hullB.uniqueEdges[e1],worldEdge1),worldEdge0.cross(worldEdge1,Cross),!Cross.almostZero()){Cross.normalize();const dist=hullA.testSepAxis(Cross,hullB,posA,quatA,posB,quatB);if(!1===dist)return!1;dist<dmin&&(dmin=dist,target.copy(Cross))}}return posB.vsub(posA,deltaC),deltaC.dot(target)>0&&target.negate(target),!0}testSepAxis(axis,hullB,posA,quatA,posB,quatB){ConvexPolyhedron.project(this,axis,posA,quatA,maxminA),ConvexPolyhedron.project(hullB,axis,posB,quatB,maxminB);const maxA=maxminA[0],minA=maxminA[1],maxB=maxminB[0],minB=maxminB[1];if(maxA<minB||maxB<minA)return!1;const d0=maxA-minB,d1=maxB-minA;return d0<d1?d0:d1}calculateLocalInertia(mass,target){const aabbmax=new Vec3,aabbmin=new Vec3;this.computeLocalAABB(aabbmin,aabbmax);const x=aabbmax.x-aabbmin.x,y=aabbmax.y-aabbmin.y,z=aabbmax.z-aabbmin.z;target.x=1/12*mass*(2*y*2*y+2*z*2*z),target.y=1/12*mass*(2*x*2*x+2*z*2*z),target.z=1/12*mass*(2*y*2*y+2*x*2*x)}getPlaneConstantOfFace(face_i){const f=this.faces[face_i],n=this.faceNormals[face_i],v=this.vertices[f[0]];return-n.dot(v)}clipFaceAgainstHull(separatingNormal,posA,quatA,worldVertsB1,minDist,maxDist,result){const faceANormalWS=new Vec3,edge0=new Vec3,WorldEdge0=new Vec3,worldPlaneAnormal1=new Vec3,planeNormalWS1=new Vec3,worldA1=new Vec3,localPlaneNormal=new Vec3,planeNormalWS=new Vec3,hullA=this,pVtxIn=worldVertsB1,pVtxOut=[];let closestFaceA=-1,dmin=Number.MAX_VALUE;for(let face=0;face<hullA.faces.length;face++){faceANormalWS.copy(hullA.faceNormals[face]),quatA.vmult(faceANormalWS,faceANormalWS);const d=faceANormalWS.dot(separatingNormal);d<dmin&&(dmin=d,closestFaceA=face)}if(closestFaceA<0)return;const polyA=hullA.faces[closestFaceA];polyA.connectedFaces=[];for(let i=0;i<hullA.faces.length;i++)for(let j=0;j<hullA.faces[i].length;j++)-1!==polyA.indexOf(hullA.faces[i][j])&&i!==closestFaceA&&-1===polyA.connectedFaces.indexOf(i)&&polyA.connectedFaces.push(i);const numVerticesA=polyA.length;for(let i=0;i<numVerticesA;i++){const a=hullA.vertices[polyA[i]],b=hullA.vertices[polyA[(i+1)%numVerticesA]];a.vsub(b,edge0),WorldEdge0.copy(edge0),quatA.vmult(WorldEdge0,WorldEdge0),posA.vadd(WorldEdge0,WorldEdge0),worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]),quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1),posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1),WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1),planeNormalWS1.negate(planeNormalWS1),worldA1.copy(a),quatA.vmult(worldA1,worldA1),posA.vadd(worldA1,worldA1);const otherFace=polyA.connectedFaces[i];localPlaneNormal.copy(this.faceNormals[otherFace]);const localPlaneEq=this.getPlaneConstantOfFace(otherFace);planeNormalWS.copy(localPlaneNormal),quatA.vmult(planeNormalWS,planeNormalWS);const planeEqWS=localPlaneEq-planeNormalWS.dot(posA);for(this.clipFaceAgainstPlane(pVtxIn,pVtxOut,planeNormalWS,planeEqWS);pVtxIn.length;)pVtxIn.shift();for(;pVtxOut.length;)pVtxIn.push(pVtxOut.shift())}localPlaneNormal.copy(this.faceNormals[closestFaceA]);const localPlaneEq=this.getPlaneConstantOfFace(closestFaceA);planeNormalWS.copy(localPlaneNormal),quatA.vmult(planeNormalWS,planeNormalWS);const planeEqWS=localPlaneEq-planeNormalWS.dot(posA);for(let i=0;i<pVtxIn.length;i++){let depth=planeNormalWS.dot(pVtxIn[i])+planeEqWS;if(depth<=minDist&&(console.log("clamped: depth="+depth+" to minDist="+minDist),depth=minDist),depth<=maxDist){const point=pVtxIn[i];if(depth<=1e-6){const p={point:point,normal:planeNormalWS,depth:depth};result.push(p)}}}}clipFaceAgainstPlane(inVertices,outVertices,planeNormal,planeConstant){let n_dot_first,n_dot_last;const numVerts=inVertices.length;if(numVerts<2)return outVertices;let firstVertex=inVertices[inVertices.length-1],lastVertex=inVertices[0];n_dot_first=planeNormal.dot(firstVertex)+planeConstant;for(let vi=0;vi<numVerts;vi++){if(lastVertex=inVertices[vi],n_dot_last=planeNormal.dot(lastVertex)+planeConstant,n_dot_first<0)if(n_dot_last<0){const newv=new Vec3;newv.copy(lastVertex),outVertices.push(newv)}else{const newv=new Vec3;firstVertex.lerp(lastVertex,n_dot_first/(n_dot_first-n_dot_last),newv),outVertices.push(newv)}else if(n_dot_last<0){const newv=new Vec3;firstVertex.lerp(lastVertex,n_dot_first/(n_dot_first-n_dot_last),newv),outVertices.push(newv),outVertices.push(lastVertex)}firstVertex=lastVertex,n_dot_first=n_dot_last}return outVertices}computeWorldVertices(position,quat){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new Vec3);const verts=this.vertices,worldVerts=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)quat.vmult(verts[i],worldVerts[i]),position.vadd(worldVerts[i],worldVerts[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(aabbmin,aabbmax){const vertices=this.vertices;aabbmin.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),aabbmax.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let i=0;i<this.vertices.length;i++){const v=vertices[i];v.x<aabbmin.x?aabbmin.x=v.x:v.x>aabbmax.x&&(aabbmax.x=v.x),v.y<aabbmin.y?aabbmin.y=v.y:v.y>aabbmax.y&&(aabbmax.y=v.y),v.z<aabbmin.z?aabbmin.z=v.z:v.z>aabbmax.z&&(aabbmax.z=v.z)}}computeWorldFaceNormals(quat){const N=this.faceNormals.length;for(;this.worldFaceNormals.length<N;)this.worldFaceNormals.push(new Vec3);const normals=this.faceNormals,worldNormals=this.worldFaceNormals;for(let i=0;i!==N;i++)quat.vmult(normals[i],worldNormals[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let max2=0;const verts=this.vertices;for(let i=0;i!==verts.length;i++){const norm2=verts[i].lengthSquared();norm2>max2&&(max2=norm2)}this.boundingSphereRadius=Math.sqrt(max2)}calculateWorldAABB(pos,quat,min,max){const verts=this.vertices;let minx,miny,minz,maxx,maxy,maxz,tempWorldVertex=new Vec3;for(let i=0;i<verts.length;i++){tempWorldVertex.copy(verts[i]),quat.vmult(tempWorldVertex,tempWorldVertex),pos.vadd(tempWorldVertex,tempWorldVertex);const v=tempWorldVertex;(void 0===minx||v.x<minx)&&(minx=v.x),(void 0===maxx||v.x>maxx)&&(maxx=v.x),(void 0===miny||v.y<miny)&&(miny=v.y),(void 0===maxy||v.y>maxy)&&(maxy=v.y),(void 0===minz||v.z<minz)&&(minz=v.z),(void 0===maxz||v.z>maxz)&&(maxz=v.z)}min.set(minx,miny,minz),max.set(maxx,maxy,maxz)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(target=new Vec3){const verts=this.vertices;for(let i=0;i<verts.length;i++)target.vadd(verts[i],target);return target.scale(1/verts.length,target),target}transformAllPoints(offset,quat){const n=this.vertices.length,verts=this.vertices;if(quat){for(let i=0;i<n;i++){const v=verts[i];quat.vmult(v,v)}for(let i=0;i<this.faceNormals.length;i++){const v=this.faceNormals[i];quat.vmult(v,v)}}if(offset)for(let i=0;i<n;i++){const v=verts[i];v.vadd(offset,v)}}pointIsInside(p){const verts=this.vertices,faces=this.faces,normals=this.faceNormals,pointInside=new Vec3;this.getAveragePointLocal(pointInside);for(let i=0;i<this.faces.length;i++){let n=normals[i];const v=verts[faces[i][0]],vToP=new Vec3;p.vsub(v,vToP);const r1=n.dot(vToP),vToPointInside=new Vec3;pointInside.vsub(v,vToPointInside);const r2=n.dot(vToPointInside);if(r1<0&&r2>0||r1>0&&r2<0)return!1}return-1}}exports.ConvexPolyhedron=ConvexPolyhedron,ConvexPolyhedron.computeNormal=((va,vb,vc,target)=>{const cb=new Vec3,ab=new Vec3;vb.vsub(va,ab),vc.vsub(vb,cb),cb.cross(ab,target),target.isZero()||target.normalize()});const maxminA=[],maxminB=[];ConvexPolyhedron.project=((shape,axis,pos,quat,result)=>{const n=shape.vertices.length,localAxis=new Vec3;let max=0,min=0;const localOrigin=new Vec3,vs=shape.vertices;localOrigin.setZero(),Transform.vectorToLocalFrame(pos,quat,axis,localAxis),Transform.pointToLocalFrame(pos,quat,localOrigin,localOrigin);const add=localOrigin.dot(localAxis);min=max=vs[0].dot(localAxis);for(let i=1;i<n;i++){const val=vs[i].dot(localAxis);val>max&&(max=val),val<min&&(min=val)}if((min-=add)>(max-=add)){const temp=min;min=max,max=temp}result[0]=max,result[1]=min});class Box extends Shape{constructor(halfExtents){super({type:Shape.types.BOX}),this.halfExtents=halfExtents,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const sx=this.halfExtents.x,sy=this.halfExtents.y,sz=this.halfExtents.z,V=Vec3,vertices=[new V(-sx,-sy,-sz),new V(sx,-sy,-sz),new V(sx,sy,-sz),new V(-sx,sy,-sz),new V(-sx,-sy,sz),new V(sx,-sy,sz),new V(sx,sy,sz),new V(-sx,sy,sz)],axes=[new V(0,0,1),new V(0,1,0),new V(1,0,0)],h=new ConvexPolyhedron({vertices:vertices,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:axes});this.convexPolyhedronRepresentation=h,h.material=this.material}calculateLocalInertia(mass,target=new Vec3){return Box.calculateInertia(this.halfExtents,mass,target),target}getSideNormals(sixTargetVectors,quat){const sides=sixTargetVectors,ex=this.halfExtents;if(sides[0].set(ex.x,0,0),sides[1].set(0,ex.y,0),sides[2].set(0,0,ex.z),sides[3].set(-ex.x,0,0),sides[4].set(0,-ex.y,0),sides[5].set(0,0,-ex.z),void 0!==quat)for(let i=0;i!==sides.length;i++)quat.vmult(sides[i],sides[i]);return sides}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(pos,quat,callback){const e=this.halfExtents,corners=[[e.x,e.y,e.z],[-e.x,e.y,e.z],[-e.x,-e.y,e.z],[-e.x,-e.y,-e.z],[e.x,-e.y,-e.z],[e.x,e.y,-e.z],[-e.x,e.y,-e.z],[e.x,-e.y,e.z]];for(let i=0;i<corners.length;i++)worldCornerTempPos.set(corners[i][0],corners[i][1],corners[i][2]),quat.vmult(worldCornerTempPos,worldCornerTempPos),pos.vadd(worldCornerTempPos,worldCornerTempPos),callback(worldCornerTempPos.x,worldCornerTempPos.y,worldCornerTempPos.z)}calculateWorldAABB(pos,quat,min,max){const e=this.halfExtents;worldCornersTemp[0].set(e.x,e.y,e.z),worldCornersTemp[1].set(-e.x,e.y,e.z),worldCornersTemp[2].set(-e.x,-e.y,e.z),worldCornersTemp[3].set(-e.x,-e.y,-e.z),worldCornersTemp[4].set(e.x,-e.y,-e.z),worldCornersTemp[5].set(e.x,e.y,-e.z),worldCornersTemp[6].set(-e.x,e.y,-e.z),worldCornersTemp[7].set(e.x,-e.y,e.z);const wc=worldCornersTemp[0];quat.vmult(wc,wc),pos.vadd(wc,wc),max.copy(wc),min.copy(wc);for(let i=1;i<8;i++){const wc=worldCornersTemp[i];quat.vmult(wc,wc),pos.vadd(wc,wc);const x=wc.x,y=wc.y,z=wc.z;x>max.x&&(max.x=x),y>max.y&&(max.y=y),z>max.z&&(max.z=z),x<min.x&&(min.x=x),y<min.y&&(min.y=y),z<min.z&&(min.z=z)}}}exports.Box=Box,Box.calculateInertia=((halfExtents,mass,target)=>{const e=halfExtents;target.x=1/12*mass*(2*e.y*2*e.y+2*e.z*2*e.z),target.y=1/12*mass*(2*e.x*2*e.x+2*e.z*2*e.z),target.z=1/12*mass*(2*e.y*2*e.y+2*e.x*2*e.x)});const worldCornerTempPos=new Vec3,worldCornersTemp=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3],BODY_SLEEP_STATES=(exports.BODY_TYPES={DYNAMIC:1,STATIC:2,KINEMATIC:4},exports.BODY_SLEEP_STATES={AWAKE:0,SLEEPY:1,SLEEPING:2});class Body extends EventTarget{constructor(options={}){super(),this.id=Body.idCounter++,this.index=-1,this.world=null,this.preStep=null,this.postStep=null,this.vlambda=new Vec3,this.collisionFilterGroup="number"==typeof options.collisionFilterGroup?options.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof options.collisionFilterMask?options.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof options.collisionResponse||options.collisionResponse,this.position=new Vec3,this.previousPosition=new Vec3,this.interpolatedPosition=new Vec3,this.initPosition=new Vec3,options.position&&(this.position.copy(options.position),this.previousPosition.copy(options.position),this.interpolatedPosition.copy(options.position),this.initPosition.copy(options.position)),this.velocity=new Vec3,options.velocity&&this.velocity.copy(options.velocity),this.initVelocity=new Vec3,this.force=new Vec3;const mass="number"==typeof options.mass?options.mass:0;this.mass=mass,this.invMass=mass>0?1/mass:0,this.material=options.material||null,this.linearDamping="number"==typeof options.linearDamping?options.linearDamping:.01,this.type=mass<=0?Body.STATIC:Body.DYNAMIC,typeof options.type==typeof Body.STATIC&&(this.type=options.type),this.allowSleep=void 0===options.allowSleep||options.allowSleep,this.sleepState=0,this.sleepSpeedLimit=void 0!==options.sleepSpeedLimit?options.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==options.sleepTimeLimit?options.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new Vec3,this.quaternion=new Quaternion,this.initQuaternion=new Quaternion,this.previousQuaternion=new Quaternion,this.interpolatedQuaternion=new Quaternion,options.quaternion&&(this.quaternion.copy(options.quaternion),this.initQuaternion.copy(options.quaternion),this.previousQuaternion.copy(options.quaternion),this.interpolatedQuaternion.copy(options.quaternion)),this.angularVelocity=new Vec3,options.angularVelocity&&this.angularVelocity.copy(options.angularVelocity),this.initAngularVelocity=new Vec3,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new Vec3,this.invInertia=new Vec3,this.invInertiaWorld=new Mat3,this.invMassSolve=0,this.invInertiaSolve=new Vec3,this.invInertiaWorldSolve=new Mat3,this.fixedRotation=void 0!==options.fixedRotation&&options.fixedRotation,this.angularDamping=void 0!==options.angularDamping?options.angularDamping:.01,this.linearFactor=new Vec3(1,1,1),options.linearFactor&&this.linearFactor.copy(options.linearFactor),this.angularFactor=new Vec3(1,1,1),options.angularFactor&&this.angularFactor.copy(options.angularFactor),this.aabb=new AABB,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new Vec3,options.shape&&this.addShape(options.shape),this.updateMassProperties()}wakeUp(){const prevState=this.sleepState;this.sleepState=0,this.wakeUpAfterNarrowphase=!1,prevState===Body.SLEEPING&&this.dispatchEvent(Body.wakeupEvent)}sleep(){this.sleepState=Body.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(time){if(this.allowSleep){const sleepState=this.sleepState,speedSquared=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),speedLimitSquared=this.sleepSpeedLimit**2;sleepState===Body.AWAKE&&speedSquared<speedLimitSquared?(this.sleepState=Body.SLEEPY,this.timeLastSleepy=time,this.dispatchEvent(Body.sleepyEvent)):sleepState===Body.SLEEPY&&speedSquared>speedLimitSquared?this.wakeUp():sleepState===Body.SLEEPY&&time-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(Body.sleepEvent))}}updateSolveMassProperties(){this.sleepState===Body.SLEEPING||this.type===Body.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(worldPoint,result=new Vec3){return worldPoint.vsub(this.position,result),this.quaternion.conjugate().vmult(result,result),result}vectorToLocalFrame(worldVector,result=new Vec3){return this.quaternion.conjugate().vmult(worldVector,result),result}pointToWorldFrame(localPoint,result=new Vec3){return this.quaternion.vmult(localPoint,result),result.vadd(this.position,result),result}vectorToWorldFrame(localVector,result=new Vec3){return this.quaternion.vmult(localVector,result),result}addShape(shape,_offset,_orientation){const offset=new Vec3,orientation=new Quaternion;return _offset&&offset.copy(_offset),_orientation&&orientation.copy(_orientation),this.shapes.push(shape),this.shapeOffsets.push(offset),this.shapeOrientations.push(orientation),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,shape.body=this,this}updateBoundingRadius(){const shapes=this.shapes,shapeOffsets=this.shapeOffsets,N=shapes.length;let radius=0;for(let i=0;i!==N;i++){const shape=shapes[i];shape.updateBoundingSphereRadius();const offset=shapeOffsets[i].length(),r=shape.boundingSphereRadius;offset+r>radius&&(radius=offset+r)}this.boundingRadius=radius}computeAABB(){const shapes=this.shapes,shapeOffsets=this.shapeOffsets,shapeOrientations=this.shapeOrientations,N=shapes.length,offset=tmpVec,orientation=tmpQuat$1,bodyQuat=this.quaternion,aabb=this.aabb,shapeAABB=computeAABB_shapeAABB;for(let i=0;i!==N;i++){const shape=shapes[i];bodyQuat.vmult(shapeOffsets[i],offset),offset.vadd(this.position,offset),bodyQuat.mult(shapeOrientations[i],orientation),shape.calculateWorldAABB(offset,orientation,shapeAABB.lowerBound,shapeAABB.upperBound),0===i?aabb.copy(shapeAABB):aabb.extend(shapeAABB)}this.aabbNeedsUpdate=!1}updateInertiaWorld(force){const I=this.invInertia;if(I.x!==I.y||I.y!==I.z||force){const m1=uiw_m1,m2=uiw_m2;m1.setRotationFromQuaternion(this.quaternion),m1.transpose(m2),m1.scale(I,m1),m1.mmult(m2,this.invInertiaWorld)}else;}applyForce(force,relativePoint){if(this.type!==Body.DYNAMIC)return;const rotForce=Body_applyForce_rotForce;relativePoint.cross(force,rotForce),this.force.vadd(force,this.force),this.torque.vadd(rotForce,this.torque)}applyLocalForce(localForce,localPoint){if(this.type!==Body.DYNAMIC)return;const worldForce=Body_applyLocalForce_worldForce,relativePointWorld=Body_applyLocalForce_relativePointWorld;this.vectorToWorldFrame(localForce,worldForce),this.vectorToWorldFrame(localPoint,relativePointWorld),this.applyForce(worldForce,relativePointWorld)}applyImpulse(impulse,relativePoint){if(this.type!==Body.DYNAMIC)return;const r=relativePoint,velo=Body_applyImpulse_velo;velo.copy(impulse),velo.scale(this.invMass,velo),this.velocity.vadd(velo,this.velocity);const rotVelo=Body_applyImpulse_rotVelo;r.cross(impulse,rotVelo),this.invInertiaWorld.vmult(rotVelo,rotVelo),this.angularVelocity.vadd(rotVelo,this.angularVelocity)}applyLocalImpulse(localImpulse,localPoint){if(this.type!==Body.DYNAMIC)return;const worldImpulse=Body_applyLocalImpulse_worldImpulse,relativePointWorld=Body_applyLocalImpulse_relativePoint;this.vectorToWorldFrame(localImpulse,worldImpulse),this.vectorToWorldFrame(localPoint,relativePointWorld),this.applyImpulse(worldImpulse,relativePointWorld)}updateMassProperties(){const halfExtents=Body_updateMassProperties_halfExtents;this.invMass=this.mass>0?1/this.mass:0;const I=this.inertia,fixed=this.fixedRotation;this.computeAABB(),halfExtents.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Box.calculateInertia(halfExtents,this.mass,I),this.invInertia.set(I.x>0&&!fixed?1/I.x:0,I.y>0&&!fixed?1/I.y:0,I.z>0&&!fixed?1/I.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(worldPoint,result){const r=new Vec3;return worldPoint.vsub(this.position,r),this.angularVelocity.cross(r,result),this.velocity.vadd(result,result),result}integrate(dt,quatNormalize,quatNormalizeFast){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==Body.DYNAMIC&&this.type!==Body.KINEMATIC||this.sleepState===Body.SLEEPING)return;const velo=this.velocity,angularVelo=this.angularVelocity,pos=this.position,force=this.force,torque=this.torque,quat=this.quaternion,invMass=this.invMass,invInertia=this.invInertiaWorld,linearFactor=this.linearFactor,iMdt=invMass*dt;velo.x+=force.x*iMdt*linearFactor.x,velo.y+=force.y*iMdt*linearFactor.y,velo.z+=force.z*iMdt*linearFactor.z;const e=invInertia.elements,angularFactor=this.angularFactor,tx=torque.x*angularFactor.x,ty=torque.y*angularFactor.y,tz=torque.z*angularFactor.z;angularVelo.x+=dt*(e[0]*tx+e[1]*ty+e[2]*tz),angularVelo.y+=dt*(e[3]*tx+e[4]*ty+e[5]*tz),angularVelo.z+=dt*(e[6]*tx+e[7]*ty+e[8]*tz),pos.x+=velo.x*dt,pos.y+=velo.y*dt,pos.z+=velo.z*dt,quat.integrate(this.angularVelocity,dt,this.angularFactor,quat),quatNormalize&&(quatNormalizeFast?quat.normalizeFast():quat.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}exports.Body=Body,Body.COLLIDE_EVENT_NAME="collide",Body.DYNAMIC=1,Body.STATIC=2,Body.KINEMATIC=4,Body.AWAKE=BODY_SLEEP_STATES.AWAKE,Body.SLEEPY=BODY_SLEEP_STATES.SLEEPY,Body.SLEEPING=BODY_SLEEP_STATES.SLEEPING,Body.idCounter=0,Body.wakeupEvent={type:"wakeup"},Body.sleepyEvent={type:"sleepy"},Body.sleepEvent={type:"sleep"};const tmpVec=new Vec3,tmpQuat$1=new Quaternion,computeAABB_shapeAABB=new AABB,uiw_m1=new Mat3,uiw_m2=new Mat3,Body_applyForce_rotForce=new Vec3,Body_applyLocalForce_worldForce=new Vec3,Body_applyLocalForce_relativePointWorld=new Vec3,Body_applyImpulse_velo=new Vec3,Body_applyImpulse_rotVelo=new Vec3,Body_applyLocalImpulse_worldImpulse=new Vec3,Body_applyLocalImpulse_relativePoint=new Vec3,Body_updateMassProperties_halfExtents=new Vec3;class Broadphase{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(world,p1,p2){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(bodyA,bodyB){return 0!=(bodyA.collisionFilterGroup&bodyB.collisionFilterMask)&&0!=(bodyB.collisionFilterGroup&bodyA.collisionFilterMask)&&(0==(bodyA.type&Body.STATIC)&&bodyA.sleepState!==Body.SLEEPING||0==(bodyB.type&Body.STATIC)&&bodyB.sleepState!==Body.SLEEPING)}intersectionTest(bodyA,bodyB,pairs1,pairs2){this.useBoundingBoxes?this.doBoundingBoxBroadphase(bodyA,bodyB,pairs1,pairs2):this.doBoundingSphereBroadphase(bodyA,bodyB,pairs1,pairs2)}doBoundingSphereBroadphase(bodyA,bodyB,pairs1,pairs2){const r=Broadphase_collisionPairs_r;bodyB.position.vsub(bodyA.position,r);const boundingRadiusSum2=(bodyA.boundingRadius+bodyB.boundingRadius)**2;r.lengthSquared()<boundingRadiusSum2&&(pairs1.push(bodyA),pairs2.push(bodyB))}doBoundingBoxBroadphase(bodyA,bodyB,pairs1,pairs2){bodyA.aabbNeedsUpdate&&bodyA.computeAABB(),bodyB.aabbNeedsUpdate&&bodyB.computeAABB(),bodyA.aabb.overlaps(bodyB.aabb)&&(pairs1.push(bodyA),pairs2.push(bodyB))}makePairsUnique(pairs1,pairs2){const t=Broadphase_makePairsUnique_temp,p1=Broadphase_makePairsUnique_p1,p2=Broadphase_makePairsUnique_p2,N=pairs1.length;for(let i=0;i!==N;i++)p1[i]=pairs1[i],p2[i]=pairs2[i];pairs1.length=0,pairs2.length=0;for(let i=0;i!==N;i++){const id1=p1[i].id,id2=p2[i].id,key=id1<id2?id1+","+id2:id2+","+id1;t[key]=i,t.keys.push(key)}for(let i=0;i!==t.keys.length;i++){const key=t.keys.pop(),pairIndex=t[key];pairs1.push(p1[pairIndex]),pairs2.push(p2[pairIndex]),delete t[key]}}setWorld(world){}aabbQuery(world,aabb,result){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}exports.Broadphase=Broadphase;const Broadphase_collisionPairs_r=new Vec3,Broadphase_makePairsUnique_temp={keys:[]},Broadphase_makePairsUnique_p1=[],Broadphase_makePairsUnique_p2=[];Broadphase.boundingSphereCheck=((bodyA,bodyB)=>{const dist=new Vec3;bodyA.position.vsub(bodyB.position,dist);const sa=bodyA.shapes[0],sb=bodyB.shapes[0];return Math.pow(sa.boundingSphereRadius+sb.boundingSphereRadius,2)>dist.lengthSquared()});exports.GridBroadphase=class extends Broadphase{constructor(aabbMin=new Vec3(100,100,100),aabbMax=new Vec3(-100,-100,-100),nx=10,ny=10,nz=10){super(),this.nx=nx,this.ny=ny,this.nz=nz,this.aabbMin=aabbMin,this.aabbMax=aabbMax;const nbins=this.nx*this.ny*this.nz;if(nbins<=0)throw"GridBroadphase: Each dimension's n must be >0";this.bins=[],this.binLengths=[],this.bins.length=nbins,this.binLengths.length=nbins;for(let i=0;i<nbins;i++)this.bins[i]=[],this.binLengths[i]=0}collisionPairs(world,pairs1,pairs2){const N=world.numObjects(),bodies=world.bodies,max=this.aabbMax,min=this.aabbMin,nx=this.nx,ny=this.ny,nz=this.nz,xstep=ny*nz,ystep=nz,zstep=1,xmax=max.x,ymax=max.y,zmax=max.z,xmin=min.x,ymin=min.y,zmin=min.z,xmult=nx/(xmax-xmin),ymult=ny/(ymax-ymin),zmult=nz/(zmax-zmin),binsizeX=(xmax-xmin)/nx,binsizeY=(ymax-ymin)/ny,binsizeZ=(zmax-zmin)/nz,binRadius=.5*Math.sqrt(binsizeX*binsizeX+binsizeY*binsizeY+binsizeZ*binsizeZ),types=Shape.types,SPHERE=types.SPHERE,PLANE=types.PLANE,bins=(types.BOX,types.COMPOUND,types.CONVEXPOLYHEDRON,this.bins),binLengths=this.binLengths,Nbins=this.bins.length;for(let i=0;i!==Nbins;i++)binLengths[i]=0;const ceil=Math.ceil;function addBoxToBins(x0,y0,z0,x1,y1,z1,bi){let xoff0=(x0-xmin)*xmult|0,yoff0=(y0-ymin)*ymult|0,zoff0=(z0-zmin)*zmult|0,xoff1=ceil((x1-xmin)*xmult),yoff1=ceil((y1-ymin)*ymult),zoff1=ceil((z1-zmin)*zmult);xoff0<0?xoff0=0:xoff0>=nx&&(xoff0=nx-1),yoff0<0?yoff0=0:yoff0>=ny&&(yoff0=ny-1),zoff0<0?zoff0=0:zoff0>=nz&&(zoff0=nz-1),xoff1<0?xoff1=0:xoff1>=nx&&(xoff1=nx-1),yoff1<0?yoff1=0:yoff1>=ny&&(yoff1=ny-1),zoff1<0?zoff1=0:zoff1>=nz&&(zoff1=nz-1),yoff0*=ystep,zoff0*=zstep,xoff1*=xstep,yoff1*=ystep,zoff1*=zstep;for(let xoff=xoff0*=xstep;xoff<=xoff1;xoff+=xstep)for(let yoff=yoff0;yoff<=yoff1;yoff+=ystep)for(let zoff=zoff0;zoff<=zoff1;zoff+=zstep){const idx=xoff+yoff+zoff;bins[idx][binLengths[idx]++]=bi}}for(let i=0;i!==N;i++){const bi=bodies[i],si=bi.shapes[0];switch(si.type){case SPHERE:{const shape=si,x=bi.position.x,y=bi.position.y,z=bi.position.z,r=shape.radius;addBoxToBins(x-r,y-r,z-r,x+r,y+r,z+r,bi);break}case PLANE:{const shape=si;shape.worldNormalNeedsUpdate&&shape.computeWorldNormal(bi.quaternion);const planeNormal=shape.worldNormal,xreset=xmin+.5*binsizeX-bi.position.x,yreset=ymin+.5*binsizeY-bi.position.y,zreset=zmin+.5*binsizeZ-bi.position.z,d=GridBroadphase_collisionPairs_d;d.set(xreset,yreset,zreset);for(let xi=0,xoff=0;xi!==nx;xi++,xoff+=xstep,d.y=yreset,d.x+=binsizeX)for(let yi=0,yoff=0;yi!==ny;yi++,yoff+=ystep,d.z=zreset,d.y+=binsizeY)for(let zi=0,zoff=0;zi!==nz;zi++,zoff+=zstep,d.z+=binsizeZ)if(d.dot(planeNormal)<binRadius){const idx=xoff+yoff+zoff;bins[idx][binLengths[idx]++]=bi}break}default:bi.aabbNeedsUpdate&&bi.computeAABB(),addBoxToBins(bi.aabb.lowerBound.x,bi.aabb.lowerBound.y,bi.aabb.lowerBound.z,bi.aabb.upperBound.x,bi.aabb.upperBound.y,bi.aabb.upperBound.z,bi)}}for(let i=0;i!==Nbins;i++){const binLength=binLengths[i];if(binLength>1){const bin=bins[i];for(let xi=0;xi!==binLength;xi++){const bi=bin[xi];for(let yi=0;yi!==xi;yi++){const bj=bin[yi];this.needBroadphaseCollision(bi,bj)&&this.intersectionTest(bi,bj,pairs1,pairs2)}}}}this.makePairsUnique(pairs1,pairs2)}};const GridBroadphase_collisionPairs_d=new Vec3;class NaiveBroadphase extends Broadphase{constructor(){super()}collisionPairs(world,pairs1,pairs2){const bodies=world.bodies,n=bodies.length;let bi,bj;for(let i=0;i!==n;i++)for(let j=0;j!==i;j++)bi=bodies[i],bj=bodies[j],this.needBroadphaseCollision(bi,bj)&&this.intersectionTest(bi,bj,pairs1,pairs2)}aabbQuery(world,aabb,result=[]){for(let i=0;i<world.bodies.length;i++){const b=world.bodies[i];b.aabbNeedsUpdate&&b.computeAABB(),b.aabb.overlaps(aabb)&&result.push(b)}return result}}exports.NaiveBroadphase=NaiveBroadphase;class RaycastResult{constructor(){this.rayFromWorld=new Vec3,this.rayToWorld=new Vec3,this.hitNormalWorld=new Vec3,this.hitPointWorld=new Vec3,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(rayFromWorld,rayToWorld,hitNormalWorld,hitPointWorld,shape,body,distance){this.rayFromWorld.copy(rayFromWorld),this.rayToWorld.copy(rayToWorld),this.hitNormalWorld.copy(hitNormalWorld),this.hitPointWorld.copy(hitPointWorld),this.shape=shape,this.body=body,this.distance=distance}}exports.RaycastResult=RaycastResult;exports.RAY_MODES={CLOSEST:1,ANY:2,ALL:4};class Ray{constructor(from=new Vec3,to=new Vec3){this.from=from.clone(),this.to=to.clone(),this.direction=new Vec3,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Ray.ANY,this.result=new RaycastResult,this.hasHit=!1,this.callback=(result=>{})}intersectWorld(world,options){return this.mode=options.mode||Ray.ANY,this.result=options.result||new RaycastResult,this.skipBackfaces=!!options.skipBackfaces,this.collisionFilterMask=void 0!==options.collisionFilterMask?options.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==options.collisionFilterGroup?options.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===options.checkCollisionResponse||options.checkCollisionResponse,options.from&&this.from.copy(options.from),options.to&&this.to.copy(options.to),this.callback=options.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(tmpAABB),tmpArray.length=0,world.broadphase.aabbQuery(world,tmpAABB,tmpArray),this.intersectBodies(tmpArray),this.hasHit}intersectBody(body,result){result&&(this.result=result,this.updateDirection());const checkCollisionResponse=this.checkCollisionResponse;if(checkCollisionResponse&&!body.collisionResponse)return;if(0==(this.collisionFilterGroup&body.collisionFilterMask)||0==(body.collisionFilterGroup&this.collisionFilterMask))return;const xi=intersectBody_xi,qi=intersectBody_qi;for(let i=0,N=body.shapes.length;i<N;i++){const shape=body.shapes[i];if((!checkCollisionResponse||shape.collisionResponse)&&(body.quaternion.mult(body.shapeOrientations[i],qi),body.quaternion.vmult(body.shapeOffsets[i],xi),xi.vadd(body.position,xi),this.intersectShape(shape,qi,xi,body),this.result.shouldStop))break}}intersectBodies(bodies,result){result&&(this.result=result,this.updateDirection());for(let i=0,l=bodies.length;!this.result.shouldStop&&i<l;i++)this.intersectBody(bodies[i])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(shape,quat,position,body){if(function(from,direction,position){position.vsub(from,v0);const dot=v0.dot(direction);return direction.scale(dot,intersect),intersect.vadd(from,intersect),position.distanceTo(intersect)}(this.from,this.direction,position)>shape.boundingSphereRadius)return;const intersectMethod=this[shape.type];intersectMethod&&intersectMethod.call(this,shape,quat,position,body,shape)}_intersectBox(box,quat,position,body,reportedShape){return this._intersectConvex(box.convexPolyhedronRepresentation,quat,position,body,reportedShape)}_intersectPlane(shape,quat,position,body,reportedShape){const from=this.from,to=this.to,direction=this.direction,worldNormal=new Vec3(0,0,1);quat.vmult(worldNormal,worldNormal);const len=new Vec3;from.vsub(position,len);const planeToFrom=len.dot(worldNormal);if(to.vsub(position,len),planeToFrom*len.dot(worldNormal)>0)return;if(from.distanceTo(to)<planeToFrom)return;const n_dot_dir=worldNormal.dot(direction);if(Math.abs(n_dot_dir)<this.precision)return;const planePointToFrom=new Vec3,dir_scaled_with_t=new Vec3,hitPointWorld=new Vec3;from.vsub(position,planePointToFrom);const t=-worldNormal.dot(planePointToFrom)/n_dot_dir;direction.scale(t,dir_scaled_with_t),from.vadd(dir_scaled_with_t,hitPointWorld),this.reportIntersection(worldNormal,hitPointWorld,reportedShape,body,-1)}getAABB(aabb){const{lowerBound:lowerBound,upperBound:upperBound}=aabb,to=this.to,from=this.from;lowerBound.x=Math.min(to.x,from.x),lowerBound.y=Math.min(to.y,from.y),lowerBound.z=Math.min(to.z,from.z),upperBound.x=Math.max(to.x,from.x),upperBound.y=Math.max(to.y,from.y),upperBound.z=Math.max(to.z,from.z)}_intersectHeightfield(shape,quat,position,body,reportedShape){shape.data,shape.elementSize;const localRay=intersectHeightfield_localRay;localRay.from.copy(this.from),localRay.to.copy(this.to),Transform.pointToLocalFrame(position,quat,localRay.from,localRay.from),Transform.pointToLocalFrame(position,quat,localRay.to,localRay.to),localRay.updateDirection();const index=intersectHeightfield_index;let iMinX,iMinY,iMaxX,iMaxY;iMinX=iMinY=0,iMaxX=iMaxY=shape.data.length-1;const aabb=new AABB;localRay.getAABB(aabb),shape.getIndexOfPosition(aabb.lowerBound.x,aabb.lowerBound.y,index,!0),iMinX=Math.max(iMinX,index[0]),iMinY=Math.max(iMinY,index[1]),shape.getIndexOfPosition(aabb.upperBound.x,aabb.upperBound.y,index,!0),iMaxX=Math.min(iMaxX,index[0]+1),iMaxY=Math.min(iMaxY,index[1]+1);for(let i=iMinX;i<iMaxX;i++)for(let j=iMinY;j<iMaxY;j++){if(this.result.shouldStop)return;if(shape.getAabbAtIndex(i,j,aabb),aabb.overlapsRay(localRay)){if(shape.getConvexTrianglePillar(i,j,!1),Transform.pointToWorldFrame(position,quat,shape.pillarOffset,worldPillarOffset),this._intersectConvex(shape.pillarConvex,quat,worldPillarOffset,body,reportedShape,intersectConvexOptions),this.result.shouldStop)return;shape.getConvexTrianglePillar(i,j,!0),Transform.pointToWorldFrame(position,quat,shape.pillarOffset,worldPillarOffset),this._intersectConvex(shape.pillarConvex,quat,worldPillarOffset,body,reportedShape,intersectConvexOptions)}}}_intersectSphere(sphere,quat,position,body,reportedShape){const from=this.from,to=this.to,r=sphere.radius,a=(to.x-from.x)**2+(to.y-from.y)**2+(to.z-from.z)**2,b=2*((to.x-from.x)*(from.x-position.x)+(to.y-from.y)*(from.y-position.y)+(to.z-from.z)*(from.z-position.z)),delta=b**2-4*a*((from.x-position.x)**2+(from.y-position.y)**2+(from.z-position.z)**2-r**2),intersectionPoint=Ray_intersectSphere_intersectionPoint,normal=Ray_intersectSphere_normal;if(!(delta<0))if(0===delta)from.lerp(to,delta,intersectionPoint),intersectionPoint.vsub(position,normal),normal.normalize(),this.reportIntersection(normal,intersectionPoint,reportedShape,body,-1);else{const d1=(-b-Math.sqrt(delta))/(2*a),d2=(-b+Math.sqrt(delta))/(2*a);if(d1>=0&&d1<=1&&(from.lerp(to,d1,intersectionPoint),intersectionPoint.vsub(position,normal),normal.normalize(),this.reportIntersection(normal,intersectionPoint,reportedShape,body,-1)),this.result.shouldStop)return;d2>=0&&d2<=1&&(from.lerp(to,d2,intersectionPoint),intersectionPoint.vsub(position,normal),normal.normalize(),this.reportIntersection(normal,intersectionPoint,reportedShape,body,-1))}}_intersectConvex(shape,quat,position,body,reportedShape,options){const normal=intersectConvex_normal,vector=intersectConvex_vector,faceList=options&&options.faceList||null,faces=shape.faces,vertices=shape.vertices,normals=shape.faceNormals,direction=this.direction,from=this.from,to=this.to,fromToDistance=from.distanceTo(to),Nfaces=faceList?faceList.length:faces.length,result=this.result;for(let j=0;!result.shouldStop&&j<Nfaces;j++){const fi=faceList?faceList[j]:j,face=faces[fi],faceNormal=normals[fi],q=quat,x=position;vector.copy(vertices[face[0]]),q.vmult(vector,vector),vector.vadd(x,vector),vector.vsub(from,vector),q.vmult(faceNormal,normal);const dot=direction.dot(normal);if(Math.abs(dot)<this.precision)continue;const scalar=normal.dot(vector)/dot;if(!(scalar<0)){direction.scale(scalar,intersectPoint),intersectPoint.vadd(from,intersectPoint),a.copy(vertices[face[0]]),q.vmult(a,a),x.vadd(a,a);for(let i=1;!result.shouldStop&&i<face.length-1;i++){b.copy(vertices[face[i]]),c.copy(vertices[face[i+1]]),q.vmult(b,b),q.vmult(c,c),x.vadd(b,b),x.vadd(c,c);const distance=intersectPoint.distanceTo(from);!pointInTriangle(intersectPoint,a,b,c)&&!pointInTriangle(intersectPoint,b,a,c)||distance>fromToDistance||this.reportIntersection(normal,intersectPoint,reportedShape,body,fi)}}}}_intersectTrimesh(mesh,quat,position,body,reportedShape,options){const normal=intersectTrimesh_normal,triangles=intersectTrimesh_triangles,treeTransform=intersectTrimesh_treeTransform,vector=intersectConvex_vector,localDirection=intersectTrimesh_localDirection,localFrom=intersectTrimesh_localFrom,localTo=intersectTrimesh_localTo,worldIntersectPoint=intersectTrimesh_worldIntersectPoint,worldNormal=intersectTrimesh_worldNormal,indices=(options&&options.faceList,mesh.indices),from=(mesh.vertices,this.from),to=this.to,direction=this.direction;treeTransform.position.copy(position),treeTransform.quaternion.copy(quat),Transform.vectorToLocalFrame(position,quat,direction,localDirection),Transform.pointToLocalFrame(position,quat,from,localFrom),Transform.pointToLocalFrame(position,quat,to,localTo),localTo.x*=mesh.scale.x,localTo.y*=mesh.scale.y,localTo.z*=mesh.scale.z,localFrom.x*=mesh.scale.x,localFrom.y*=mesh.scale.y,localFrom.z*=mesh.scale.z,localTo.vsub(localFrom,localDirection),localDirection.normalize();const fromToDistanceSquared=localFrom.distanceSquared(localTo);mesh.tree.rayQuery(this,treeTransform,triangles);for(let i=0,N=triangles.length;!this.result.shouldStop&&i!==N;i++){const trianglesIndex=triangles[i];mesh.getNormal(trianglesIndex,normal),mesh.getVertex(indices[3*trianglesIndex],a),a.vsub(localFrom,vector);const dot=localDirection.dot(normal),scalar=normal.dot(vector)/dot;if(scalar<0)continue;localDirection.scale(scalar,intersectPoint),intersectPoint.vadd(localFrom,intersectPoint),mesh.getVertex(indices[3*trianglesIndex+1],b),mesh.getVertex(indices[3*trianglesIndex+2],c);const squaredDistance=intersectPoint.distanceSquared(localFrom);!pointInTriangle(intersectPoint,b,a,c)&&!pointInTriangle(intersectPoint,a,b,c)||squaredDistance>fromToDistanceSquared||(Transform.vectorToWorldFrame(quat,normal,worldNormal),Transform.pointToWorldFrame(position,quat,intersectPoint,worldIntersectPoint),this.reportIntersection(worldNormal,worldIntersectPoint,reportedShape,body,trianglesIndex))}triangles.length=0}reportIntersection(normal,hitPointWorld,shape,body,hitFaceIndex){const from=this.from,to=this.to,distance=from.distanceTo(hitPointWorld),result=this.result;if(!(this.skipBackfaces&&normal.dot(this.direction)>0))switch(result.hitFaceIndex=void 0!==hitFaceIndex?hitFaceIndex:-1,this.mode){case Ray.ALL:this.hasHit=!0,result.set(from,to,normal,hitPointWorld,shape,body,distance),result.hasHit=!0,this.callback(result);break;case Ray.CLOSEST:(distance<result.distance||!result.hasHit)&&(this.hasHit=!0,result.hasHit=!0,result.set(from,to,normal,hitPointWorld,shape,body,distance));break;case Ray.ANY:this.hasHit=!0,result.hasHit=!0,result.set(from,to,normal,hitPointWorld,shape,body,distance),result.shouldStop=!0}}}exports.Ray=Ray,Ray.CLOSEST=1,Ray.ANY=2,Ray.ALL=4;const tmpAABB=new AABB,tmpArray=[],v1=new Vec3,v2=new Vec3;function pointInTriangle(p,a,b,c){c.vsub(a,v0),b.vsub(a,v1),p.vsub(a,v2);const dot00=v0.dot(v0),dot01=v0.dot(v1),dot02=v0.dot(v2),dot11=v1.dot(v1),dot12=v1.dot(v2);let u,v;return(u=dot11*dot02-dot01*dot12)>=0&&(v=dot00*dot12-dot01*dot02)>=0&&u+v<dot00*dot11-dot01*dot01}Ray.pointInTriangle=pointInTriangle;const intersectBody_xi=new Vec3,intersectBody_qi=new Quaternion,intersectPoint=new Vec3,a=new Vec3,b=new Vec3,c=new Vec3;Ray.prototype[Shape.types.BOX]=Ray.prototype._intersectBox,Ray.prototype[Shape.types.PLANE]=Ray.prototype._intersectPlane;const intersectConvexOptions={faceList:[0]},worldPillarOffset=new Vec3,intersectHeightfield_localRay=new Ray,intersectHeightfield_index=[];Ray.prototype[Shape.types.HEIGHTFIELD]=Ray.prototype._intersectHeightfield;const Ray_intersectSphere_intersectionPoint=new Vec3,Ray_intersectSphere_normal=new Vec3;Ray.prototype[Shape.types.SPHERE]=Ray.prototype._intersectSphere;const intersectConvex_normal=new Vec3,intersectConvex_vector=new Vec3;Ray.prototype[Shape.types.CONVEXPOLYHEDRON]=Ray.prototype._intersectConvex;const intersectTrimesh_normal=new Vec3,intersectTrimesh_localDirection=new Vec3,intersectTrimesh_localFrom=new Vec3,intersectTrimesh_localTo=new Vec3,intersectTrimesh_worldNormal=new Vec3,intersectTrimesh_worldIntersectPoint=new Vec3,intersectTrimesh_triangles=(new AABB,[]),intersectTrimesh_treeTransform=new Transform;Ray.prototype[Shape.types.TRIMESH]=Ray.prototype._intersectTrimesh;const v0=new Vec3,intersect=new Vec3;class SAPBroadphase extends Broadphase{constructor(world){super(),this.axisList=[],this.world=null,this.axisIndex=0;const axisList=this.axisList;this._addBodyHandler=(event=>{axisList.push(event.body)}),this._removeBodyHandler=(event=>{const idx=axisList.indexOf(event.body);-1!==idx&&axisList.splice(idx,1)}),world&&this.setWorld(world)}setWorld(world){this.axisList.length=0;for(let i=0;i<world.bodies.length;i++)this.axisList.push(world.bodies[i]);world.removeEventListener("addBody",this._addBodyHandler),world.removeEventListener("removeBody",this._removeBodyHandler),world.addEventListener("addBody",this._addBodyHandler),world.addEventListener("removeBody",this._removeBodyHandler),this.world=world,this.dirty=!0}collisionPairs(world,p1,p2){const bodies=this.axisList,N=bodies.length,axisIndex=this.axisIndex;let i,j;for(this.dirty&&(this.sortList(),this.dirty=!1),i=0;i!==N;i++){const bi=bodies[i];for(j=i+1;j<N;j++){const bj=bodies[j];if(this.needBroadphaseCollision(bi,bj)){if(!SAPBroadphase.checkBounds(bi,bj,axisIndex))break;this.intersectionTest(bi,bj,p1,p2)}}}}sortList(){const axisList=this.axisList,axisIndex=this.axisIndex,N=axisList.length;for(let i=0;i!==N;i++){const bi=axisList[i];bi.aabbNeedsUpdate&&bi.computeAABB()}0===axisIndex?SAPBroadphase.insertionSortX(axisList):1===axisIndex?SAPBroadphase.insertionSortY(axisList):2===axisIndex&&SAPBroadphase.insertionSortZ(axisList)}autoDetectAxis(){let sumX=0,sumX2=0,sumY=0,sumY2=0,sumZ=0,sumZ2=0;const bodies=this.axisList,N=bodies.length,invN=1/N;for(let i=0;i!==N;i++){const b=bodies[i],centerX=b.position.x;sumX+=centerX,sumX2+=centerX*centerX;const centerY=b.position.y;sumY+=centerY,sumY2+=centerY*centerY;const centerZ=b.position.z;sumZ+=centerZ,sumZ2+=centerZ*centerZ}const varianceX=sumX2-sumX*sumX*invN,varianceY=sumY2-sumY*sumY*invN,varianceZ=sumZ2-sumZ*sumZ*invN;this.axisIndex=varianceX>varianceY?varianceX>varianceZ?0:2:varianceY>varianceZ?1:2}aabbQuery(world,aabb,result=[]){this.dirty&&(this.sortList(),this.dirty=!1);const axisIndex=this.axisIndex;let axis="x";1===axisIndex&&(axis="y"),2===axisIndex&&(axis="z");const axisList=this.axisList;aabb.lowerBound[axis],aabb.upperBound[axis];for(let i=0;i<axisList.length;i++){const b=axisList[i];b.aabbNeedsUpdate&&b.computeAABB(),b.aabb.overlaps(aabb)&&result.push(b)}return result}}function Utils(){}exports.SAPBroadphase=SAPBroadphase,SAPBroadphase.insertionSortX=(a=>{for(let i=1,l=a.length;i<l;i++){const v=a[i];let j;for(j=i-1;j>=0&&!(a[j].aabb.lowerBound.x<=v.aabb.lowerBound.x);j--)a[j+1]=a[j];a[j+1]=v}return a}),SAPBroadphase.insertionSortY=(a=>{for(let i=1,l=a.length;i<l;i++){const v=a[i];let j;for(j=i-1;j>=0&&!(a[j].aabb.lowerBound.y<=v.aabb.lowerBound.y);j--)a[j+1]=a[j];a[j+1]=v}return a}),SAPBroadphase.insertionSortZ=(a=>{for(let i=1,l=a.length;i<l;i++){const v=a[i];let j;for(j=i-1;j>=0&&!(a[j].aabb.lowerBound.z<=v.aabb.lowerBound.z);j--)a[j+1]=a[j];a[j+1]=v}return a}),SAPBroadphase.checkBounds=((bi,bj,axisIndex)=>{let biPos,bjPos;0===axisIndex?(biPos=bi.position.x,bjPos=bj.position.x):1===axisIndex?(biPos=bi.position.y,bjPos=bj.position.y):2===axisIndex&&(biPos=bi.position.z,bjPos=bj.position.z);const ri=bi.boundingRadius;return bjPos-bj.boundingRadius<biPos+ri}),Utils.defaults=((options={},defaults)=>{for(let key in defaults)key in options||(options[key]=defaults[key]);return options});class Constraint{constructor(bodyA,bodyB,options={}){options=Utils.defaults(options,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=bodyA,this.bodyB=bodyB,this.id=Constraint.idCounter++,this.collideConnected=options.collideConnected,options.wakeUpBodies&&(bodyA&&bodyA.wakeUp(),bodyB&&bodyB.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const eqs=this.equations;for(let i=0;i<eqs.length;i++)eqs[i].enabled=!0}disable(){const eqs=this.equations;for(let i=0;i<eqs.length;i++)eqs[i].enabled=!1}}exports.Constraint=Constraint,Constraint.idCounter=0;class JacobianElement{constructor(){this.spatial=new Vec3,this.rotational=new Vec3}multiplyElement(element){return element.spatial.dot(this.spatial)+element.rotational.dot(this.rotational)}multiplyVectors(spatial,rotational){return spatial.dot(this.spatial)+rotational.dot(this.rotational)}}exports.JacobianElement=JacobianElement;class Equation{constructor(bi,bj,minForce=-1e6,maxForce=1e6){this.id=Equation.id++,this.minForce=minForce,this.maxForce=maxForce,this.bi=bi,this.bj=bj,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new JacobianElement,this.jacobianElementB=new JacobianElement,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(stiffness,relaxation,timeStep){const d=relaxation,k=stiffness,h=timeStep;this.a=4/(h*(1+4*d)),this.b=4*d/(1+4*d),this.eps=4/(h*h*k*(1+4*d))}computeB(a,b,h){const GW=this.computeGW();return-this.computeGq()*a-GW*b-this.computeGiMf()*h}computeGq(){const GA=this.jacobianElementA,GB=this.jacobianElementB,bi=this.bi,bj=this.bj,xi=bi.position,xj=bj.position;return GA.spatial.dot(xi)+GB.spatial.dot(xj)}computeGW(){const GA=this.jacobianElementA,GB=this.jacobianElementB,bi=this.bi,bj=this.bj,vi=bi.velocity,vj=bj.velocity,wi=bi.angularVelocity,wj=bj.angularVelocity;return GA.multiplyVectors(vi,wi)+GB.multiplyVectors(vj,wj)}computeGWlambda(){const GA=this.jacobianElementA,GB=this.jacobianElementB,bi=this.bi,bj=this.bj,vi=bi.vlambda,vj=bj.vlambda,wi=bi.wlambda,wj=bj.wlambda;return GA.multiplyVectors(vi,wi)+GB.multiplyVectors(vj,wj)}computeGiMf(){const GA=this.jacobianElementA,GB=this.jacobianElementB,bi=this.bi,bj=this.bj,fi=bi.force,ti=bi.torque,fj=bj.force,tj=bj.torque,invMassi=bi.invMassSolve,invMassj=bj.invMassSolve;return fi.scale(invMassi,iMfi),fj.scale(invMassj,iMfj),bi.invInertiaWorldSolve.vmult(ti,invIi_vmult_taui),bj.invInertiaWorldSolve.vmult(tj,invIj_vmult_tauj),GA.multiplyVectors(iMfi,invIi_vmult_taui)+GB.multiplyVectors(iMfj,invIj_vmult_tauj)}computeGiMGt(){const GA=this.jacobianElementA,GB=this.jacobianElementB,bi=this.bi,bj=this.bj,invMassi=bi.invMassSolve,invMassj=bj.invMassSolve,invIi=bi.invInertiaWorldSolve,invIj=bj.invInertiaWorldSolve;let result=invMassi+invMassj;return invIi.vmult(GA.rotational,tmp$1),result+=tmp$1.dot(GA.rotational),invIj.vmult(GB.rotational,tmp$1),result+=tmp$1.dot(GB.rotational)}addToWlambda(deltalambda){const GA=this.jacobianElementA,GB=this.jacobianElementB,bi=this.bi,bj=this.bj,temp=addToWlambda_temp;bi.vlambda.addScaledVector(bi.invMassSolve*deltalambda,GA.spatial,bi.vlambda),bj.vlambda.addScaledVector(bj.invMassSolve*deltalambda,GB.spatial,bj.vlambda),bi.invInertiaWorldSolve.vmult(GA.rotational,temp),bi.wlambda.addScaledVector(deltalambda,temp,bi.wlambda),bj.invInertiaWorldSolve.vmult(GB.rotational,temp),bj.wlambda.addScaledVector(deltalambda,temp,bj.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}exports.Equation=Equation,Equation.id=0;const iMfi=new Vec3,iMfj=new Vec3,invIi_vmult_taui=new Vec3,invIj_vmult_tauj=new Vec3,tmp$1=new Vec3,addToWlambda_temp=new Vec3;class ContactEquation extends Equation{constructor(bodyA,bodyB,maxForce=1e6){super(bodyA,bodyB,0,maxForce),this.restitution=0,this.ri=new Vec3,this.rj=new Vec3,this.ni=new Vec3}computeB(h){const a=this.a,b=this.b,bi=this.bi,bj=this.bj,ri=this.ri,rj=this.rj,rixn=ContactEquation_computeB_temp1,rjxn=ContactEquation_computeB_temp2,vi=bi.velocity,wi=bi.angularVelocity,vj=(bi.force,bi.torque,bj.velocity),wj=bj.angularVelocity,penetrationVec=(bj.force,bj.torque,ContactEquation_computeB_temp3),GA=this.jacobianElementA,GB=this.jacobianElementB,n=this.ni;ri.cross(n,rixn),rj.cross(n,rjxn),n.negate(GA.spatial),rixn.negate(GA.rotational),GB.spatial.copy(n),GB.rotational.copy(rjxn),penetrationVec.copy(bj.position),penetrationVec.vadd(rj,penetrationVec),penetrationVec.vsub(bi.position,penetrationVec),penetrationVec.vsub(ri,penetrationVec);const g=n.dot(penetrationVec),ePlusOne=this.restitution+1;return-g*a-(ePlusOne*vj.dot(n)-ePlusOne*vi.dot(n)+wj.dot(rjxn)-wi.dot(rixn))*b-h*this.computeGiMf()}getImpactVelocityAlongNormal(){const vi=ContactEquation_getImpactVelocityAlongNormal_vi,vj=ContactEquation_getImpactVelocityAlongNormal_vj,xi=ContactEquation_getImpactVelocityAlongNormal_xi,xj=ContactEquation_getImpactVelocityAlongNormal_xj,relVel=ContactEquation_getImpactVelocityAlongNormal_relVel;return this.bi.position.vadd(this.ri,xi),this.bj.position.vadd(this.rj,xj),this.bi.getVelocityAtWorldPoint(xi,vi),this.bj.getVelocityAtWorldPoint(xj,vj),vi.vsub(vj,relVel),this.ni.dot(relVel)}}exports.ContactEquation=ContactEquation;const ContactEquation_computeB_temp1=new Vec3,ContactEquation_computeB_temp2=new Vec3,ContactEquation_computeB_temp3=new Vec3,ContactEquation_getImpactVelocityAlongNormal_vi=new Vec3,ContactEquation_getImpactVelocityAlongNormal_vj=new Vec3,ContactEquation_getImpactVelocityAlongNormal_xi=new Vec3,ContactEquation_getImpactVelocityAlongNormal_xj=new Vec3,ContactEquation_getImpactVelocityAlongNormal_relVel=new Vec3;class PointToPointConstraint extends Constraint{constructor(bodyA,pivotA=new Vec3,bodyB,pivotB=new Vec3,maxForce=1e6){super(bodyA,bodyB),this.pivotA=pivotA.clone(),this.pivotB=pivotB.clone();const x=this.equationX=new ContactEquation(bodyA,bodyB),y=this.equationY=new ContactEquation(bodyA,bodyB),z=this.equationZ=new ContactEquation(bodyA,bodyB);this.equations.push(x,y,z),x.minForce=y.minForce=z.minForce=-maxForce,x.maxForce=y.maxForce=z.maxForce=maxForce,x.ni.set(1,0,0),y.ni.set(0,1,0),z.ni.set(0,0,1)}update(){const bodyA=this.bodyA,bodyB=this.bodyB,x=this.equationX,y=this.equationY,z=this.equationZ;bodyA.quaternion.vmult(this.pivotA,x.ri),bodyB.quaternion.vmult(this.pivotB,x.rj),y.ri.copy(x.ri),y.rj.copy(x.rj),z.ri.copy(x.ri),z.rj.copy(x.rj)}}exports.PointToPointConstraint=PointToPointConstraint;class ConeEquation extends Equation{constructor(bodyA,bodyB,options={}){const maxForce=void 0!==options.maxForce?options.maxForce:1e6;super(bodyA,bodyB,-maxForce,maxForce),this.axisA=options.axisA?options.axisA.clone():new Vec3(1,0,0),this.axisB=options.axisB?options.axisB.clone():new Vec3(0,1,0),this.angle=void 0!==options.angle?options.angle:0}computeB(h){const a=this.a,b=this.b,ni=this.axisA,nj=this.axisB,nixnj=tmpVec1,njxni=tmpVec2,GA=this.jacobianElementA,GB=this.jacobianElementB;return ni.cross(nj,nixnj),nj.cross(ni,njxni),GA.rotational.copy(njxni),GB.rotational.copy(nixnj),-(Math.cos(this.angle)-ni.dot(nj))*a-this.computeGW()*b-h*this.computeGiMf()}}const tmpVec1=new Vec3,tmpVec2=new Vec3;class RotationalEquation extends Equation{constructor(bodyA,bodyB,options={}){const maxForce=void 0!==options.maxForce?options.maxForce:1e6;super(bodyA,bodyB,-maxForce,maxForce),this.axisA=options.axisA?options.axisA.clone():new Vec3(1,0,0),this.axisB=options.axisB?options.axisB.clone():new Vec3(0,1,0),this.maxAngle=Math.PI/2}computeB(h){const a=this.a,b=this.b,ni=this.axisA,nj=this.axisB,nixnj=tmpVec1$1,njxni=tmpVec2$1,GA=this.jacobianElementA,GB=this.jacobianElementB;return ni.cross(nj,nixnj),nj.cross(ni,njxni),GA.rotational.copy(njxni),GB.rotational.copy(nixnj),-(Math.cos(this.maxAngle)-ni.dot(nj))*a-this.computeGW()*b-h*this.computeGiMf()}}exports.RotationalEquation=RotationalEquation;const tmpVec1$1=new Vec3,tmpVec2$1=new Vec3;exports.ConeTwistConstraint=class extends PointToPointConstraint{constructor(bodyA,bodyB,options={}){const maxForce=void 0!==options.maxForce?options.maxForce:1e6;super(bodyA,options.pivotA?options.pivotA.clone():new Vec3,bodyB,options.pivotB?options.pivotB.clone():new Vec3,maxForce),this.axisA=options.axisA?options.axisA.clone():new Vec3,this.axisB=options.axisB?options.axisB.clone():new Vec3,this.collideConnected=!!options.collideConnected,this.angle=void 0!==options.angle?options.angle:0;const c=this.coneEquation=new ConeEquation(bodyA,bodyB,options),t=this.twistEquation=new RotationalEquation(bodyA,bodyB,options);this.twistAngle=void 0!==options.twistAngle?options.twistAngle:0,c.maxForce=0,c.minForce=-maxForce,t.maxForce=0,t.minForce=-maxForce,this.equations.push(c,t)}update(){const bodyA=this.bodyA,bodyB=this.bodyB,cone=this.coneEquation,twist=this.twistEquation;super.update(),bodyA.vectorToWorldFrame(this.axisA,cone.axisA),bodyB.vectorToWorldFrame(this.axisB,cone.axisB),this.axisA.tangents(twist.axisA,twist.axisA),bodyA.vectorToWorldFrame(twist.axisA,twist.axisA),this.axisB.tangents(twist.axisB,twist.axisB),bodyB.vectorToWorldFrame(twist.axisB,twist.axisB),cone.angle=this.angle,twist.maxAngle=this.twistAngle}};exports.DistanceConstraint=class extends Constraint{constructor(bodyA,bodyB,distance,maxForce=1e6){super(bodyA,bodyB),void 0===distance&&(distance=bodyA.position.distanceTo(bodyB.position)),this.distance=distance;const eq=this.distanceEquation=new ContactEquation(bodyA,bodyB);this.equations.push(eq),eq.minForce=-maxForce,eq.maxForce=maxForce}update(){const bodyA=this.bodyA,bodyB=this.bodyB,eq=this.distanceEquation,halfDist=.5*this.distance,normal=eq.ni;bodyB.position.vsub(bodyA.position,normal),normal.normalize(),normal.scale(halfDist,eq.ri),normal.scale(-halfDist,eq.rj)}};exports.LockConstraint=class extends PointToPointConstraint{constructor(bodyA,bodyB,options={}){const maxForce=void 0!==options.maxForce?options.maxForce:1e6,pivotA=new Vec3,pivotB=new Vec3,halfWay=new Vec3;bodyA.position.vadd(bodyB.position,halfWay),halfWay.scale(.5,halfWay),bodyB.pointToLocalFrame(halfWay,pivotB),bodyA.pointToLocalFrame(halfWay,pivotA),super(bodyA,pivotA,bodyB,pivotB,maxForce),this.xA=bodyA.vectorToLocalFrame(Vec3.UNIT_X),this.xB=bodyB.vectorToLocalFrame(Vec3.UNIT_X),this.yA=bodyA.vectorToLocalFrame(Vec3.UNIT_Y),this.yB=bodyB.vectorToLocalFrame(Vec3.UNIT_Y),this.zA=bodyA.vectorToLocalFrame(Vec3.UNIT_Z),this.zB=bodyB.vectorToLocalFrame(Vec3.UNIT_Z);const r1=this.rotationalEquation1=new RotationalEquation(bodyA,bodyB,options),r2=this.rotationalEquation2=new RotationalEquation(bodyA,bodyB,options),r3=this.rotationalEquation3=new RotationalEquation(bodyA,bodyB,options);this.equations.push(r1,r2,r3)}update(){const bodyA=this.bodyA,bodyB=this.bodyB,r1=(this.motorEquation,this.rotationalEquation1),r2=this.rotationalEquation2,r3=this.rotationalEquation3;super.update(),bodyA.vectorToWorldFrame(this.xA,r1.axisA),bodyB.vectorToWorldFrame(this.yB,r1.axisB),bodyA.vectorToWorldFrame(this.yA,r2.axisA),bodyB.vectorToWorldFrame(this.zB,r2.axisB),bodyA.vectorToWorldFrame(this.zA,r3.axisA),bodyB.vectorToWorldFrame(this.xB,r3.axisB)}};class RotationalMotorEquation extends Equation{constructor(bodyA,bodyB,maxForce=1e6){super(bodyA,bodyB,-maxForce,maxForce),this.axisA=new Vec3,this.axisB=new Vec3,this.targetVelocity=0}computeB(h){this.a;const b=this.b,axisA=(this.bi,this.bj,this.axisA),axisB=this.axisB,GA=this.jacobianElementA,GB=this.jacobianElementB;return GA.rotational.copy(axisA),axisB.negate(GB.rotational),-(this.computeGW()-this.targetVelocity)*b-h*this.computeGiMf()}}exports.RotationalMotorEquation=RotationalMotorEquation;class HingeConstraint extends PointToPointConstraint{constructor(bodyA,bodyB,options={}){const maxForce=void 0!==options.maxForce?options.maxForce:1e6;super(bodyA,options.pivotA?options.pivotA.clone():new Vec3,bodyB,options.pivotB?options.pivotB.clone():new Vec3,maxForce),(this.axisA=options.axisA?options.axisA.clone():new Vec3(1,0,0)).normalize(),(this.axisB=options.axisB?options.axisB.clone():new Vec3(1,0,0)).normalize(),this.collideConnected=!!options.collideConnected;const rotational1=this.rotationalEquation1=new RotationalEquation(bodyA,bodyB,options),rotational2=this.rotationalEquation2=new RotationalEquation(bodyA,bodyB,options),motor=this.motorEquation=new RotationalMotorEquation(bodyA,bodyB,maxForce);motor.enabled=!1,this.equations.push(rotational1,rotational2,motor)}enableMotor(){this.motorEquation.enabled=!0}disableMotor(){this.motorEquation.enabled=!1}setMotorSpeed(speed){this.motorEquation.targetVelocity=speed}setMotorMaxForce(maxForce){this.motorEquation.maxForce=maxForce,this.motorEquation.minForce=-maxForce}update(){const bodyA=this.bodyA,bodyB=this.bodyB,motor=this.motorEquation,r1=this.rotationalEquation1,r2=this.rotationalEquation2,worldAxisA=HingeConstraint_update_tmpVec1,worldAxisB=HingeConstraint_update_tmpVec2,axisA=this.axisA,axisB=this.axisB;super.update(),bodyA.quaternion.vmult(axisA,worldAxisA),bodyB.quaternion.vmult(axisB,worldAxisB),worldAxisA.tangents(r1.axisA,r2.axisA),r1.axisB.copy(worldAxisB),r2.axisB.copy(worldAxisB),this.motorEquation.enabled&&(bodyA.quaternion.vmult(this.axisA,motor.axisA),bodyB.quaternion.vmult(this.axisB,motor.axisB))}}exports.HingeConstraint=HingeConstraint;const HingeConstraint_update_tmpVec1=new Vec3,HingeConstraint_update_tmpVec2=new Vec3;class FrictionEquation extends Equation{constructor(bodyA,bodyB,slipForce){super(bodyA,bodyB,-slipForce,slipForce),this.ri=new Vec3,this.rj=new Vec3,this.t=new Vec3}computeB(h){this.a;const b=this.b,ri=(this.bi,this.bj,this.ri),rj=this.rj,rixt=FrictionEquation_computeB_temp1,rjxt=FrictionEquation_computeB_temp2,t=this.t;ri.cross(t,rixt),rj.cross(t,rjxt);const GA=this.jacobianElementA,GB=this.jacobianElementB;return t.negate(GA.spatial),rixt.negate(GA.rotational),GB.spatial.copy(t),GB.rotational.copy(rjxt),-this.computeGW()*b-h*this.computeGiMf()}}exports.FrictionEquation=FrictionEquation;const FrictionEquation_computeB_temp1=new Vec3,FrictionEquation_computeB_temp2=new Vec3;class ContactMaterial{constructor(m1,m2,options){options=Utils.defaults(options,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=ContactMaterial.idCounter++,this.materials=[m1,m2],this.friction=options.friction,this.restitution=options.restitution,this.contactEquationStiffness=options.contactEquationStiffness,this.contactEquationRelaxation=options.contactEquationRelaxation,this.frictionEquationStiffness=options.frictionEquationStiffness,this.frictionEquationRelaxation=options.frictionEquationRelaxation}}exports.ContactMaterial=ContactMaterial,ContactMaterial.idCounter=0;class Material{constructor(options={}){let name="";"string"==typeof options&&(name=options,options={}),this.name=name,this.id=Material.idCounter++,this.friction=void 0!==options.friction?options.friction:-1,this.restitution=void 0!==options.restitution?options.restitution:-1}}exports.Material=Material,Material.idCounter=0;exports.Spring=class{constructor(bodyA,bodyB,options={}){this.restLength="number"==typeof options.restLength?options.restLength:1,this.stiffness=options.stiffness||100,this.damping=options.damping||1,this.bodyA=bodyA,this.bodyB=bodyB,this.localAnchorA=new Vec3,this.localAnchorB=new Vec3,options.localAnchorA&&this.localAnchorA.copy(options.localAnchorA),options.localAnchorB&&this.localAnchorB.copy(options.localAnchorB),options.worldAnchorA&&this.setWorldAnchorA(options.worldAnchorA),options.worldAnchorB&&this.setWorldAnchorB(options.worldAnchorB)}setWorldAnchorA(worldAnchorA){this.bodyA.pointToLocalFrame(worldAnchorA,this.localAnchorA)}setWorldAnchorB(worldAnchorB){this.bodyB.pointToLocalFrame(worldAnchorB,this.localAnchorB)}getWorldAnchorA(result){this.bodyA.pointToWorldFrame(this.localAnchorA,result)}getWorldAnchorB(result){this.bodyB.pointToWorldFrame(this.localAnchorB,result)}applyForce(){const k=this.stiffness,d=this.damping,l=this.restLength,bodyA=this.bodyA,bodyB=this.bodyB,r=applyForce_r,r_unit=applyForce_r_unit,u=applyForce_u,f=applyForce_f,tmp=applyForce_tmp,worldAnchorA=applyForce_worldAnchorA,worldAnchorB=applyForce_worldAnchorB,ri=applyForce_ri,rj=applyForce_rj,ri_x_f=applyForce_ri_x_f,rj_x_f=applyForce_rj_x_f;this.getWorldAnchorA(worldAnchorA),this.getWorldAnchorB(worldAnchorB),worldAnchorA.vsub(bodyA.position,ri),worldAnchorB.vsub(bodyB.position,rj),worldAnchorB.vsub(worldAnchorA,r);const rlen=r.length();r_unit.copy(r),r_unit.normalize(),bodyB.velocity.vsub(bodyA.velocity,u),bodyB.angularVelocity.cross(rj,tmp),u.vadd(tmp,u),bodyA.angularVelocity.cross(ri,tmp),u.vsub(tmp,u),r_unit.scale(-k*(rlen-l)-d*u.dot(r_unit),f),bodyA.force.vsub(f,bodyA.force),bodyB.force.vadd(f,bodyB.force),ri.cross(f,ri_x_f),rj.cross(f,rj_x_f),bodyA.torque.vsub(ri_x_f,bodyA.torque),bodyB.torque.vadd(rj_x_f,bodyB.torque)}};const applyForce_r=new Vec3,applyForce_r_unit=new Vec3,applyForce_u=new Vec3,applyForce_f=new Vec3,applyForce_worldAnchorA=new Vec3,applyForce_worldAnchorB=new Vec3,applyForce_ri=new Vec3,applyForce_rj=new Vec3,applyForce_ri_x_f=new Vec3,applyForce_rj_x_f=new Vec3,applyForce_tmp=new Vec3;class WheelInfo{constructor(options={}){options=Utils.defaults(options,{chassisConnectionPointLocal:new Vec3,chassisConnectionPointWorld:new Vec3,directionLocal:new Vec3,directionWorld:new Vec3,axleLocal:new Vec3,axleWorld:new Vec3,suspensionRestLength:1,suspensionMaxLength:2,radius:1,suspensionStiffness:100,dampingCompression:10,dampingRelaxation:10,frictionSlip:1e4,steering:0,rotation:0,deltaRotation:0,rollInfluence:.01,maxSuspensionForce:Number.MAX_VALUE,isFrontWheel:!0,clippedInvContactDotSuspension:1,suspensionRelativeVelocity:0,suspensionForce:0,slipInfo:0,skidInfo:0,suspensionLength:0,maxSuspensionTravel:1,useCustomSlidingRotationalSpeed:!1,customSlidingRotationalSpeed:-.1}),this.maxSuspensionTravel=options.maxSuspensionTravel,this.customSlidingRotationalSpeed=options.customSlidingRotationalSpeed,this.useCustomSlidingRotationalSpeed=options.useCustomSlidingRotationalSpeed,this.sliding=!1,this.chassisConnectionPointLocal=options.chassisConnectionPointLocal.clone(),this.chassisConnectionPointWorld=options.chassisConnectionPointWorld.clone(),this.directionLocal=options.directionLocal.clone(),this.directionWorld=options.directionWorld.clone(),this.axleLocal=options.axleLocal.clone(),this.axleWorld=options.axleWorld.clone(),this.suspensionRestLength=options.suspensionRestLength,this.suspensionMaxLength=options.suspensionMaxLength,this.radius=options.radius,this.suspensionStiffness=options.suspensionStiffness,this.dampingCompression=options.dampingCompression,this.dampingRelaxation=options.dampingRelaxation,this.frictionSlip=options.frictionSlip,this.steering=0,this.rotation=0,this.deltaRotation=0,this.rollInfluence=options.rollInfluence,this.maxSuspensionForce=options.maxSuspensionForce,this.engineForce=0,this.brake=0,this.isFrontWheel=options.isFrontWheel,this.clippedInvContactDotSuspension=1,this.suspensionRelativeVelocity=0,this.suspensionForce=0,this.slipInfo=0,this.skidInfo=0,this.suspensionLength=0,this.sideImpulse=0,this.forwardImpulse=0,this.raycastResult=new RaycastResult,this.worldTransform=new Transform,this.isInContact=!1}updateWheel(chassis){const raycastResult=this.raycastResult;if(this.isInContact){const project=raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);raycastResult.hitPointWorld.vsub(chassis.position,relpos),chassis.getVelocityAtWorldPoint(relpos,chassis_velocity_at_contactPoint);const projVel=raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);if(project>=-.1)this.suspensionRelativeVelocity=0,this.clippedInvContactDotSuspension=10;else{const inv=-1/project;this.suspensionRelativeVelocity=projVel*inv,this.clippedInvContactDotSuspension=inv}}else raycastResult.suspensionLength=this.suspensionRestLength,this.suspensionRelativeVelocity=0,raycastResult.directionWorld.scale(-1,raycastResult.hitNormalWorld),this.clippedInvContactDotSuspension=1}}const chassis_velocity_at_contactPoint=new Vec3,relpos=new Vec3;exports.RaycastVehicle=class{constructor(options){this.chassisBody=options.chassisBody,this.wheelInfos=[],this.sliding=!1,this.world=null,this.indexRightAxis=void 0!==options.indexRightAxis?options.indexRightAxis:1,this.indexForwardAxis=void 0!==options.indexForwardAxis?options.indexForwardAxis:0,this.indexUpAxis=void 0!==options.indexUpAxis?options.indexUpAxis:2,this.constraints=[],this.preStepCallback=(()=>{}),this.currentVehicleSpeedKmHour=0}addWheel(options={}){const info=new WheelInfo(options),index=this.wheelInfos.length;return this.wheelInfos.push(info),index}setSteeringValue(value,wheelIndex){this.wheelInfos[wheelIndex].steering=value}applyEngineForce(value,wheelIndex){this.wheelInfos[wheelIndex].engineForce=value}setBrake(brake,wheelIndex){this.wheelInfos[wheelIndex].brake=brake}addToWorld(world){this.constraints,world.addBody(this.chassisBody);const that=this;this.preStepCallback=(()=>{that.updateVehicle(world.dt)}),world.addEventListener("preStep",this.preStepCallback),this.world=world}getVehicleAxisWorld(axisIndex,result){result.set(0===axisIndex?1:0,1===axisIndex?1:0,2===axisIndex?1:0),this.chassisBody.vectorToWorldFrame(result,result)}updateVehicle(timeStep){const wheelInfos=this.wheelInfos,numWheels=wheelInfos.length,chassisBody=this.chassisBody;for(let i=0;i<numWheels;i++)this.updateWheelTransform(i);this.currentVehicleSpeedKmHour=3.6*chassisBody.velocity.length();const forwardWorld=new Vec3;this.getVehicleAxisWorld(this.indexForwardAxis,forwardWorld),forwardWorld.dot(chassisBody.velocity)<0&&(this.currentVehicleSpeedKmHour*=-1);for(let i=0;i<numWheels;i++)this.castRay(wheelInfos[i]);this.updateSuspension(timeStep);const impulse=new Vec3,relpos=new Vec3;for(let i=0;i<numWheels;i++){const wheel=wheelInfos[i];let suspensionForce=wheel.suspensionForce;suspensionForce>wheel.maxSuspensionForce&&(suspensionForce=wheel.maxSuspensionForce),wheel.raycastResult.hitNormalWorld.scale(suspensionForce*timeStep,impulse),wheel.raycastResult.hitPointWorld.vsub(chassisBody.position,relpos),chassisBody.applyImpulse(impulse,relpos)}this.updateFriction(timeStep);const hitNormalWorldScaledWithProj=new Vec3,fwd=new Vec3,vel=new Vec3;for(let i=0;i<numWheels;i++){const wheel=wheelInfos[i];chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld,vel);let m=1;switch(this.indexUpAxis){case 1:m=-1}if(wheel.isInContact){this.getVehicleAxisWorld(this.indexForwardAxis,fwd);const proj=fwd.dot(wheel.raycastResult.hitNormalWorld);wheel.raycastResult.hitNormalWorld.scale(proj,hitNormalWorldScaledWithProj),fwd.vsub(hitNormalWorldScaledWithProj,fwd);const proj2=fwd.dot(vel);wheel.deltaRotation=m*proj2*timeStep/wheel.radius}!wheel.sliding&&wheel.isInContact||0===wheel.engineForce||!wheel.useCustomSlidingRotationalSpeed||(wheel.deltaRotation=(wheel.engineForce>0?1:-1)*wheel.customSlidingRotationalSpeed*timeStep),Math.abs(wheel.brake)>Math.abs(wheel.engineForce)&&(wheel.deltaRotation=0),wheel.rotation+=wheel.deltaRotation,wheel.deltaRotation*=.99}}updateSuspension(deltaTime){const chassisMass=this.chassisBody.mass,wheelInfos=this.wheelInfos,numWheels=wheelInfos.length;for(let w_it=0;w_it<numWheels;w_it++){const wheel=wheelInfos[w_it];if(wheel.isInContact){let force;const length_diff=wheel.suspensionRestLength-wheel.suspensionLength;force=wheel.suspensionStiffness*length_diff*wheel.clippedInvContactDotSuspension;const projected_rel_vel=wheel.suspensionRelativeVelocity;let susp_damping;force-=(susp_damping=projected_rel_vel<0?wheel.dampingCompression:wheel.dampingRelaxation)*projected_rel_vel,wheel.suspensionForce=force*chassisMass,wheel.suspensionForce<0&&(wheel.suspensionForce=0)}else wheel.suspensionForce=0}}removeFromWorld(world){this.constraints,world.removeBody(this.chassisBody),world.removeEventListener("preStep",this.preStepCallback),this.world=null}castRay(wheel){const rayvector=castRay_rayvector,target=castRay_target;this.updateWheelTransformWorld(wheel);const chassisBody=this.chassisBody;let depth=-1;const raylen=wheel.suspensionRestLength+wheel.radius;wheel.directionWorld.scale(raylen,rayvector);const source=wheel.chassisConnectionPointWorld;source.vadd(rayvector,target);const raycastResult=wheel.raycastResult;raycastResult.reset();const oldState=chassisBody.collisionResponse;chassisBody.collisionResponse=!1,this.world.rayTest(source,target,raycastResult),chassisBody.collisionResponse=oldState;const object=raycastResult.body;if(wheel.raycastResult.groundObject=0,object){depth=raycastResult.distance,wheel.raycastResult.hitNormalWorld=raycastResult.hitNormalWorld,wheel.isInContact=!0;const hitDistance=raycastResult.distance;wheel.suspensionLength=hitDistance-wheel.radius;const minSuspensionLength=wheel.suspensionRestLength-wheel.maxSuspensionTravel,maxSuspensionLength=wheel.suspensionRestLength+wheel.maxSuspensionTravel;wheel.suspensionLength<minSuspensionLength&&(wheel.suspensionLength=minSuspensionLength),wheel.suspensionLength>maxSuspensionLength&&(wheel.suspensionLength=maxSuspensionLength,wheel.raycastResult.reset());const denominator=wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld),chassis_velocity_at_contactPoint=new Vec3;chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld,chassis_velocity_at_contactPoint);const projVel=wheel.raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);if(denominator>=-.1)wheel.suspensionRelativeVelocity=0,wheel.clippedInvContactDotSuspension=10;else{const inv=-1/denominator;wheel.suspensionRelativeVelocity=projVel*inv,wheel.clippedInvContactDotSuspension=inv}}else wheel.suspensionLength=wheel.suspensionRestLength+0*wheel.maxSuspensionTravel,wheel.suspensionRelativeVelocity=0,wheel.directionWorld.scale(-1,wheel.raycastResult.hitNormalWorld),wheel.clippedInvContactDotSuspension=1;return depth}updateWheelTransformWorld(wheel){wheel.isInContact=!1;const chassisBody=this.chassisBody;chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal,wheel.chassisConnectionPointWorld),chassisBody.vectorToWorldFrame(wheel.directionLocal,wheel.directionWorld),chassisBody.vectorToWorldFrame(wheel.axleLocal,wheel.axleWorld)}updateWheelTransform(wheelIndex){const up=tmpVec4,right=tmpVec5,fwd=tmpVec6,wheel=this.wheelInfos[wheelIndex];this.updateWheelTransformWorld(wheel),wheel.directionLocal.scale(-1,up),right.copy(wheel.axleLocal),up.cross(right,fwd),fwd.normalize(),right.normalize();const steering=wheel.steering,steeringOrn=new Quaternion;steeringOrn.setFromAxisAngle(up,steering);const rotatingOrn=new Quaternion;rotatingOrn.setFromAxisAngle(right,wheel.rotation);const q=wheel.worldTransform.quaternion;this.chassisBody.quaternion.mult(steeringOrn,q),q.mult(rotatingOrn,q),q.normalize();const p=wheel.worldTransform.position;p.copy(wheel.directionWorld),p.scale(wheel.suspensionLength,p),p.vadd(wheel.chassisConnectionPointWorld,p)}getWheelTransformWorld(wheelIndex){return this.wheelInfos[wheelIndex].worldTransform}updateFriction(timeStep){const surfNormalWS_scaled_proj=updateFriction_surfNormalWS_scaled_proj,wheelInfos=this.wheelInfos,numWheels=wheelInfos.length,chassisBody=this.chassisBody,forwardWS=updateFriction_forwardWS,axle=updateFriction_axle;for(let i=0;i<numWheels;i++){const wheel=wheelInfos[i];wheel.raycastResult.body,wheel.sideImpulse=0,wheel.forwardImpulse=0,forwardWS[i]||(forwardWS[i]=new Vec3),axle[i]||(axle[i]=new Vec3)}for(let i=0;i<numWheels;i++){const wheel=wheelInfos[i],groundObject=wheel.raycastResult.body;if(groundObject){const axlei=axle[i];this.getWheelTransformWorld(i).vectorToWorldFrame(directions[this.indexRightAxis],axlei);const surfNormalWS=wheel.raycastResult.hitNormalWorld,proj=axlei.dot(surfNormalWS);surfNormalWS.scale(proj,surfNormalWS_scaled_proj),axlei.vsub(surfNormalWS_scaled_proj,axlei),axlei.normalize(),surfNormalWS.cross(axlei,forwardWS[i]),forwardWS[i].normalize(),wheel.sideImpulse=resolveSingleBilateral(chassisBody,wheel.raycastResult.hitPointWorld,groundObject,wheel.raycastResult.hitPointWorld,axlei),wheel.sideImpulse*=sideFrictionStiffness2}}this.sliding=!1;for(let i=0;i<numWheels;i++){const wheel=wheelInfos[i],groundObject=wheel.raycastResult.body;let rollingFriction=0;if(wheel.slipInfo=1,groundObject){const defaultRollingFrictionImpulse=0,maxImpulse=wheel.brake?wheel.brake:defaultRollingFrictionImpulse;rollingFriction=calcRollingFriction(chassisBody,groundObject,wheel.raycastResult.hitPointWorld,forwardWS[i],maxImpulse);const factor=maxImpulse/(rollingFriction+=wheel.engineForce*timeStep);wheel.slipInfo*=factor}if(wheel.forwardImpulse=0,wheel.skidInfo=1,groundObject){wheel.skidInfo=1;const maximp=wheel.suspensionForce*timeStep*wheel.frictionSlip,maximpSquared=maximp*maximp;wheel.forwardImpulse=rollingFriction;const x=.5*wheel.forwardImpulse,y=1*wheel.sideImpulse,impulseSquared=x*x+y*y;if(wheel.sliding=!1,impulseSquared>maximpSquared){this.sliding=!0,wheel.sliding=!0;const factor=maximp/Math.sqrt(impulseSquared);wheel.skidInfo*=factor}}}if(this.sliding)for(let i=0;i<numWheels;i++){const wheel=wheelInfos[i];0!==wheel.sideImpulse&&wheel.skidInfo<1&&(wheel.forwardImpulse*=wheel.skidInfo,wheel.sideImpulse*=wheel.skidInfo)}for(let i=0;i<numWheels;i++){const wheel=wheelInfos[i],rel_pos=new Vec3;if(wheel.raycastResult.hitPointWorld.vsub(chassisBody.position,rel_pos),0!==wheel.forwardImpulse){const impulse=new Vec3;forwardWS[i].scale(wheel.forwardImpulse,impulse),chassisBody.applyImpulse(impulse,rel_pos)}if(0!==wheel.sideImpulse){const groundObject=wheel.raycastResult.body,rel_pos2=new Vec3;wheel.raycastResult.hitPointWorld.vsub(groundObject.position,rel_pos2);const sideImp=new Vec3;axle[i].scale(wheel.sideImpulse,sideImp),chassisBody.vectorToLocalFrame(rel_pos,rel_pos),rel_pos["xyz"[this.indexUpAxis]]*=wheel.rollInfluence,chassisBody.vectorToWorldFrame(rel_pos,rel_pos),chassisBody.applyImpulse(sideImp,rel_pos),sideImp.scale(-1,sideImp),groundObject.applyImpulse(sideImp,rel_pos2)}}}};const tmpVec4=new Vec3,tmpVec5=new Vec3,tmpVec6=new Vec3,castRay_rayvector=(new Ray,new Vec3),castRay_target=new Vec3,directions=[new Vec3(1,0,0),new Vec3(0,1,0),new Vec3(0,0,1)],updateFriction_surfNormalWS_scaled_proj=new Vec3,updateFriction_axle=[],updateFriction_forwardWS=[],sideFrictionStiffness2=1,calcRollingFriction_vel1=new Vec3,calcRollingFriction_vel2=new Vec3,calcRollingFriction_vel=new Vec3;function calcRollingFriction(body0,body1,frictionPosWorld,frictionDirectionWorld,maxImpulse){let j1=0;const contactPosWorld=frictionPosWorld,vel1=calcRollingFriction_vel1,vel2=calcRollingFriction_vel2,vel=calcRollingFriction_vel;body0.getVelocityAtWorldPoint(contactPosWorld,vel1),body1.getVelocityAtWorldPoint(contactPosWorld,vel2),vel1.vsub(vel2,vel);return maxImpulse<(j1=-frictionDirectionWorld.dot(vel)*(1/(computeImpulseDenominator(body0,frictionPosWorld,frictionDirectionWorld)+computeImpulseDenominator(body1,frictionPosWorld,frictionDirectionWorld))))&&(j1=maxImpulse),j1<-maxImpulse&&(j1=-maxImpulse),j1}const computeImpulseDenominator_r0=new Vec3,computeImpulseDenominator_c0=new Vec3,computeImpulseDenominator_vec=new Vec3,computeImpulseDenominator_m=new Vec3;function computeImpulseDenominator(body,pos,normal){const r0=computeImpulseDenominator_r0,c0=computeImpulseDenominator_c0,vec=computeImpulseDenominator_vec,m=computeImpulseDenominator_m;return pos.vsub(body.position,r0),r0.cross(normal,c0),body.invInertiaWorld.vmult(c0,m),m.cross(r0,vec),body.invMass+normal.dot(vec)}const resolveSingleBilateral_vel1=new Vec3,resolveSingleBilateral_vel2=new Vec3,resolveSingleBilateral_vel=new Vec3;function resolveSingleBilateral(body1,pos1,body2,pos2,normal){if(normal.lengthSquared()>1.1)return 0;const vel1=resolveSingleBilateral_vel1,vel2=resolveSingleBilateral_vel2,vel=resolveSingleBilateral_vel;body1.getVelocityAtWorldPoint(pos1,vel1),body2.getVelocityAtWorldPoint(pos2,vel2),vel1.vsub(vel2,vel);return-.2*normal.dot(vel)*(1/(body1.invMass+body2.invMass))}class Sphere extends Shape{constructor(radius){if(super({type:Shape.types.SPHERE}),this.radius=void 0!==radius?radius:1,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(mass,target=new Vec3){const I=2*mass*this.radius*this.radius/5;return target.x=I,target.y=I,target.z=I,target}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(pos,quat,min,max){const r=this.radius,axes=["x","y","z"];for(let i=0;i<axes.length;i++){const ax=axes[i];min[ax]=pos[ax]-r,max[ax]=pos[ax]+r}}}exports.Sphere=Sphere;exports.RigidVehicle=class{constructor(options={}){this.wheelBodies=[],this.coordinateSystem=void 0!==options.coordinateSystem?options.coordinateSystem.clone():new Vec3(1,2,3),options.chassisBody?this.chassisBody=options.chassisBody:this.chassisBody=new Body({mass:1,shape:new Box(new Vec3(5,2,.5))}),this.constraints=[],this.wheelAxes=[],this.wheelForces=[]}addWheel(options={}){let wheelBody;wheelBody=options.body?options.body:new Body({mass:1,shape:new Sphere(1.2)}),this.wheelBodies.push(wheelBody),this.wheelForces.push(0);const position=void 0!==options.position?options.position.clone():new Vec3,worldPosition=new Vec3;this.chassisBody.pointToWorldFrame(position,worldPosition),wheelBody.position.set(worldPosition.x,worldPosition.y,worldPosition.z);const axis=void 0!==options.axis?options.axis.clone():new Vec3(0,1,0);this.wheelAxes.push(axis);const hingeConstraint=new HingeConstraint(this.chassisBody,wheelBody,{pivotA:position,axisA:axis,pivotB:Vec3.ZERO,axisB:axis,collideConnected:!1});return this.constraints.push(hingeConstraint),this.wheelBodies.length-1}setSteeringValue(value,wheelIndex){const axis=this.wheelAxes[wheelIndex],c=Math.cos(value),s=Math.sin(value),x=axis.x,y=axis.y;this.constraints[wheelIndex].axisA.set(c*x-s*y,s*x+c*y,0)}setMotorSpeed(value,wheelIndex){const hingeConstraint=this.constraints[wheelIndex];hingeConstraint.enableMotor(),hingeConstraint.motorTargetVelocity=value}disableMotor(wheelIndex){this.constraints[wheelIndex].disableMotor()}setWheelForce(value,wheelIndex){this.wheelForces[wheelIndex]=value}applyWheelForce(value,wheelIndex){const axis=this.wheelAxes[wheelIndex],wheelBody=this.wheelBodies[wheelIndex],bodyTorque=wheelBody.torque;axis.scale(value,torque),wheelBody.vectorToWorldFrame(torque,torque),bodyTorque.vadd(torque,bodyTorque)}addToWorld(world){const constraints=this.constraints,bodies=this.wheelBodies.concat([this.chassisBody]);for(let i=0;i<bodies.length;i++)world.addBody(bodies[i]);for(let i=0;i<constraints.length;i++)world.addConstraint(constraints[i]);world.addEventListener("preStep",this._update.bind(this))}_update(){const wheelForces=this.wheelForces;for(let i=0;i<wheelForces.length;i++)this.applyWheelForce(wheelForces[i],i)}removeFromWorld(world){const constraints=this.constraints,bodies=this.wheelBodies.concat([this.chassisBody]);for(let i=0;i<bodies.length;i++)world.removeBody(bodies[i]);for(let i=0;i<constraints.length;i++)world.removeConstraint(constraints[i])}getWheelSpeed(wheelIndex){const axis=this.wheelAxes[wheelIndex],w=this.wheelBodies[wheelIndex].angularVelocity;return this.chassisBody.vectorToWorldFrame(axis,worldAxis),w.dot(worldAxis)}};const torque=new Vec3,worldAxis=new Vec3;exports.SPHSystem=class{constructor(){this.particles=[],this.density=1,this.smoothingRadius=1,this.speedOfSound=1,this.viscosity=.01,this.eps=1e-6,this.pressures=[],this.densities=[],this.neighbors=[]}add(particle){this.particles.push(particle),this.neighbors.length<this.particles.length&&this.neighbors.push([])}remove(particle){const idx=this.particles.indexOf(particle);-1!==idx&&(this.particles.splice(idx,1),this.neighbors.length>this.particles.length&&this.neighbors.pop())}getNeighbors(particle,neighbors){const N=this.particles.length,id=particle.id,R2=this.smoothingRadius*this.smoothingRadius,dist=SPHSystem_getNeighbors_dist;for(let i=0;i!==N;i++){const p=this.particles[i];p.position.vsub(particle.position,dist),id!==p.id&&dist.lengthSquared()<R2&&neighbors.push(p)}}update(){const N=this.particles.length,dist=SPHSystem_update_dist,cs=this.speedOfSound,eps=this.eps;for(let i=0;i!==N;i++){const p=this.particles[i],neighbors=this.neighbors[i];neighbors.length=0,this.getNeighbors(p,neighbors),neighbors.push(this.particles[i]);const numNeighbors=neighbors.length;let sum=0;for(let j=0;j!==numNeighbors;j++){p.position.vsub(neighbors[j].position,dist);const len=dist.length(),weight=this.w(len);sum+=neighbors[j].mass*weight}this.densities[i]=sum,this.pressures[i]=cs*cs*(this.densities[i]-this.density)}const a_pressure=SPHSystem_update_a_pressure,a_visc=SPHSystem_update_a_visc,gradW=SPHSystem_update_gradW,r_vec=SPHSystem_update_r_vec,u=SPHSystem_update_u;for(let i=0;i!==N;i++){const particle=this.particles[i];let Pij,nabla;a_pressure.set(0,0,0),a_visc.set(0,0,0);const neighbors=this.neighbors[i],numNeighbors=neighbors.length;for(let j=0;j!==numNeighbors;j++){const neighbor=neighbors[j];particle.position.vsub(neighbor.position,r_vec);const r=r_vec.length();Pij=-neighbor.mass*(this.pressures[i]/(this.densities[i]*this.densities[i]+eps)+this.pressures[j]/(this.densities[j]*this.densities[j]+eps)),this.gradw(r_vec,gradW),gradW.scale(Pij,gradW),a_pressure.vadd(gradW,a_pressure),neighbor.velocity.vsub(particle.velocity,u),u.scale(1/(1e-4+this.densities[i]*this.densities[j])*this.viscosity*neighbor.mass,u),nabla=this.nablaw(r),u.scale(nabla,u),a_visc.vadd(u,a_visc)}a_visc.scale(particle.mass,a_visc),a_pressure.scale(particle.mass,a_pressure),particle.force.vadd(a_visc,particle.force),particle.force.vadd(a_pressure,particle.force)}}w(r){const h=this.smoothingRadius;return 315/(64*Math.PI*h**9)*(h*h-r*r)**3}gradw(rVec,resultVec){const r=rVec.length(),h=this.smoothingRadius;rVec.scale(945/(32*Math.PI*h**9)*(h*h-r*r)**2,resultVec)}nablaw(r){const h=this.smoothingRadius;return 945/(32*Math.PI*h**9)*(h*h-r*r)*(7*r*r-3*h*h)}};const SPHSystem_getNeighbors_dist=new Vec3,SPHSystem_update_dist=new Vec3,SPHSystem_update_a_pressure=new Vec3,SPHSystem_update_a_visc=new Vec3,SPHSystem_update_gradW=new Vec3,SPHSystem_update_r_vec=new Vec3,SPHSystem_update_u=new Vec3;exports.Cylinder=class extends ConvexPolyhedron{constructor(radiusTop,radiusBottom,height,numSegments){const N=numSegments,vertices=[],axes=[],faces=[],bottomface=[],topface=[],cos=Math.cos,sin=Math.sin;vertices.push(new Vec3(radiusBottom*cos(0),radiusBottom*sin(0),.5*-height)),bottomface.push(0),vertices.push(new Vec3(radiusTop*cos(0),radiusTop*sin(0),.5*height)),topface.push(1);for(let i=0;i<N;i++){const theta=2*Math.PI/N*(i+1),thetaN=2*Math.PI/N*(i+.5);i<N-1?(vertices.push(new Vec3(radiusBottom*cos(theta),radiusBottom*sin(theta),.5*-height)),bottomface.push(2*i+2),vertices.push(new Vec3(radiusTop*cos(theta),radiusTop*sin(theta),.5*height)),topface.push(2*i+3),faces.push([2*i+2,2*i+3,2*i+1,2*i])):faces.push([0,1,2*i+1,2*i]),(N%2==1||i<N/2)&&axes.push(new Vec3(cos(thetaN),sin(thetaN),0))}faces.push(topface),axes.push(new Vec3(0,0,1));const temp=[];for(let i=0;i<bottomface.length;i++)temp.push(bottomface[bottomface.length-i-1]);faces.push(temp),super({vertices:vertices,faces:faces,axes:axes})}};exports.Particle=class extends Shape{constructor(){super({type:Shape.types.PARTICLE})}calculateLocalInertia(mass,target=new Vec3){return target.set(0,0,0),target}volume(){return 0}updateBoundingSphereRadius(){this.boundingSphereRadius=0}calculateWorldAABB(pos,quat,min,max){min.copy(pos),max.copy(pos)}};exports.Plane=class extends Shape{constructor(){super({type:Shape.types.PLANE}),this.worldNormal=new Vec3,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(quat){const n=this.worldNormal;n.set(0,0,1),quat.vmult(n,n),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(mass,target=new Vec3){return target}volume(){return Number.MAX_VALUE}calculateWorldAABB(pos,quat,min,max){tempNormal.set(0,0,1),quat.vmult(tempNormal,tempNormal);const maxVal=Number.MAX_VALUE;min.set(-maxVal,-maxVal,-maxVal),max.set(maxVal,maxVal,maxVal),1===tempNormal.x?max.x=pos.x:-1===tempNormal.x&&(min.x=pos.x),1===tempNormal.y?max.y=pos.y:-1===tempNormal.y&&(min.y=pos.y),1===tempNormal.z?max.z=pos.z:-1===tempNormal.z&&(min.z=pos.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}};const tempNormal=new Vec3;exports.Heightfield=class extends Shape{constructor(data,options={}){options=Utils.defaults(options,{maxValue:null,minValue:null,elementSize:1}),super({type:Shape.types.HEIGHTFIELD}),this.data=data,this.maxValue=options.maxValue,this.minValue=options.minValue,this.elementSize=options.elementSize,null===options.minValue&&this.updateMinValue(),null===options.maxValue&&this.updateMaxValue(),this.cacheEnabled=!0,this.pillarConvex=new ConvexPolyhedron,this.pillarOffset=new Vec3,this.updateBoundingSphereRadius(),this._cachedPillars={}}update(){this._cachedPillars={}}updateMinValue(){const data=this.data;let minValue=data[0][0];for(let i=0;i!==data.length;i++)for(let j=0;j!==data[i].length;j++){const v=data[i][j];v<minValue&&(minValue=v)}this.minValue=minValue}updateMaxValue(){const data=this.data;let maxValue=data[0][0];for(let i=0;i!==data.length;i++)for(let j=0;j!==data[i].length;j++){const v=data[i][j];v>maxValue&&(maxValue=v)}this.maxValue=maxValue}setHeightValueAtIndex(xi,yi,value){this.data[xi][yi]=value,this.clearCachedConvexTrianglePillar(xi,yi,!1),xi>0&&(this.clearCachedConvexTrianglePillar(xi-1,yi,!0),this.clearCachedConvexTrianglePillar(xi-1,yi,!1)),yi>0&&(this.clearCachedConvexTrianglePillar(xi,yi-1,!0),this.clearCachedConvexTrianglePillar(xi,yi-1,!1)),yi>0&&xi>0&&this.clearCachedConvexTrianglePillar(xi-1,yi-1,!0)}getRectMinMax(iMinX,iMinY,iMaxX,iMaxY,result=[]){const data=this.data;let max=this.minValue;for(let i=iMinX;i<=iMaxX;i++)for(let j=iMinY;j<=iMaxY;j++){const height=data[i][j];height>max&&(max=height)}result[0]=this.minValue,result[1]=max}getIndexOfPosition(x,y,result,clamp){const w=this.elementSize,data=this.data;let xi=Math.floor(x/w),yi=Math.floor(y/w);return result[0]=xi,result[1]=yi,clamp&&(xi<0&&(xi=0),yi<0&&(yi=0),xi>=data.length-1&&(xi=data.length-1),yi>=data[0].length-1&&(yi=data[0].length-1)),!(xi<0||yi<0||xi>=data.length-1||yi>=data[0].length-1)}getTriangleAt(x,y,edgeClamp,a,b,c){const idx=getHeightAt_idx;this.getIndexOfPosition(x,y,idx,edgeClamp);let xi=idx[0],yi=idx[1];const data=this.data;edgeClamp&&(xi=Math.min(data.length-2,Math.max(0,xi)),yi=Math.min(data[0].length-2,Math.max(0,yi)));const elementSize=this.elementSize,upper=(x/elementSize-xi)**2+(y/elementSize-yi)**2>(x/elementSize-(xi+1))**2+(y/elementSize-(yi+1))**2;return this.getTriangle(xi,yi,upper,a,b,c),upper}getNormalAt(x,y,edgeClamp,result){const a=getNormalAt_a,b=getNormalAt_b,c=getNormalAt_c,e0=getNormalAt_e0,e1=getNormalAt_e1;this.getTriangleAt(x,y,edgeClamp,a,b,c),b.vsub(a,e0),c.vsub(a,e1),e0.cross(e1,result),result.normalize()}getAabbAtIndex(xi,yi,{lowerBound:lowerBound,upperBound:upperBound}){const data=this.data,elementSize=this.elementSize;lowerBound.set(xi*elementSize,yi*elementSize,data[xi][yi]),upperBound.set((xi+1)*elementSize,(yi+1)*elementSize,data[xi+1][yi+1])}getHeightAt(x,y,edgeClamp){const data=this.data,a=getHeightAt_a,b=getHeightAt_b,c=getHeightAt_c,idx=getHeightAt_idx;this.getIndexOfPosition(x,y,idx,edgeClamp);let xi=idx[0],yi=idx[1];edgeClamp&&(xi=Math.min(data.length-2,Math.max(0,xi)),yi=Math.min(data[0].length-2,Math.max(0,yi)));const upper=this.getTriangleAt(x,y,edgeClamp,a,b,c);!function(x,y,ax,ay,bx,by,cx,cy,result){result.x=((by-cy)*(x-cx)+(cx-bx)*(y-cy))/((by-cy)*(ax-cx)+(cx-bx)*(ay-cy)),result.y=((cy-ay)*(x-cx)+(ax-cx)*(y-cy))/((by-cy)*(ax-cx)+(cx-bx)*(ay-cy)),result.z=1-result.x-result.y}(x,y,a.x,a.y,b.x,b.y,c.x,c.y,getHeightAt_weights);const w=getHeightAt_weights;return upper?data[xi+1][yi+1]*w.x+data[xi][yi+1]*w.y+data[xi+1][yi]*w.z:data[xi][yi]*w.x+data[xi+1][yi]*w.y+data[xi][yi+1]*w.z}getCacheConvexTrianglePillarKey(xi,yi,getUpperTriangle){return xi+"_"+yi+"_"+(getUpperTriangle?1:0)}getCachedConvexTrianglePillar(xi,yi,getUpperTriangle){return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi,yi,getUpperTriangle)]}setCachedConvexTrianglePillar(xi,yi,getUpperTriangle,convex,offset){this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi,yi,getUpperTriangle)]={convex:convex,offset:offset}}clearCachedConvexTrianglePillar(xi,yi,getUpperTriangle){delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi,yi,getUpperTriangle)]}getTriangle(xi,yi,upper,a,b,c){const data=this.data,elementSize=this.elementSize;upper?(a.set((xi+1)*elementSize,(yi+1)*elementSize,data[xi+1][yi+1]),b.set(xi*elementSize,(yi+1)*elementSize,data[xi][yi+1]),c.set((xi+1)*elementSize,yi*elementSize,data[xi+1][yi])):(a.set(xi*elementSize,yi*elementSize,data[xi][yi]),b.set((xi+1)*elementSize,yi*elementSize,data[xi+1][yi]),c.set(xi*elementSize,(yi+1)*elementSize,data[xi][yi+1]))}getConvexTrianglePillar(xi,yi,getUpperTriangle){let result=this.pillarConvex,offsetResult=this.pillarOffset;if(this.cacheEnabled){const data=this.getCachedConvexTrianglePillar(xi,yi,getUpperTriangle);if(data)return this.pillarConvex=data.convex,void(this.pillarOffset=data.offset);result=new ConvexPolyhedron,offsetResult=new Vec3,this.pillarConvex=result,this.pillarOffset=offsetResult}const data=this.data,elementSize=this.elementSize,faces=result.faces;result.vertices.length=6;for(let i=0;i<6;i++)result.vertices[i]||(result.vertices[i]=new Vec3);faces.length=5;for(let i=0;i<5;i++)faces[i]||(faces[i]=[]);const verts=result.vertices,h=(Math.min(data[xi][yi],data[xi+1][yi],data[xi][yi+1],data[xi+1][yi+1])-this.minValue)/2+this.minValue;getUpperTriangle?(offsetResult.set((xi+.75)*elementSize,(yi+.75)*elementSize,h),verts[0].set(.25*elementSize,.25*elementSize,data[xi+1][yi+1]-h),verts[1].set(-.75*elementSize,.25*elementSize,data[xi][yi+1]-h),verts[2].set(.25*elementSize,-.75*elementSize,data[xi+1][yi]-h),verts[3].set(.25*elementSize,.25*elementSize,-h-1),verts[4].set(-.75*elementSize,.25*elementSize,-h-1),verts[5].set(.25*elementSize,-.75*elementSize,-h-1),faces[0][0]=0,faces[0][1]=1,faces[0][2]=2,faces[1][0]=5,faces[1][1]=4,faces[1][2]=3,faces[2][0]=2,faces[2][1]=5,faces[2][2]=3,faces[2][3]=0,faces[3][0]=3,faces[3][1]=4,faces[3][2]=1,faces[3][3]=0,faces[4][0]=1,faces[4][1]=4,faces[4][2]=5,faces[4][3]=2):(offsetResult.set((xi+.25)*elementSize,(yi+.25)*elementSize,h),verts[0].set(-.25*elementSize,-.25*elementSize,data[xi][yi]-h),verts[1].set(.75*elementSize,-.25*elementSize,data[xi+1][yi]-h),verts[2].set(-.25*elementSize,.75*elementSize,data[xi][yi+1]-h),verts[3].set(-.25*elementSize,-.25*elementSize,-h-1),verts[4].set(.75*elementSize,-.25*elementSize,-h-1),verts[5].set(-.25*elementSize,.75*elementSize,-h-1),faces[0][0]=0,faces[0][1]=1,faces[0][2]=2,faces[1][0]=5,faces[1][1]=4,faces[1][2]=3,faces[2][0]=0,faces[2][1]=2,faces[2][2]=5,faces[2][3]=3,faces[3][0]=1,faces[3][1]=0,faces[3][2]=3,faces[3][3]=4,faces[4][0]=4,faces[4][1]=5,faces[4][2]=2,faces[4][3]=1),result.computeNormals(),result.computeEdges(),result.updateBoundingSphereRadius(),this.setCachedConvexTrianglePillar(xi,yi,getUpperTriangle,result,offsetResult)}calculateLocalInertia(mass,target=new Vec3){return target.set(0,0,0),target}volume(){return Number.MAX_VALUE}calculateWorldAABB(pos,quat,min,max){min.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),max.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}updateBoundingSphereRadius(){const data=this.data,s=this.elementSize;this.boundingSphereRadius=new Vec3(data.length*s,data[0].length*s,Math.max(Math.abs(this.maxValue),Math.abs(this.minValue))).length()}setHeightsFromImage(image,scale){const{x:x,z:z,y:y}=scale,canvas=document.createElement("canvas");canvas.width=image.width,canvas.height=image.height;const context=canvas.getContext("2d");context.drawImage(image,0,0);const imageData=context.getImageData(0,0,image.width,image.height),matrix=this.data;matrix.length=0,this.elementSize=Math.abs(x)/imageData.width;for(let i=0;i<imageData.height;i++){const row=[];for(let j=0;j<imageData.width;j++){const height=(imageData.data[4*(i*imageData.height+j)]+imageData.data[4*(i*imageData.height+j)+1]+imageData.data[4*(i*imageData.height+j)+2])/4/255*z;x<0?row.push(height):row.unshift(height)}y<0?matrix.unshift(row):matrix.push(row)}this.updateMaxValue(),this.updateMinValue(),this.update()}};const getHeightAt_idx=[],getHeightAt_weights=new Vec3,getHeightAt_a=new Vec3,getHeightAt_b=new Vec3,getHeightAt_c=new Vec3,getNormalAt_a=new Vec3,getNormalAt_b=new Vec3,getNormalAt_c=new Vec3,getNormalAt_e0=new Vec3,getNormalAt_e1=new Vec3;class OctreeNode{constructor(options={}){this.root=options.root||null,this.aabb=options.aabb?options.aabb.clone():new AABB,this.data=[],this.children=[]}reset(){this.children.length=this.data.length=0}insert(aabb,elementData,level=0){const nodeData=this.data;if(!this.aabb.contains(aabb))return!1;const children=this.children;if(level<(this.maxDepth||this.root.maxDepth)){let subdivided=!1;children.length||(this.subdivide(),subdivided=!0);for(let i=0;8!==i;i++)if(children[i].insert(aabb,elementData,level+1))return!0;subdivided&&(children.length=0)}return nodeData.push(elementData),!0}subdivide(){const aabb=this.aabb,l=aabb.lowerBound,u=aabb.upperBound,children=this.children;children.push(new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,0,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,0,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,1,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,1,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,1,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,0,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,0,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,1,0)})})),u.vsub(l,halfDiagonal),halfDiagonal.scale(.5,halfDiagonal);const root=this.root||this;for(let i=0;8!==i;i++){const child=children[i];child.root=root;const lowerBound=child.aabb.lowerBound;lowerBound.x*=halfDiagonal.x,lowerBound.y*=halfDiagonal.y,lowerBound.z*=halfDiagonal.z,lowerBound.vadd(l,lowerBound),lowerBound.vadd(halfDiagonal,child.aabb.upperBound)}}aabbQuery(aabb,result){this.data,this.children;const queue=[this];for(;queue.length;){const node=queue.pop();node.aabb.overlaps(aabb)&&Array.prototype.push.apply(result,node.data),Array.prototype.push.apply(queue,node.children)}return result}rayQuery(ray,treeTransform,result){return ray.getAABB(tmpAABB$1),tmpAABB$1.toLocalFrame(treeTransform,tmpAABB$1),this.aabbQuery(tmpAABB$1,result),result}removeEmptyNodes(){for(let i=this.children.length-1;i>=0;i--)this.children[i].removeEmptyNodes(),this.children[i].children.length||this.children[i].data.length||this.children.splice(i,1)}}class Octree extends OctreeNode{constructor(aabb,options={}){super({root:null,aabb:aabb}),this.maxDepth=void 0!==options.maxDepth?options.maxDepth:8}}const halfDiagonal=new Vec3,tmpAABB$1=new AABB;class Trimesh extends Shape{constructor(vertices,indices){super({type:Shape.types.TRIMESH}),this.vertices=new Float32Array(vertices),this.indices=new Int16Array(indices),this.normals=new Float32Array(indices.length),this.aabb=new AABB,this.edges=null,this.scale=new Vec3(1,1,1),this.tree=new Octree,this.updateEdges(),this.updateNormals(),this.updateAABB(),this.updateBoundingSphereRadius(),this.updateTree()}updateTree(){const tree=this.tree;tree.reset(),tree.aabb.copy(this.aabb);const scale=this.scale;tree.aabb.lowerBound.x*=1/scale.x,tree.aabb.lowerBound.y*=1/scale.y,tree.aabb.lowerBound.z*=1/scale.z,tree.aabb.upperBound.x*=1/scale.x,tree.aabb.upperBound.y*=1/scale.y,tree.aabb.upperBound.z*=1/scale.z;const triangleAABB=new AABB,a=new Vec3,b=new Vec3,c=new Vec3,points=[a,b,c];for(let i=0;i<this.indices.length/3;i++){const i3=3*i;this._getUnscaledVertex(this.indices[i3],a),this._getUnscaledVertex(this.indices[i3+1],b),this._getUnscaledVertex(this.indices[i3+2],c),triangleAABB.setFromPoints(points),tree.insert(triangleAABB,i)}tree.removeEmptyNodes()}getTrianglesInAABB(aabb,result){unscaledAABB.copy(aabb);const scale=this.scale,isx=scale.x,isy=scale.y,isz=scale.z,l=unscaledAABB.lowerBound,u=unscaledAABB.upperBound;return l.x/=isx,l.y/=isy,l.z/=isz,u.x/=isx,u.y/=isy,u.z/=isz,this.tree.aabbQuery(unscaledAABB,result)}setScale(scale){const wasUniform=this.scale.x===this.scale.y&&this.scale.y===this.scale.z,isUniform=scale.x===scale.y&&scale.y===scale.z;wasUniform&&isUniform||this.updateNormals(),this.scale.copy(scale),this.updateAABB(),this.updateBoundingSphereRadius()}updateNormals(){const n=computeNormals_n,normals=this.normals;for(let i=0;i<this.indices.length/3;i++){const i3=3*i,a=this.indices[i3],b=this.indices[i3+1],c=this.indices[i3+2];this.getVertex(a,va),this.getVertex(b,vb),this.getVertex(c,vc),Trimesh.computeNormal(vb,va,vc,n),normals[i3]=n.x,normals[i3+1]=n.y,normals[i3+2]=n.z}}updateEdges(){const edges={},add=(a,b)=>{edges[a<b?a+"_"+b:b+"_"+a]=!0};for(let i=0;i<this.indices.length/3;i++){const i3=3*i,a=this.indices[i3],b=this.indices[i3+1],c=this.indices[i3+2];add(a,b),add(b,c),add(c,a)}const keys=Object.keys(edges);this.edges=new Int16Array(2*keys.length);for(let i=0;i<keys.length;i++){const indices=keys[i].split("_");this.edges[2*i]=parseInt(indices[0],10),this.edges[2*i+1]=parseInt(indices[1],10)}}getEdgeVertex(edgeIndex,firstOrSecond,vertexStore){const vertexIndex=this.edges[2*edgeIndex+(firstOrSecond?1:0)];this.getVertex(vertexIndex,vertexStore)}getEdgeVector(edgeIndex,vectorStore){const va=getEdgeVector_va,vb=getEdgeVector_vb;this.getEdgeVertex(edgeIndex,0,va),this.getEdgeVertex(edgeIndex,1,vb),vb.vsub(va,vectorStore)}getVertex(i,out){const scale=this.scale;return this._getUnscaledVertex(i,out),out.x*=scale.x,out.y*=scale.y,out.z*=scale.z,out}_getUnscaledVertex(i,out){const i3=3*i,vertices=this.vertices;return out.set(vertices[i3],vertices[i3+1],vertices[i3+2])}getWorldVertex(i,pos,quat,out){return this.getVertex(i,out),Transform.pointToWorldFrame(pos,quat,out,out),out}getTriangleVertices(i,a,b,c){const i3=3*i;this.getVertex(this.indices[i3],a),this.getVertex(this.indices[i3+1],b),this.getVertex(this.indices[i3+2],c)}getNormal(i,target){const i3=3*i;return target.set(this.normals[i3],this.normals[i3+1],this.normals[i3+2])}calculateLocalInertia(mass,target){this.computeLocalAABB(cli_aabb);const x=cli_aabb.upperBound.x-cli_aabb.lowerBound.x,y=cli_aabb.upperBound.y-cli_aabb.lowerBound.y,z=cli_aabb.upperBound.z-cli_aabb.lowerBound.z;return target.set(1/12*mass*(2*y*2*y+2*z*2*z),1/12*mass*(2*x*2*x+2*z*2*z),1/12*mass*(2*y*2*y+2*x*2*x))}computeLocalAABB(aabb){const l=aabb.lowerBound,u=aabb.upperBound,n=this.vertices.length,v=(this.vertices,computeLocalAABB_worldVert);this.getVertex(0,v),l.copy(v),u.copy(v);for(let i=0;i!==n;i++)this.getVertex(i,v),v.x<l.x?l.x=v.x:v.x>u.x&&(u.x=v.x),v.y<l.y?l.y=v.y:v.y>u.y&&(u.y=v.y),v.z<l.z?l.z=v.z:v.z>u.z&&(u.z=v.z)}updateAABB(){this.computeLocalAABB(this.aabb)}updateBoundingSphereRadius(){let max2=0;const vertices=this.vertices,v=new Vec3;for(let i=0,N=vertices.length/3;i!==N;i++){this.getVertex(i,v);const norm2=v.lengthSquared();norm2>max2&&(max2=norm2)}this.boundingSphereRadius=Math.sqrt(max2)}calculateWorldAABB(pos,quat,min,max){const frame=calculateWorldAABB_frame,result=calculateWorldAABB_aabb;frame.position=pos,frame.quaternion=quat,this.aabb.toWorldFrame(frame,result),min.copy(result.lowerBound),max.copy(result.upperBound)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}}exports.Trimesh=Trimesh;const computeNormals_n=new Vec3,unscaledAABB=new AABB,getEdgeVector_va=new Vec3,getEdgeVector_vb=new Vec3,cb=new Vec3,ab=new Vec3;Trimesh.computeNormal=((va,vb,vc,target)=>{vb.vsub(va,ab),vc.vsub(vb,cb),cb.cross(ab,target),target.isZero()||target.normalize()});const va=new Vec3,vb=new Vec3,vc=new Vec3,cli_aabb=new AABB,computeLocalAABB_worldVert=new Vec3,calculateWorldAABB_frame=new Transform,calculateWorldAABB_aabb=new AABB;Trimesh.createTorus=((radius=1,tube=.5,radialSegments=8,tubularSegments=6,arc=2*Math.PI)=>{const vertices=[],indices=[];for(let j=0;j<=radialSegments;j++)for(let i=0;i<=tubularSegments;i++){const u=i/tubularSegments*arc,v=j/radialSegments*Math.PI*2,x=(radius+tube*Math.cos(v))*Math.cos(u),y=(radius+tube*Math.cos(v))*Math.sin(u),z=tube*Math.sin(v);vertices.push(x,y,z)}for(let j=1;j<=radialSegments;j++)for(let i=1;i<=tubularSegments;i++){const a=(tubularSegments+1)*j+i-1,b=(tubularSegments+1)*(j-1)+i-1,c=(tubularSegments+1)*(j-1)+i,d=(tubularSegments+1)*j+i;indices.push(a,b,d),indices.push(b,c,d)}return new Trimesh(vertices,indices)});class Solver{constructor(){this.equations=[]}solve(dt,world){return 0}addEquation(eq){eq.enabled&&this.equations.push(eq)}removeEquation(eq){const eqs=this.equations,i=eqs.indexOf(eq);-1!==i&&eqs.splice(i,1)}removeAllEquations(){this.equations.length=0}}exports.Solver=Solver;class GSSolver extends Solver{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(dt,world){let iter=0;const maxIter=this.iterations,tolSquared=this.tolerance*this.tolerance,equations=this.equations,Neq=equations.length,bodies=world.bodies,Nbodies=bodies.length,h=dt;let B,invC,deltalambda,deltalambdaTot,GWlambda,lambdaj;if(0!==Neq)for(let i=0;i!==Nbodies;i++)bodies[i].updateSolveMassProperties();const invCs=GSSolver_solve_invCs,Bs=GSSolver_solve_Bs,lambda=GSSolver_solve_lambda;invCs.length=Neq,Bs.length=Neq,lambda.length=Neq;for(let i=0;i!==Neq;i++){const c=equations[i];lambda[i]=0,Bs[i]=c.computeB(h),invCs[i]=1/c.computeC()}if(0!==Neq){for(let i=0;i!==Nbodies;i++){const b=bodies[i],vlambda=b.vlambda,wlambda=b.wlambda;vlambda.set(0,0,0),wlambda.set(0,0,0)}for(iter=0;iter!==maxIter;iter++){deltalambdaTot=0;for(let j=0;j!==Neq;j++){const c=equations[j];B=Bs[j],invC=invCs[j],(lambdaj=lambda[j])+(deltalambda=invC*(B-(GWlambda=c.computeGWlambda())-c.eps*lambdaj))<c.minForce?deltalambda=c.minForce-lambdaj:lambdaj+deltalambda>c.maxForce&&(deltalambda=c.maxForce-lambdaj),lambda[j]+=deltalambda,deltalambdaTot+=deltalambda>0?deltalambda:-deltalambda,c.addToWlambda(deltalambda)}if(deltalambdaTot*deltalambdaTot<tolSquared)break}for(let i=0;i!==Nbodies;i++){const b=bodies[i],v=b.velocity,w=b.angularVelocity;b.vlambda.vmul(b.linearFactor,b.vlambda),v.vadd(b.vlambda,v),b.wlambda.vmul(b.angularFactor,b.wlambda),w.vadd(b.wlambda,w)}let l=equations.length;const invDt=1/h;for(;l--;)equations[l].multiplier=lambda[l]*invDt}return iter}}exports.GSSolver=GSSolver;const GSSolver_solve_lambda=[],GSSolver_solve_invCs=[],GSSolver_solve_Bs=[];exports.SplitSolver=class extends Solver{constructor(subsolver){for(super(),this.iterations=10,this.tolerance=1e-7,this.subsolver=subsolver,this.nodes=[],this.nodePool=[];this.nodePool.length<128;)this.nodePool.push(this.createNode())}createNode(){return{body:null,children:[],eqs:[],visited:!1}}solve(dt,world){const nodes=SplitSolver_solve_nodes,nodePool=this.nodePool,bodies=world.bodies,equations=this.equations,Neq=equations.length,Nbodies=bodies.length,subsolver=this.subsolver;for(;nodePool.length<Nbodies;)nodePool.push(this.createNode());nodes.length=Nbodies;for(let i=0;i<Nbodies;i++)nodes[i]=nodePool[i];for(let i=0;i!==Nbodies;i++){const node=nodes[i];node.body=bodies[i],node.children.length=0,node.eqs.length=0,node.visited=!1}for(let k=0;k!==Neq;k++){const eq=equations[k],i=bodies.indexOf(eq.bi),j=bodies.indexOf(eq.bj),ni=nodes[i],nj=nodes[j];ni.children.push(nj),ni.eqs.push(eq),nj.children.push(ni),nj.eqs.push(eq)}let child,n=0,eqs=SplitSolver_solve_eqs;subsolver.tolerance=this.tolerance,subsolver.iterations=this.iterations;const dummyWorld=SplitSolver_solve_dummyWorld;for(;child=getUnvisitedNode(nodes);){eqs.length=0,dummyWorld.bodies.length=0,bfs(child,visitFunc,dummyWorld.bodies,eqs);const Neqs=eqs.length;eqs=eqs.sort(sortById);for(let i=0;i!==Neqs;i++)subsolver.addEquation(eqs[i]);subsolver.solve(dt,dummyWorld),subsolver.removeAllEquations(),n++}return n}};const SplitSolver_solve_nodes=[],SplitSolver_solve_eqs=[],SplitSolver_solve_dummyWorld={bodies:[]},STATIC=Body.STATIC;function getUnvisitedNode(nodes){const Nnodes=nodes.length;for(let i=0;i!==Nnodes;i++){const node=nodes[i];if(!(node.visited||node.body.type&STATIC))return node}return!1}const queue=[];function bfs(root,visitFunc,bds,eqs){for(queue.push(root),root.visited=!0,visitFunc(root,bds,eqs);queue.length;){const node=queue.pop();let child;for(;child=getUnvisitedNode(node.children);)child.visited=!0,visitFunc(child,bds,eqs),queue.push(child)}}function visitFunc(node,bds,eqs){bds.push(node.body);const Neqs=node.eqs.length;for(let i=0;i!==Neqs;i++){const eq=node.eqs[i];eqs.includes(eq)||eqs.push(eq)}}function sortById(a,b){return b.id-a.id}class Pool{constructor(){this.objects=[],this.type=Object}release(...args){const Nargs=args.length;for(let i=0;i!==Nargs;i++)this.objects.push(args[i]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(size){const objects=this.objects;for(;objects.length>size;)objects.pop();for(;objects.length<size;)objects.push(this.constructObject());return this}}exports.Pool=Pool;class Vec3Pool extends Pool{constructor(){super(),this.type=Vec3}constructObject(){return new Vec3}}exports.Vec3Pool=Vec3Pool;const COLLISION_TYPES=exports.COLLISION_TYPES={sphereSphere:Shape.types.SPHERE,spherePlane:Shape.types.SPHERE|Shape.types.PLANE,boxBox:Shape.types.BOX|Shape.types.BOX,sphereBox:Shape.types.SPHERE|Shape.types.BOX,planeBox:Shape.types.PLANE|Shape.types.BOX,convexConvex:Shape.types.CONVEXPOLYHEDRON,sphereConvex:Shape.types.SPHERE|Shape.types.CONVEXPOLYHEDRON,planeConvex:Shape.types.PLANE|Shape.types.CONVEXPOLYHEDRON,boxConvex:Shape.types.BOX|Shape.types.CONVEXPOLYHEDRON,sphereHeightfield:Shape.types.SPHERE|Shape.types.HEIGHTFIELD,boxHeightfield:Shape.types.BOX|Shape.types.HEIGHTFIELD,convexHeightfield:Shape.types.CONVEXPOLYHEDRON|Shape.types.HEIGHTFIELD,sphereParticle:Shape.types.PARTICLE|Shape.types.SPHERE,planeParticle:Shape.types.PLANE|Shape.types.PARTICLE,boxParticle:Shape.types.BOX|Shape.types.PARTICLE,convexParticle:Shape.types.PARTICLE|Shape.types.CONVEXPOLYHEDRON,sphereTrimesh:Shape.types.SPHERE|Shape.types.TRIMESH,planeTrimesh:Shape.types.PLANE|Shape.types.TRIMESH};class Narrowphase{constructor(world){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new Vec3Pool,this.world=world,this.currentContactMaterial=world.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(bi,bj,si,sj,overrideShapeA,overrideShapeB){let c;this.contactPointPool.length?((c=this.contactPointPool.pop()).bi=bi,c.bj=bj):c=new ContactEquation(bi,bj),c.enabled=bi.collisionResponse&&bj.collisionResponse&&si.collisionResponse&&sj.collisionResponse;const cm=this.currentContactMaterial;c.restitution=cm.restitution,c.setSpookParams(cm.contactEquationStiffness,cm.contactEquationRelaxation,this.world.dt);const matA=si.material||bi.material,matB=sj.material||bj.material;return matA&&matB&&matA.restitution>=0&&matB.restitution>=0&&(c.restitution=matA.restitution*matB.restitution),c.si=overrideShapeA||si,c.sj=overrideShapeB||sj,c}createFrictionEquationsFromContact(contactEquation,outArray){const bodyA=contactEquation.bi,bodyB=contactEquation.bj,shapeA=contactEquation.si,shapeB=contactEquation.sj,world=this.world,cm=this.currentContactMaterial;let friction=cm.friction;const matA=shapeA.material||bodyA.material,matB=shapeB.material||bodyB.material;if(matA&&matB&&matA.friction>=0&&matB.friction>=0&&(friction=matA.friction*matB.friction),friction>0){const mug=friction*world.gravity.length();let reducedMass=bodyA.invMass+bodyB.invMass;reducedMass>0&&(reducedMass=1/reducedMass);const pool=this.frictionEquationPool,c1=pool.length?pool.pop():new FrictionEquation(bodyA,bodyB,mug*reducedMass),c2=pool.length?pool.pop():new FrictionEquation(bodyA,bodyB,mug*reducedMass);return c1.bi=c2.bi=bodyA,c1.bj=c2.bj=bodyB,c1.minForce=c2.minForce=-mug*reducedMass,c1.maxForce=c2.maxForce=mug*reducedMass,c1.ri.copy(contactEquation.ri),c1.rj.copy(contactEquation.rj),c2.ri.copy(contactEquation.ri),c2.rj.copy(contactEquation.rj),contactEquation.ni.tangents(c1.t,c2.t),c1.setSpookParams(cm.frictionEquationStiffness,cm.frictionEquationRelaxation,world.dt),c2.setSpookParams(cm.frictionEquationStiffness,cm.frictionEquationRelaxation,world.dt),c1.enabled=c2.enabled=contactEquation.enabled,outArray.push(c1,c2),!0}return!1}createFrictionFromAverage(numContacts){let c=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(c,this.frictionResult)||1===numContacts)return;const f1=this.frictionResult[this.frictionResult.length-2],f2=this.frictionResult[this.frictionResult.length-1];averageNormal.setZero(),averageContactPointA.setZero(),averageContactPointB.setZero();const bodyA=c.bi;c.bj;for(let i=0;i!==numContacts;i++)(c=this.result[this.result.length-1-i]).bi!==bodyA?(averageNormal.vadd(c.ni,averageNormal),averageContactPointA.vadd(c.ri,averageContactPointA),averageContactPointB.vadd(c.rj,averageContactPointB)):(averageNormal.vsub(c.ni,averageNormal),averageContactPointA.vadd(c.rj,averageContactPointA),averageContactPointB.vadd(c.ri,averageContactPointB));const invNumContacts=1/numContacts;averageContactPointA.scale(invNumContacts,f1.ri),averageContactPointB.scale(invNumContacts,f1.rj),f2.ri.copy(f1.ri),f2.rj.copy(f1.rj),averageNormal.normalize(),averageNormal.tangents(f1.t,f2.t)}getContacts(p1,p2,world,result,oldcontacts,frictionResult,frictionPool){this.contactPointPool=oldcontacts,this.frictionEquationPool=frictionPool,this.result=result,this.frictionResult=frictionResult;const qi=tmpQuat1,qj=tmpQuat2,xi=tmpVec1$2,xj=tmpVec2$2;for(let k=0,N=p1.length;k!==N;k++){const bi=p1[k],bj=p2[k];let bodyContactMaterial=null;bi.material&&bj.material&&(bodyContactMaterial=world.getContactMaterial(bi.material,bj.material)||null);const justTest=bi.type&Body.KINEMATIC&&bj.type&Body.STATIC||bi.type&Body.STATIC&&bj.type&Body.KINEMATIC||bi.type&Body.KINEMATIC&&bj.type&Body.KINEMATIC;for(let i=0;i<bi.shapes.length;i++){bi.quaternion.mult(bi.shapeOrientations[i],qi),bi.quaternion.vmult(bi.shapeOffsets[i],xi),xi.vadd(bi.position,xi);const si=bi.shapes[i];for(let j=0;j<bj.shapes.length;j++){bj.quaternion.mult(bj.shapeOrientations[j],qj),bj.quaternion.vmult(bj.shapeOffsets[j],xj),xj.vadd(bj.position,xj);const sj=bj.shapes[j];if(!(si.collisionFilterMask&sj.collisionFilterGroup&&sj.collisionFilterMask&si.collisionFilterGroup))continue;if(xi.distanceTo(xj)>si.boundingSphereRadius+sj.boundingSphereRadius)continue;let shapeContactMaterial=null;si.material&&sj.material&&(shapeContactMaterial=world.getContactMaterial(si.material,sj.material)||null),this.currentContactMaterial=shapeContactMaterial||bodyContactMaterial||world.defaultContactMaterial;const resolver=this[si.type|sj.type];if(resolver){let retval=!1;(retval=si.type<sj.type?resolver.call(this,si,sj,xi,xj,qi,qj,bi,bj,si,sj,justTest):resolver.call(this,sj,si,xj,xi,qj,qi,bj,bi,si,sj,justTest))&&justTest&&(world.shapeOverlapKeeper.set(si.id,sj.id),world.bodyOverlapKeeper.set(bi.id,bj.id))}}}}}sphereSphere(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){if(justTest)return xi.distanceSquared(xj)<(si.radius+sj.radius)**2;const r=this.createContactEquation(bi,bj,si,sj,rsi,rsj);xj.vsub(xi,r.ni),r.ni.normalize(),r.ri.copy(r.ni),r.rj.copy(r.ni),r.ri.scale(si.radius,r.ri),r.rj.scale(-sj.radius,r.rj),r.ri.vadd(xi,r.ri),r.ri.vsub(bi.position,r.ri),r.rj.vadd(xj,r.rj),r.rj.vsub(bj.position,r.rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}spherePlane(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){const r=this.createContactEquation(bi,bj,si,sj,rsi,rsj);if(r.ni.set(0,0,1),qj.vmult(r.ni,r.ni),r.ni.negate(r.ni),r.ni.normalize(),r.ni.scale(si.radius,r.ri),xi.vsub(xj,point_on_plane_to_sphere),r.ni.scale(r.ni.dot(point_on_plane_to_sphere),plane_to_sphere_ortho),point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,r.rj),-point_on_plane_to_sphere.dot(r.ni)<=si.radius){if(justTest)return!0;const ri=r.ri,rj=r.rj;ri.vadd(xi,ri),ri.vsub(bi.position,ri),rj.vadd(xj,rj),rj.vsub(bj.position,rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}boxBox(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){return si.convexPolyhedronRepresentation.material=si.material,sj.convexPolyhedronRepresentation.material=sj.material,si.convexPolyhedronRepresentation.collisionResponse=si.collisionResponse,sj.convexPolyhedronRepresentation.collisionResponse=sj.collisionResponse,this.convexConvex(si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj,justTest)}sphereBox(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){const v3pool=this.v3pool,sides=sphereBox_sides;xi.vsub(xj,box_to_sphere),sj.getSideNormals(sides,qj);const R=si.radius;let found=!1;const side_ns=sphereBox_side_ns,side_ns1=sphereBox_side_ns1,side_ns2=sphereBox_side_ns2;let side_h=null,side_penetrations=0,side_dot1=0,side_dot2=0,side_distance=null;for(let idx=0,nsides=sides.length;idx!==nsides&&!1===found;idx++){const ns=sphereBox_ns;ns.copy(sides[idx]);const h=ns.length();ns.normalize();const dot=box_to_sphere.dot(ns);if(dot<h+R&&dot>0){const ns1=sphereBox_ns1,ns2=sphereBox_ns2;ns1.copy(sides[(idx+1)%3]),ns2.copy(sides[(idx+2)%3]);const h1=ns1.length(),h2=ns2.length();ns1.normalize(),ns2.normalize();const dot1=box_to_sphere.dot(ns1),dot2=box_to_sphere.dot(ns2);if(dot1<h1&&dot1>-h1&&dot2<h2&&dot2>-h2){const dist=Math.abs(dot-h-R);if((null===side_distance||dist<side_distance)&&(side_distance=dist,side_dot1=dot1,side_dot2=dot2,side_h=h,side_ns.copy(ns),side_ns1.copy(ns1),side_ns2.copy(ns2),side_penetrations++,justTest))return!0}}}if(side_penetrations){found=!0;const r=this.createContactEquation(bi,bj,si,sj,rsi,rsj);side_ns.scale(-R,r.ri),r.ni.copy(side_ns),r.ni.negate(r.ni),side_ns.scale(side_h,side_ns),side_ns1.scale(side_dot1,side_ns1),side_ns.vadd(side_ns1,side_ns),side_ns2.scale(side_dot2,side_ns2),side_ns.vadd(side_ns2,r.rj),r.ri.vadd(xi,r.ri),r.ri.vsub(bi.position,r.ri),r.rj.vadd(xj,r.rj),r.rj.vsub(bj.position,r.rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}let rj=v3pool.get();const sphere_to_corner=sphereBox_sphere_to_corner;for(let j=0;2!==j&&!found;j++)for(let k=0;2!==k&&!found;k++)for(let l=0;2!==l&&!found;l++)if(rj.set(0,0,0),j?rj.vadd(sides[0],rj):rj.vsub(sides[0],rj),k?rj.vadd(sides[1],rj):rj.vsub(sides[1],rj),l?rj.vadd(sides[2],rj):rj.vsub(sides[2],rj),xj.vadd(rj,sphere_to_corner),sphere_to_corner.vsub(xi,sphere_to_corner),sphere_to_corner.lengthSquared()<R*R){if(justTest)return!0;found=!0;const r=this.createContactEquation(bi,bj,si,sj,rsi,rsj);r.ri.copy(sphere_to_corner),r.ri.normalize(),r.ni.copy(r.ri),r.ri.scale(R,r.ri),r.rj.copy(rj),r.ri.vadd(xi,r.ri),r.ri.vsub(bi.position,r.ri),r.rj.vadd(xj,r.rj),r.rj.vsub(bj.position,r.rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}v3pool.release(rj),rj=null;const edgeTangent=v3pool.get(),edgeCenter=v3pool.get(),r=v3pool.get(),orthogonal=v3pool.get(),dist=v3pool.get(),Nsides=sides.length;for(let j=0;j!==Nsides&&!found;j++)for(let k=0;k!==Nsides&&!found;k++)if(j%3!=k%3){sides[k].cross(sides[j],edgeTangent),edgeTangent.normalize(),sides[j].vadd(sides[k],edgeCenter),r.copy(xi),r.vsub(edgeCenter,r),r.vsub(xj,r);const orthonorm=r.dot(edgeTangent);edgeTangent.scale(orthonorm,orthogonal);let l=0;for(;l===j%3||l===k%3;)l++;dist.copy(xi),dist.vsub(orthogonal,dist),dist.vsub(edgeCenter,dist),dist.vsub(xj,dist);const tdist=Math.abs(orthonorm),ndist=dist.length();if(tdist<sides[l].length()&&ndist<R){if(justTest)return!0;found=!0;const res=this.createContactEquation(bi,bj,si,sj,rsi,rsj);edgeCenter.vadd(orthogonal,res.rj),res.rj.copy(res.rj),dist.negate(res.ni),res.ni.normalize(),res.ri.copy(res.rj),res.ri.vadd(xj,res.ri),res.ri.vsub(xi,res.ri),res.ri.normalize(),res.ri.scale(R,res.ri),res.ri.vadd(xi,res.ri),res.ri.vsub(bi.position,res.ri),res.rj.vadd(xj,res.rj),res.rj.vsub(bj.position,res.rj),this.result.push(res),this.createFrictionEquationsFromContact(res,this.frictionResult)}}v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist)}planeBox(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){return sj.convexPolyhedronRepresentation.material=sj.material,sj.convexPolyhedronRepresentation.collisionResponse=sj.collisionResponse,sj.convexPolyhedronRepresentation.id=sj.id,this.planeConvex(si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj,justTest)}convexConvex(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest,faceListA,faceListB){const sepAxis=convexConvex_sepAxis;if(!(xi.distanceTo(xj)>si.boundingSphereRadius+sj.boundingSphereRadius)&&si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis,faceListA,faceListB)){const res=[],q=convexConvex_q;si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);let numContacts=0;for(let j=0;j!==res.length;j++){if(justTest)return!0;const r=this.createContactEquation(bi,bj,si,sj,rsi,rsj),ri=r.ri,rj=r.rj;sepAxis.negate(r.ni),res[j].normal.negate(q),q.scale(res[j].depth,q),res[j].point.vadd(q,ri),rj.copy(res[j].point),ri.vsub(xi,ri),rj.vsub(xj,rj),ri.vadd(xi,ri),ri.vsub(bi.position,ri),rj.vadd(xj,rj),rj.vsub(bj.position,rj),this.result.push(r),numContacts++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(r,this.frictionResult)}this.enableFrictionReduction&&numContacts&&this.createFrictionFromAverage(numContacts)}}sphereConvex(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){const v3pool=this.v3pool;xi.vsub(xj,convex_to_sphere);const normals=sj.faceNormals,faces=sj.faces,verts=sj.vertices,R=si.radius;let found=!1;for(let i=0;i!==verts.length;i++){const v=verts[i],worldCorner=sphereConvex_worldCorner;qj.vmult(v,worldCorner),xj.vadd(worldCorner,worldCorner);const sphere_to_corner=sphereConvex_sphereToCorner;if(worldCorner.vsub(xi,sphere_to_corner),sphere_to_corner.lengthSquared()<R*R){if(justTest)return!0;found=!0;const r=this.createContactEquation(bi,bj,si,sj,rsi,rsj);return r.ri.copy(sphere_to_corner),r.ri.normalize(),r.ni.copy(r.ri),r.ri.scale(R,r.ri),worldCorner.vsub(xj,r.rj),r.ri.vadd(xi,r.ri),r.ri.vsub(bi.position,r.ri),r.rj.vadd(xj,r.rj),r.rj.vsub(bj.position,r.rj),this.result.push(r),void this.createFrictionEquationsFromContact(r,this.frictionResult)}}for(let i=0,nfaces=faces.length;i!==nfaces&&!1===found;i++){const normal=normals[i],face=faces[i],worldNormal=sphereConvex_worldNormal;qj.vmult(normal,worldNormal);const worldPoint=sphereConvex_worldPoint;qj.vmult(verts[face[0]],worldPoint),worldPoint.vadd(xj,worldPoint);const worldSpherePointClosestToPlane=sphereConvex_worldSpherePointClosestToPlane;worldNormal.scale(-R,worldSpherePointClosestToPlane),xi.vadd(worldSpherePointClosestToPlane,worldSpherePointClosestToPlane);const penetrationVec=sphereConvex_penetrationVec;worldSpherePointClosestToPlane.vsub(worldPoint,penetrationVec);const penetration=penetrationVec.dot(worldNormal),worldPointToSphere=sphereConvex_sphereToWorldPoint;if(xi.vsub(worldPoint,worldPointToSphere),penetration<0&&worldPointToSphere.dot(worldNormal)>0){const faceVerts=[];for(let j=0,Nverts=face.length;j!==Nverts;j++){const worldVertex=v3pool.get();qj.vmult(verts[face[j]],worldVertex),xj.vadd(worldVertex,worldVertex),faceVerts.push(worldVertex)}if(pointInPolygon(faceVerts,worldNormal,xi)){if(justTest)return!0;found=!0;const r=this.createContactEquation(bi,bj,si,sj,rsi,rsj);worldNormal.scale(-R,r.ri),worldNormal.negate(r.ni);const penetrationVec2=v3pool.get();worldNormal.scale(-penetration,penetrationVec2);const penetrationSpherePoint=v3pool.get();worldNormal.scale(-R,penetrationSpherePoint),xi.vsub(xj,r.rj),r.rj.vadd(penetrationSpherePoint,r.rj),r.rj.vadd(penetrationVec2,r.rj),r.rj.vadd(xj,r.rj),r.rj.vsub(bj.position,r.rj),r.ri.vadd(xi,r.ri),r.ri.vsub(bi.position,r.ri),v3pool.release(penetrationVec2),v3pool.release(penetrationSpherePoint),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult);for(let j=0,Nfaceverts=faceVerts.length;j!==Nfaceverts;j++)v3pool.release(faceVerts[j]);return}for(let j=0;j!==face.length;j++){const v1=v3pool.get(),v2=v3pool.get();qj.vmult(verts[face[(j+1)%face.length]],v1),qj.vmult(verts[face[(j+2)%face.length]],v2),xj.vadd(v1,v1),xj.vadd(v2,v2);const edge=sphereConvex_edge;v2.vsub(v1,edge);const edgeUnit=sphereConvex_edgeUnit;edge.unit(edgeUnit);const p=v3pool.get(),v1_to_xi=v3pool.get();xi.vsub(v1,v1_to_xi);const dot=v1_to_xi.dot(edgeUnit);edgeUnit.scale(dot,p),p.vadd(v1,p);const xi_to_p=v3pool.get();if(p.vsub(xi,xi_to_p),dot>0&&dot*dot<edge.lengthSquared()&&xi_to_p.lengthSquared()<R*R){if(justTest)return!0;const r=this.createContactEquation(bi,bj,si,sj,rsi,rsj);p.vsub(xj,r.rj),p.vsub(xi,r.ni),r.ni.normalize(),r.ni.scale(R,r.ri),r.rj.vadd(xj,r.rj),r.rj.vsub(bj.position,r.rj),r.ri.vadd(xi,r.ri),r.ri.vsub(bi.position,r.ri),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult);for(let j=0,Nfaceverts=faceVerts.length;j!==Nfaceverts;j++)v3pool.release(faceVerts[j]);return v3pool.release(v1),v3pool.release(v2),v3pool.release(p),v3pool.release(xi_to_p),void v3pool.release(v1_to_xi)}v3pool.release(v1),v3pool.release(v2),v3pool.release(p),v3pool.release(xi_to_p),v3pool.release(v1_to_xi)}for(let j=0,Nfaceverts=faceVerts.length;j!==Nfaceverts;j++)v3pool.release(faceVerts[j])}}}planeConvex(planeShape,convexShape,planePosition,convexPosition,planeQuat,convexQuat,planeBody,convexBody,si,sj,justTest){const worldVertex=planeConvex_v,worldNormal=planeConvex_normal;worldNormal.set(0,0,1),planeQuat.vmult(worldNormal,worldNormal);let numContacts=0;const relpos=planeConvex_relpos;for(let i=0;i!==convexShape.vertices.length;i++){if(worldVertex.copy(convexShape.vertices[i]),convexQuat.vmult(worldVertex,worldVertex),convexPosition.vadd(worldVertex,worldVertex),worldVertex.vsub(planePosition,relpos),worldNormal.dot(relpos)<=0){if(justTest)return!0;const r=this.createContactEquation(planeBody,convexBody,planeShape,convexShape,si,sj),projected=planeConvex_projected;worldNormal.scale(worldNormal.dot(relpos),projected),worldVertex.vsub(projected,projected),projected.vsub(planePosition,r.ri),r.ni.copy(worldNormal),worldVertex.vsub(convexPosition,r.rj),r.ri.vadd(planePosition,r.ri),r.ri.vsub(planeBody.position,r.ri),r.rj.vadd(convexPosition,r.rj),r.rj.vsub(convexBody.position,r.rj),this.result.push(r),numContacts++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(r,this.frictionResult)}}this.enableFrictionReduction&&numContacts&&this.createFrictionFromAverage(numContacts)}boxConvex(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){return si.convexPolyhedronRepresentation.material=si.material,si.convexPolyhedronRepresentation.collisionResponse=si.collisionResponse,this.convexConvex(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj,justTest)}sphereHeightfield(sphereShape,hfShape,spherePos,hfPos,sphereQuat,hfQuat,sphereBody,hfBody,rsi,rsj,justTest){const data=hfShape.data,radius=sphereShape.radius,w=hfShape.elementSize,worldPillarOffset=sphereHeightfield_tmp2,localSpherePos=sphereHeightfield_tmp1;Transform.pointToLocalFrame(hfPos,hfQuat,spherePos,localSpherePos);let iMinX=Math.floor((localSpherePos.x-radius)/w)-1,iMaxX=Math.ceil((localSpherePos.x+radius)/w)+1,iMinY=Math.floor((localSpherePos.y-radius)/w)-1,iMaxY=Math.ceil((localSpherePos.y+radius)/w)+1;if(iMaxX<0||iMaxY<0||iMinX>data.length||iMinY>data[0].length)return;iMinX<0&&(iMinX=0),iMaxX<0&&(iMaxX=0),iMinY<0&&(iMinY=0),iMaxY<0&&(iMaxY=0),iMinX>=data.length&&(iMinX=data.length-1),iMaxX>=data.length&&(iMaxX=data.length-1),iMaxY>=data[0].length&&(iMaxY=data[0].length-1),iMinY>=data[0].length&&(iMinY=data[0].length-1);const minMax=[];hfShape.getRectMinMax(iMinX,iMinY,iMaxX,iMaxY,minMax);const min=minMax[0],max=minMax[1];if(localSpherePos.z-radius>max||localSpherePos.z+radius<min)return;const result=this.result;for(let i=iMinX;i<iMaxX;i++)for(let j=iMinY;j<iMaxY;j++){const numContactsBefore=result.length;let intersecting=!1;if(hfShape.getConvexTrianglePillar(i,j,!1),Transform.pointToWorldFrame(hfPos,hfQuat,hfShape.pillarOffset,worldPillarOffset),spherePos.distanceTo(worldPillarOffset)<hfShape.pillarConvex.boundingSphereRadius+sphereShape.boundingSphereRadius&&(intersecting=this.sphereConvex(sphereShape,hfShape.pillarConvex,spherePos,worldPillarOffset,sphereQuat,hfQuat,sphereBody,hfBody,sphereShape,hfShape,justTest)),justTest&&intersecting)return!0;if(hfShape.getConvexTrianglePillar(i,j,!0),Transform.pointToWorldFrame(hfPos,hfQuat,hfShape.pillarOffset,worldPillarOffset),spherePos.distanceTo(worldPillarOffset)<hfShape.pillarConvex.boundingSphereRadius+sphereShape.boundingSphereRadius&&(intersecting=this.sphereConvex(sphereShape,hfShape.pillarConvex,spherePos,worldPillarOffset,sphereQuat,hfQuat,sphereBody,hfBody,sphereShape,hfShape,justTest)),justTest&&intersecting)return!0;if(result.length-numContactsBefore>2)return}}boxHeightfield(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){return si.convexPolyhedronRepresentation.material=si.material,si.convexPolyhedronRepresentation.collisionResponse=si.collisionResponse,this.convexHeightfield(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj,justTest)}convexHeightfield(convexShape,hfShape,convexPos,hfPos,convexQuat,hfQuat,convexBody,hfBody,rsi,rsj,justTest){const data=hfShape.data,w=hfShape.elementSize,radius=convexShape.boundingSphereRadius,worldPillarOffset=convexHeightfield_tmp2,faceList=convexHeightfield_faceList,localConvexPos=convexHeightfield_tmp1;Transform.pointToLocalFrame(hfPos,hfQuat,convexPos,localConvexPos);let iMinX=Math.floor((localConvexPos.x-radius)/w)-1,iMaxX=Math.ceil((localConvexPos.x+radius)/w)+1,iMinY=Math.floor((localConvexPos.y-radius)/w)-1,iMaxY=Math.ceil((localConvexPos.y+radius)/w)+1;if(iMaxX<0||iMaxY<0||iMinX>data.length||iMinY>data[0].length)return;iMinX<0&&(iMinX=0),iMaxX<0&&(iMaxX=0),iMinY<0&&(iMinY=0),iMaxY<0&&(iMaxY=0),iMinX>=data.length&&(iMinX=data.length-1),iMaxX>=data.length&&(iMaxX=data.length-1),iMaxY>=data[0].length&&(iMaxY=data[0].length-1),iMinY>=data[0].length&&(iMinY=data[0].length-1);const minMax=[];hfShape.getRectMinMax(iMinX,iMinY,iMaxX,iMaxY,minMax);const min=minMax[0],max=minMax[1];if(!(localConvexPos.z-radius>max||localConvexPos.z+radius<min))for(let i=iMinX;i<iMaxX;i++)for(let j=iMinY;j<iMaxY;j++){let intersecting=!1;if(hfShape.getConvexTrianglePillar(i,j,!1),Transform.pointToWorldFrame(hfPos,hfQuat,hfShape.pillarOffset,worldPillarOffset),convexPos.distanceTo(worldPillarOffset)<hfShape.pillarConvex.boundingSphereRadius+convexShape.boundingSphereRadius&&(intersecting=this.convexConvex(convexShape,hfShape.pillarConvex,convexPos,worldPillarOffset,convexQuat,hfQuat,convexBody,hfBody,null,null,justTest,faceList,null)),justTest&&intersecting)return!0;if(hfShape.getConvexTrianglePillar(i,j,!0),Transform.pointToWorldFrame(hfPos,hfQuat,hfShape.pillarOffset,worldPillarOffset),convexPos.distanceTo(worldPillarOffset)<hfShape.pillarConvex.boundingSphereRadius+convexShape.boundingSphereRadius&&(intersecting=this.convexConvex(convexShape,hfShape.pillarConvex,convexPos,worldPillarOffset,convexQuat,hfQuat,convexBody,hfBody,null,null,justTest,faceList,null)),justTest&&intersecting)return!0}}sphereParticle(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj,justTest){const normal=particleSphere_normal;if(normal.set(0,0,1),xi.vsub(xj,normal),normal.lengthSquared()<=sj.radius*sj.radius){if(justTest)return!0;const r=this.createContactEquation(bi,bj,si,sj,rsi,rsj);normal.normalize(),r.rj.copy(normal),r.rj.scale(sj.radius,r.rj),r.ni.copy(normal),r.ni.negate(r.ni),r.ri.set(0,0,0),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}planeParticle(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj,justTest){const normal=particlePlane_normal;normal.set(0,0,1),bj.quaternion.vmult(normal,normal);const relpos=particlePlane_relpos;if(xi.vsub(bj.position,relpos),normal.dot(relpos)<=0){if(justTest)return!0;const r=this.createContactEquation(bi,bj,si,sj,rsi,rsj);r.ni.copy(normal),r.ni.negate(r.ni),r.ri.set(0,0,0);const projected=particlePlane_projected;normal.scale(normal.dot(xi),projected),xi.vsub(projected,projected),r.rj.copy(projected),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}boxParticle(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,justTest){return si.convexPolyhedronRepresentation.material=si.material,si.convexPolyhedronRepresentation.collisionResponse=si.collisionResponse,this.convexParticle(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj,justTest)}convexParticle(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj,justTest){let penetratedFaceIndex=-1;const penetratedFaceNormal=convexParticle_penetratedFaceNormal,worldPenetrationVec=convexParticle_worldPenetrationVec;let minPenetration=null;const local=convexParticle_local;if(local.copy(xi),local.vsub(xj,local),qj.conjugate(cqj),cqj.vmult(local,local),sj.pointIsInside(local)){sj.worldVerticesNeedsUpdate&&sj.computeWorldVertices(xj,qj),sj.worldFaceNormalsNeedsUpdate&&sj.computeWorldFaceNormals(qj);for(let i=0,nfaces=sj.faces.length;i!==nfaces;i++){const verts=[sj.worldVertices[sj.faces[i][0]]],normal=sj.worldFaceNormals[i];xi.vsub(verts[0],convexParticle_vertexToParticle);const penetration=-normal.dot(convexParticle_vertexToParticle);if(null===minPenetration||Math.abs(penetration)<Math.abs(minPenetration)){if(justTest)return!0;minPenetration=penetration,penetratedFaceIndex=i,penetratedFaceNormal.copy(normal)}}if(-1!==penetratedFaceIndex){const r=this.createContactEquation(bi,bj,si,sj,rsi,rsj);penetratedFaceNormal.scale(minPenetration,worldPenetrationVec),worldPenetrationVec.vadd(xi,worldPenetrationVec),worldPenetrationVec.vsub(xj,worldPenetrationVec),r.rj.copy(worldPenetrationVec),penetratedFaceNormal.negate(r.ni),r.ri.set(0,0,0);const ri=r.ri,rj=r.rj;ri.vadd(xi,ri),ri.vsub(bi.position,ri),rj.vadd(xj,rj),rj.vsub(bj.position,rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}sphereTrimesh(sphereShape,trimeshShape,spherePos,trimeshPos,sphereQuat,trimeshQuat,sphereBody,trimeshBody,rsi,rsj,justTest){const edgeVertexA=sphereTrimesh_edgeVertexA,edgeVertexB=sphereTrimesh_edgeVertexB,edgeVector=sphereTrimesh_edgeVector,edgeVectorUnit=sphereTrimesh_edgeVectorUnit,localSpherePos=sphereTrimesh_localSpherePos,tmp=sphereTrimesh_tmp,localSphereAABB=sphereTrimesh_localSphereAABB,v2=sphereTrimesh_v2,relpos=sphereTrimesh_relpos,triangles=sphereTrimesh_triangles;Transform.pointToLocalFrame(trimeshPos,trimeshQuat,spherePos,localSpherePos);const sphereRadius=sphereShape.radius;localSphereAABB.lowerBound.set(localSpherePos.x-sphereRadius,localSpherePos.y-sphereRadius,localSpherePos.z-sphereRadius),localSphereAABB.upperBound.set(localSpherePos.x+sphereRadius,localSpherePos.y+sphereRadius,localSpherePos.z+sphereRadius),trimeshShape.getTrianglesInAABB(localSphereAABB,triangles);const v=sphereTrimesh_v,radiusSquared=sphereShape.radius*sphereShape.radius;for(let i=0;i<triangles.length;i++)for(let j=0;j<3;j++)if(trimeshShape.getVertex(trimeshShape.indices[3*triangles[i]+j],v),v.vsub(localSpherePos,relpos),relpos.lengthSquared()<=radiusSquared){if(v2.copy(v),Transform.pointToWorldFrame(trimeshPos,trimeshQuat,v2,v),v.vsub(spherePos,relpos),justTest)return!0;let r=this.createContactEquation(sphereBody,trimeshBody,sphereShape,trimeshShape,rsi,rsj);r.ni.copy(relpos),r.ni.normalize(),r.ri.copy(r.ni),r.ri.scale(sphereShape.radius,r.ri),r.ri.vadd(spherePos,r.ri),r.ri.vsub(sphereBody.position,r.ri),r.rj.copy(v),r.rj.vsub(trimeshBody.position,r.rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}for(let i=0;i<triangles.length;i++)for(let j=0;j<3;j++){trimeshShape.getVertex(trimeshShape.indices[3*triangles[i]+j],edgeVertexA),trimeshShape.getVertex(trimeshShape.indices[3*triangles[i]+(j+1)%3],edgeVertexB),edgeVertexB.vsub(edgeVertexA,edgeVector),localSpherePos.vsub(edgeVertexB,tmp);const positionAlongEdgeB=tmp.dot(edgeVector);localSpherePos.vsub(edgeVertexA,tmp);let positionAlongEdgeA=tmp.dot(edgeVector);if(positionAlongEdgeA>0&&positionAlongEdgeB<0){if(localSpherePos.vsub(edgeVertexA,tmp),edgeVectorUnit.copy(edgeVector),edgeVectorUnit.normalize(),positionAlongEdgeA=tmp.dot(edgeVectorUnit),edgeVectorUnit.scale(positionAlongEdgeA,tmp),tmp.vadd(edgeVertexA,tmp),tmp.distanceTo(localSpherePos)<sphereShape.radius){if(justTest)return!0;const r=this.createContactEquation(sphereBody,trimeshBody,sphereShape,trimeshShape,rsi,rsj);tmp.vsub(localSpherePos,r.ni),r.ni.normalize(),r.ni.scale(sphereShape.radius,r.ri),r.ri.vadd(spherePos,r.ri),r.ri.vsub(sphereBody.position,r.ri),Transform.pointToWorldFrame(trimeshPos,trimeshQuat,tmp,tmp),tmp.vsub(trimeshBody.position,r.rj),Transform.vectorToWorldFrame(trimeshQuat,r.ni,r.ni),Transform.vectorToWorldFrame(trimeshQuat,r.ri,r.ri),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}}const va=sphereTrimesh_va,vb=sphereTrimesh_vb,vc=sphereTrimesh_vc,normal=sphereTrimesh_normal;for(let i=0,N=triangles.length;i!==N;i++){trimeshShape.getTriangleVertices(triangles[i],va,vb,vc),trimeshShape.getNormal(triangles[i],normal),localSpherePos.vsub(va,tmp);let dist=tmp.dot(normal);if(normal.scale(dist,tmp),localSpherePos.vsub(tmp,tmp),dist=tmp.distanceTo(localSpherePos),Ray.pointInTriangle(tmp,va,vb,vc)&&dist<sphereShape.radius){if(justTest)return!0;let r=this.createContactEquation(sphereBody,trimeshBody,sphereShape,trimeshShape,rsi,rsj);tmp.vsub(localSpherePos,r.ni),r.ni.normalize(),r.ni.scale(sphereShape.radius,r.ri),r.ri.vadd(spherePos,r.ri),r.ri.vsub(sphereBody.position,r.ri),Transform.pointToWorldFrame(trimeshPos,trimeshQuat,tmp,tmp),tmp.vsub(trimeshBody.position,r.rj),Transform.vectorToWorldFrame(trimeshQuat,r.ni,r.ni),Transform.vectorToWorldFrame(trimeshQuat,r.ri,r.ri),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}triangles.length=0}planeTrimesh(planeShape,trimeshShape,planePos,trimeshPos,planeQuat,trimeshQuat,planeBody,trimeshBody,rsi,rsj,justTest){const v=new Vec3,normal=planeTrimesh_normal;normal.set(0,0,1),planeQuat.vmult(normal,normal);for(let i=0;i<trimeshShape.vertices.length/3;i++){trimeshShape.getVertex(i,v);const v2=new Vec3;v2.copy(v),Transform.pointToWorldFrame(trimeshPos,trimeshQuat,v2,v);const relpos=planeTrimesh_relpos;if(v.vsub(planePos,relpos),normal.dot(relpos)<=0){if(justTest)return!0;const r=this.createContactEquation(planeBody,trimeshBody,planeShape,trimeshShape,rsi,rsj);r.ni.copy(normal);const projected=planeTrimesh_projected;normal.scale(relpos.dot(normal),projected),v.vsub(projected,projected),r.ri.copy(projected),r.ri.vsub(planeBody.position,r.ri),r.rj.copy(v),r.rj.vsub(trimeshBody.position,r.rj),this.result.push(r),this.createFrictionEquationsFromContact(r,this.frictionResult)}}}}exports.Narrowphase=Narrowphase;const averageNormal=new Vec3,averageContactPointA=new Vec3,averageContactPointB=new Vec3,tmpVec1$2=new Vec3,tmpVec2$2=new Vec3,tmpQuat1=new Quaternion,tmpQuat2=new Quaternion;Narrowphase.prototype[COLLISION_TYPES.boxBox]=Narrowphase.prototype.boxBox,Narrowphase.prototype[COLLISION_TYPES.boxConvex]=Narrowphase.prototype.boxConvex,Narrowphase.prototype[COLLISION_TYPES.boxParticle]=Narrowphase.prototype.boxParticle,Narrowphase.prototype[COLLISION_TYPES.sphereSphere]=Narrowphase.prototype.sphereSphere;const planeTrimesh_normal=new Vec3,planeTrimesh_relpos=new Vec3,planeTrimesh_projected=new Vec3;Narrowphase.prototype[COLLISION_TYPES.planeTrimesh]=Narrowphase.prototype.planeTrimesh;const sphereTrimesh_normal=new Vec3,sphereTrimesh_relpos=new Vec3,sphereTrimesh_v=new Vec3,sphereTrimesh_v2=new Vec3,sphereTrimesh_edgeVertexA=new Vec3,sphereTrimesh_edgeVertexB=new Vec3,sphereTrimesh_edgeVector=new Vec3,sphereTrimesh_edgeVectorUnit=new Vec3,sphereTrimesh_localSpherePos=new Vec3,sphereTrimesh_tmp=new Vec3,sphereTrimesh_va=new Vec3,sphereTrimesh_vb=new Vec3,sphereTrimesh_vc=new Vec3,sphereTrimesh_localSphereAABB=new AABB,sphereTrimesh_triangles=[];Narrowphase.prototype[COLLISION_TYPES.sphereTrimesh]=Narrowphase.prototype.sphereTrimesh;const point_on_plane_to_sphere=new Vec3,plane_to_sphere_ortho=new Vec3;Narrowphase.prototype[COLLISION_TYPES.spherePlane]=Narrowphase.prototype.spherePlane;const pointInPolygon_edge=new Vec3,pointInPolygon_edge_x_normal=new Vec3,pointInPolygon_vtp=new Vec3;function pointInPolygon(verts,normal,p){let positiveResult=null;const N=verts.length;for(let i=0;i!==N;i++){const v=verts[i],edge=pointInPolygon_edge;verts[(i+1)%N].vsub(v,edge);const edge_x_normal=pointInPolygon_edge_x_normal;edge.cross(normal,edge_x_normal);const vertex_to_p=pointInPolygon_vtp;p.vsub(v,vertex_to_p);const r=edge_x_normal.dot(vertex_to_p);if(!(null===positiveResult||r>0&&!0===positiveResult||r<=0&&!1===positiveResult))return!1;null===positiveResult&&(positiveResult=r>0)}return!0}const box_to_sphere=new Vec3,sphereBox_ns=new Vec3,sphereBox_ns1=new Vec3,sphereBox_ns2=new Vec3,sphereBox_sides=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3],sphereBox_sphere_to_corner=new Vec3,sphereBox_side_ns=new Vec3,sphereBox_side_ns1=new Vec3,sphereBox_side_ns2=new Vec3;Narrowphase.prototype[COLLISION_TYPES.sphereBox]=Narrowphase.prototype.sphereBox;const convex_to_sphere=new Vec3,sphereConvex_edge=new Vec3,sphereConvex_edgeUnit=new Vec3,sphereConvex_sphereToCorner=new Vec3,sphereConvex_worldCorner=new Vec3,sphereConvex_worldNormal=new Vec3,sphereConvex_worldPoint=new Vec3,sphereConvex_worldSpherePointClosestToPlane=new Vec3,sphereConvex_penetrationVec=new Vec3,sphereConvex_sphereToWorldPoint=new Vec3;Narrowphase.prototype[COLLISION_TYPES.sphereConvex]=Narrowphase.prototype.sphereConvex,Narrowphase.prototype[COLLISION_TYPES.planeBox]=Narrowphase.prototype.planeBox;const planeConvex_v=new Vec3,planeConvex_normal=new Vec3,planeConvex_relpos=new Vec3,planeConvex_projected=new Vec3;Narrowphase.prototype[COLLISION_TYPES.planeConvex]=Narrowphase.prototype.planeConvex;const convexConvex_sepAxis=new Vec3,convexConvex_q=new Vec3;Narrowphase.prototype[COLLISION_TYPES.convexConvex]=Narrowphase.prototype.convexConvex;const particlePlane_normal=new Vec3,particlePlane_relpos=new Vec3,particlePlane_projected=new Vec3;Narrowphase.prototype[COLLISION_TYPES.planeParticle]=Narrowphase.prototype.planeParticle;const particleSphere_normal=new Vec3;Narrowphase.prototype[COLLISION_TYPES.sphereParticle]=Narrowphase.prototype.sphereParticle;const cqj=new Quaternion,convexParticle_local=new Vec3,convexParticle_penetratedFaceNormal=new Vec3,convexParticle_vertexToParticle=new Vec3,convexParticle_worldPenetrationVec=new Vec3;Narrowphase.prototype[COLLISION_TYPES.convexParticle]=Narrowphase.prototype.convexParticle,Narrowphase.prototype[COLLISION_TYPES.boxHeightfield]=Narrowphase.prototype.boxHeightfield;const convexHeightfield_tmp1=new Vec3,convexHeightfield_tmp2=new Vec3,convexHeightfield_faceList=[0];Narrowphase.prototype[COLLISION_TYPES.convexHeightfield]=Narrowphase.prototype.convexHeightfield;const sphereHeightfield_tmp1=new Vec3,sphereHeightfield_tmp2=new Vec3;Narrowphase.prototype[COLLISION_TYPES.sphereHeightfield]=Narrowphase.prototype.sphereHeightfield;class OverlapKeeper{constructor(){this.current=[],this.previous=[]}getKey(i,j){if(j<i){const temp=j;j=i,i=temp}return i<<16|j}set(i,j){const key=this.getKey(i,j),current=this.current;let index=0;for(;key>current[index];)index++;if(key!==current[index]){for(let j=current.length-1;j>=index;j--)current[j+1]=current[j];current[index]=key}}tick(){const tmp=this.current;this.current=this.previous,this.previous=tmp,this.current.length=0}getDiff(additions,removals){const a=this.current,b=this.previous,al=a.length,bl=b.length;let j=0;for(let i=0;i<al;i++){let found=!1;const keyA=a[i];for(;keyA>b[j];)j++;(found=keyA===b[j])||unpackAndPush(additions,keyA)}j=0;for(let i=0;i<bl;i++){let found=!1;const keyB=b[i];for(;keyB>a[j];)j++;(found=a[j]===keyB)||unpackAndPush(removals,keyB)}}}function unpackAndPush(array,key){array.push((4294901760&key)>>16,65535&key)}class TupleDictionary{constructor(){this.data={keys:[]}}get(i,j){if(i>j){const temp=j;j=i,i=temp}return this.data[i+"-"+j]}set(i,j,value){if(i>j){const temp=j;j=i,i=temp}const key=i+"-"+j;this.get(i,j)||this.data.keys.push(key),this.data[key]=value}reset(){const data=this.data,keys=data.keys;for(;keys.length>0;){delete data[keys.pop()]}}}class World extends EventTarget{constructor(options={}){super(),this.dt=-1,this.allowSleep=!!options.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==options.quatNormalizeSkip?options.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==options.quatNormalizeFast&&options.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new Vec3,options.gravity&&this.gravity.copy(options.gravity),this.broadphase=void 0!==options.broadphase?options.broadphase:new NaiveBroadphase,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==options.solver?options.solver:new GSSolver,this.constraints=[],this.narrowphase=new Narrowphase(this),this.collisionMatrix=new ArrayCollisionMatrix,this.collisionMatrixPrevious=new ArrayCollisionMatrix,this.bodyOverlapKeeper=new OverlapKeeper,this.shapeOverlapKeeper=new OverlapKeeper,this.materials=[],this.contactmaterials=[],this.contactMaterialTable=new TupleDictionary,this.defaultMaterial=new Material("default"),this.defaultContactMaterial=new ContactMaterial(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(m1,m2){return this.contactMaterialTable.get(m1.id,m2.id)}numObjects(){return this.bodies.length}collisionMatrixTick(){const temp=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=temp,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(c){this.constraints.push(c)}removeConstraint(c){const idx=this.constraints.indexOf(c);-1!==idx&&this.constraints.splice(idx,1)}rayTest(from,to,result){result instanceof RaycastResult?this.raycastClosest(from,to,{skipBackfaces:!0},result):this.raycastAll(from,to,{skipBackfaces:!0},result)}raycastAll(from,to,options={},callback){return options.mode=Ray.ALL,options.from=from,options.to=to,options.callback=callback,tmpRay$1.intersectWorld(this,options)}raycastAny(from,to,options={},result){return options.mode=Ray.ANY,options.from=from,options.to=to,options.result=result,tmpRay$1.intersectWorld(this,options)}raycastClosest(from,to,options={},result){return options.mode=Ray.CLOSEST,options.from=from,options.to=to,options.result=result,tmpRay$1.intersectWorld(this,options)}addBody(body){this.bodies.includes(body)||(body.index=this.bodies.length,this.bodies.push(body),body.world=this,body.initPosition.copy(body.position),body.initVelocity.copy(body.velocity),body.timeLastSleepy=this.time,body instanceof Body&&(body.initAngularVelocity.copy(body.angularVelocity),body.initQuaternion.copy(body.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=body,this.idToBodyMap[body.id]=body,this.dispatchEvent(this.addBodyEvent))}removeBody(body){body.world=null;const n=this.bodies.length-1,bodies=this.bodies,idx=bodies.indexOf(body);if(-1!==idx){bodies.splice(idx,1);for(let i=0;i!==bodies.length;i++)bodies[i].index=i;this.collisionMatrix.setNumObjects(n),this.removeBodyEvent.body=body,delete this.idToBodyMap[body.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(id){return this.idToBodyMap[id]}getShapeById(id){const bodies=this.bodies;for(let i=0,bl=bodies.length;i<bl;i++){const shapes=bodies[i].shapes;for(let j=0,sl=shapes.length;j<sl;j++){const shape=shapes[j];if(shape.id===id)return shape}}}addMaterial(m){this.materials.push(m)}addContactMaterial(cmat){this.contactmaterials.push(cmat),this.contactMaterialTable.set(cmat.materials[0].id,cmat.materials[1].id,cmat)}step(dt,timeSinceLastCalled=0,maxSubSteps=10){if(0===timeSinceLastCalled)this.internalStep(dt),this.time+=dt;else{this.accumulator+=timeSinceLastCalled;let substeps=0;for(;this.accumulator>=dt&&substeps<maxSubSteps;)this.internalStep(dt),this.accumulator-=dt,substeps++;const t=this.accumulator%dt/dt;for(let j=0;j!==this.bodies.length;j++){const b=this.bodies[j];b.previousPosition.lerp(b.position,t,b.interpolatedPosition),b.previousQuaternion.slerp(b.quaternion,t,b.interpolatedQuaternion),b.previousQuaternion.normalize()}this.time+=timeSinceLastCalled}}internalStep(dt){this.dt=dt;const contacts=this.contacts,p1=World_step_p1,p2=World_step_p2,N=this.numObjects(),bodies=this.bodies,solver=this.solver,gravity=this.gravity,doProfiling=this.doProfiling,profile=this.profile,DYNAMIC=Body.DYNAMIC;let profilingStart=-1/0;const constraints=this.constraints,frictionEquationPool=World_step_frictionEquationPool,gx=(gravity.length(),gravity.x),gy=gravity.y,gz=gravity.z;let i=0;for(doProfiling&&(profilingStart=performance.now()),i=0;i!==N;i++){const bi=bodies[i];if(bi.type===DYNAMIC){const f=bi.force,m=bi.mass;f.x+=m*gx,f.y+=m*gy,f.z+=m*gz}}for(let i=0,Nsubsystems=this.subsystems.length;i!==Nsubsystems;i++)this.subsystems[i].update();doProfiling&&(profilingStart=performance.now()),p1.length=0,p2.length=0,this.broadphase.collisionPairs(this,p1,p2),doProfiling&&(profile.broadphase=performance.now()-profilingStart);let Nconstraints=constraints.length;for(i=0;i!==Nconstraints;i++){const c=constraints[i];if(!c.collideConnected)for(let j=p1.length-1;j>=0;j-=1)(c.bodyA===p1[j]&&c.bodyB===p2[j]||c.bodyB===p1[j]&&c.bodyA===p2[j])&&(p1.splice(j,1),p2.splice(j,1))}this.collisionMatrixTick(),doProfiling&&(profilingStart=performance.now());const oldcontacts=World_step_oldContacts,NoldContacts=contacts.length;for(i=0;i!==NoldContacts;i++)oldcontacts.push(contacts[i]);contacts.length=0;const NoldFrictionEquations=this.frictionEquations.length;for(i=0;i!==NoldFrictionEquations;i++)frictionEquationPool.push(this.frictionEquations[i]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(p1,p2,this,contacts,oldcontacts,this.frictionEquations,frictionEquationPool),doProfiling&&(profile.narrowphase=performance.now()-profilingStart),doProfiling&&(profilingStart=performance.now()),i=0;i<this.frictionEquations.length;i++)solver.addEquation(this.frictionEquations[i]);const ncontacts=contacts.length;for(let k=0;k!==ncontacts;k++){const c=contacts[k],bi=c.bi,bj=c.bj,si=c.si,sj=c.sj;let cm,mu=(cm=bi.material&&bj.material&&this.getContactMaterial(bi.material,bj.material)||this.defaultContactMaterial).friction;if(bi.material&&bj.material&&(bi.material.friction>=0&&bj.material.friction>=0&&(mu=bi.material.friction*bj.material.friction),bi.material.restitution>=0&&bj.material.restitution>=0&&(c.restitution=bi.material.restitution*bj.material.restitution)),solver.addEquation(c),bi.allowSleep&&bi.type===Body.DYNAMIC&&bi.sleepState===Body.SLEEPING&&bj.sleepState===Body.AWAKE&&bj.type!==Body.STATIC){bj.velocity.lengthSquared()+bj.angularVelocity.lengthSquared()>=2*bj.sleepSpeedLimit**2&&(bi.wakeUpAfterNarrowphase=!0)}if(bj.allowSleep&&bj.type===Body.DYNAMIC&&bj.sleepState===Body.SLEEPING&&bi.sleepState===Body.AWAKE&&bi.type!==Body.STATIC){bi.velocity.lengthSquared()+bi.angularVelocity.lengthSquared()>=2*bi.sleepSpeedLimit**2&&(bj.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(bi,bj,!0),this.collisionMatrixPrevious.get(bi,bj)||(World_step_collideEvent.body=bj,World_step_collideEvent.contact=c,bi.dispatchEvent(World_step_collideEvent),World_step_collideEvent.body=bi,bj.dispatchEvent(World_step_collideEvent)),this.bodyOverlapKeeper.set(bi.id,bj.id),this.shapeOverlapKeeper.set(si.id,sj.id)}for(this.emitContactEvents(),doProfiling&&(profile.makeContactConstraints=performance.now()-profilingStart,profilingStart=performance.now()),i=0;i!==N;i++){const bi=bodies[i];bi.wakeUpAfterNarrowphase&&(bi.wakeUp(),bi.wakeUpAfterNarrowphase=!1)}for(Nconstraints=constraints.length,i=0;i!==Nconstraints;i++){const c=constraints[i];c.update();for(let j=0,Neq=c.equations.length;j!==Neq;j++){const eq=c.equations[j];solver.addEquation(eq)}}solver.solve(dt,this),doProfiling&&(profile.solve=performance.now()-profilingStart),solver.removeAllEquations();const pow=Math.pow;for(i=0;i!==N;i++){const bi=bodies[i];if(bi.type&DYNAMIC){const ld=pow(1-bi.linearDamping,dt),v=bi.velocity;v.scale(ld,v);const av=bi.angularVelocity;if(av){const ad=pow(1-bi.angularDamping,dt);av.scale(ad,av)}}}for(this.dispatchEvent(World_step_preStepEvent),i=0;i!==N;i++){const bi=bodies[i];bi.preStep&&bi.preStep.call(bi)}doProfiling&&(profilingStart=performance.now());const quatNormalize=this.stepnumber%(this.quatNormalizeSkip+1)==0,quatNormalizeFast=this.quatNormalizeFast;for(i=0;i!==N;i++)bodies[i].integrate(dt,quatNormalize,quatNormalizeFast);for(this.clearForces(),this.broadphase.dirty=!0,doProfiling&&(profile.integrate=performance.now()-profilingStart),this.time+=dt,this.stepnumber+=1,this.dispatchEvent(World_step_postStepEvent),i=0;i!==N;i++){const bi=bodies[i],postStep=bi.postStep;postStep&&postStep.call(bi)}let hasActiveBodies=!0;if(this.allowSleep)for(hasActiveBodies=!1,i=0;i!==N;i++){const bi=bodies[i];bi.sleepTick(this.time),bi.sleepState!==Body.SLEEPING&&(hasActiveBodies=!0)}this.hasActiveBodies=hasActiveBodies}clearForces(){const bodies=this.bodies,N=bodies.length;for(let i=0;i!==N;i++){const b=bodies[i];b.force,b.torque;b.force.set(0,0,0),b.torque.set(0,0,0)}}}exports.World=World;new AABB;const tmpRay$1=new Ray;if("undefined"==typeof performance&&(performance={}),!performance.now){let nowOffset=Date.now();performance.timing&&performance.timing.navigationStart&&(nowOffset=performance.timing.navigationStart),performance.now=(()=>Date.now()-nowOffset)}const World_step_postStepEvent={type:"postStep"},World_step_preStepEvent={type:"preStep"},World_step_collideEvent={type:Body.COLLIDE_EVENT_NAME,body:null,contact:null},World_step_oldContacts=[],World_step_frictionEquationPool=[],World_step_p1=[],World_step_p2=[];World.prototype.emitContactEvents=(()=>{const additions=[],removals=[],beginContactEvent={type:"beginContact",bodyA:null,bodyB:null},endContactEvent={type:"endContact",bodyA:null,bodyB:null},beginShapeContactEvent={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},endShapeContactEvent={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};return function(){const hasBeginContact=this.hasAnyEventListener("beginContact"),hasEndContact=this.hasAnyEventListener("endContact");if((hasBeginContact||hasEndContact)&&this.bodyOverlapKeeper.getDiff(additions,removals),hasBeginContact){for(let i=0,l=additions.length;i<l;i+=2)beginContactEvent.bodyA=this.getBodyById(additions[i]),beginContactEvent.bodyB=this.getBodyById(additions[i+1]),this.dispatchEvent(beginContactEvent);beginContactEvent.bodyA=beginContactEvent.bodyB=null}if(hasEndContact){for(let i=0,l=removals.length;i<l;i+=2)endContactEvent.bodyA=this.getBodyById(removals[i]),endContactEvent.bodyB=this.getBodyById(removals[i+1]),this.dispatchEvent(endContactEvent);endContactEvent.bodyA=endContactEvent.bodyB=null}additions.length=removals.length=0;const hasBeginShapeContact=this.hasAnyEventListener("beginShapeContact"),hasEndShapeContact=this.hasAnyEventListener("endShapeContact");if((hasBeginShapeContact||hasEndShapeContact)&&this.shapeOverlapKeeper.getDiff(additions,removals),hasBeginShapeContact){for(let i=0,l=additions.length;i<l;i+=2){const shapeA=this.getShapeById(additions[i]),shapeB=this.getShapeById(additions[i+1]);beginShapeContactEvent.shapeA=shapeA,beginShapeContactEvent.shapeB=shapeB,beginShapeContactEvent.bodyA=shapeA.body,beginShapeContactEvent.bodyB=shapeB.body,this.dispatchEvent(beginShapeContactEvent)}beginShapeContactEvent.bodyA=beginShapeContactEvent.bodyB=beginShapeContactEvent.shapeA=beginShapeContactEvent.shapeB=null}if(hasEndShapeContact){for(let i=0,l=removals.length;i<l;i+=2){const shapeA=this.getShapeById(removals[i]),shapeB=this.getShapeById(removals[i+1]);endShapeContactEvent.shapeA=shapeA,endShapeContactEvent.shapeB=shapeB,endShapeContactEvent.bodyA=shapeA.body,endShapeContactEvent.bodyB=shapeB.body,this.dispatchEvent(endShapeContactEvent)}endShapeContactEvent.bodyA=endShapeContactEvent.bodyB=endShapeContactEvent.shapeA=endShapeContactEvent.shapeB=null}}})()},{}],6:[function(require,module,exports){(function(global){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.iterateGeometries=exports.createVHACDShapes=exports.createTriMeshShape=exports.createSphereShape=exports.createHullShape=exports.createHeightfieldTerrainShape=exports.createHACDShapes=exports.createCylinderShape=exports.createConeShape=exports.createCollisionShapes=exports.createCapsuleShape=exports.createBoxShape=exports.TYPE=exports.HEIGHTFIELD_DATA_TYPE=exports.FIT=void 0;var THREE=function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!=typeof obj&&"function"!=typeof obj)return{default:obj};var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj))return cache.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj,cache&&cache.set(obj,newObj);return newObj}("undefined"!=typeof window?window.THREE:void 0!==global?global.THREE:null);function _getRequireWildcardCache(nodeInterop){if("function"!=typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}const TYPE=exports.TYPE={BOX:"box",CYLINDER:"cylinder",SPHERE:"sphere",CAPSULE:"capsule",CONE:"cone",HULL:"hull",HACD:"hacd",VHACD:"vhacd",MESH:"mesh",HEIGHTFIELD:"heightfield"},FIT=exports.FIT={ALL:"all",MANUAL:"manual"};exports.HEIGHTFIELD_DATA_TYPE={short:"short",float:"float"};exports.createCollisionShapes=function(vertices,matrices,indexes,matrixWorld,options={}){switch(options.type){case TYPE.BOX:return[createBoxShape(vertices,matrices,matrixWorld,options)];case TYPE.CYLINDER:return[createCylinderShape(vertices,matrices,matrixWorld,options)];case TYPE.CAPSULE:return[createCapsuleShape(vertices,matrices,matrixWorld,options)];case TYPE.CONE:return[createConeShape(vertices,matrices,matrixWorld,options)];case TYPE.SPHERE:return[createSphereShape(vertices,matrices,matrixWorld,options)];case TYPE.HULL:return[createHullShape(vertices,matrices,matrixWorld,options)];case TYPE.HACD:return createHACDShapes(vertices,matrices,indexes,matrixWorld,options);case TYPE.VHACD:return createVHACDShapes(vertices,matrices,indexes,matrixWorld,options);case TYPE.MESH:return[createTriMeshShape(vertices,matrices,indexes,matrixWorld,options)];case TYPE.HEIGHTFIELD:return[createHeightfieldTerrainShape(options)];default:return console.warn(options.type+" is not currently supported"),[]}};const createBoxShape=function(vertices,matrices,matrixWorld,options={}){options.type=TYPE.BOX,_setOptions(options),options.fit===FIT.ALL&&(options.halfExtents=_computeHalfExtents(_computeBounds(vertices,matrices),options.minHalfExtent,options.maxHalfExtent));const btHalfExtents=new Ammo.btVector3(options.halfExtents.x,options.halfExtents.y,options.halfExtents.z),collisionShape=new Ammo.btBoxShape(btHalfExtents);return Ammo.destroy(btHalfExtents),_finishCollisionShape(collisionShape,options,_computeScale(matrixWorld,options)),collisionShape};exports.createBoxShape=createBoxShape;const createCylinderShape=function(vertices,matrices,matrixWorld,options={}){options.type=TYPE.CYLINDER,_setOptions(options),options.fit===FIT.ALL&&(options.halfExtents=_computeHalfExtents(_computeBounds(vertices,matrices),options.minHalfExtent,options.maxHalfExtent));const btHalfExtents=new Ammo.btVector3(options.halfExtents.x,options.halfExtents.y,options.halfExtents.z),collisionShape=(()=>{switch(options.cylinderAxis){case"y":return new Ammo.btCylinderShape(btHalfExtents);case"x":return new Ammo.btCylinderShapeX(btHalfExtents);case"z":return new Ammo.btCylinderShapeZ(btHalfExtents)}return null})();return Ammo.destroy(btHalfExtents),_finishCollisionShape(collisionShape,options,_computeScale(matrixWorld,options)),collisionShape};exports.createCylinderShape=createCylinderShape;const createCapsuleShape=function(vertices,matrices,matrixWorld,options={}){options.type=TYPE.CAPSULE,_setOptions(options),options.fit===FIT.ALL&&(options.halfExtents=_computeHalfExtents(_computeBounds(vertices,matrices),options.minHalfExtent,options.maxHalfExtent));const{x:x,y:y,z:z}=options.halfExtents,collisionShape=(()=>{switch(options.cylinderAxis){case"y":return new Ammo.btCapsuleShape(Math.max(x,z),2*y);case"x":return new Ammo.btCapsuleShapeX(Math.max(y,z),2*x);case"z":return new Ammo.btCapsuleShapeZ(Math.max(x,y),2*z)}return null})();return _finishCollisionShape(collisionShape,options,_computeScale(matrixWorld,options)),collisionShape};exports.createCapsuleShape=createCapsuleShape;const createConeShape=function(vertices,matrices,matrixWorld,options={}){options.type=TYPE.CONE,_setOptions(options),options.fit===FIT.ALL&&(options.halfExtents=_computeHalfExtents(_computeBounds(vertices,matrices),options.minHalfExtent,options.maxHalfExtent));const{x:x,y:y,z:z}=options.halfExtents,collisionShape=(()=>{switch(options.cylinderAxis){case"y":return new Ammo.btConeShape(Math.max(x,z),2*y);case"x":return new Ammo.btConeShapeX(Math.max(y,z),2*x);case"z":return new Ammo.btConeShapeZ(Math.max(x,y),2*z)}return null})();return _finishCollisionShape(collisionShape,options,_computeScale(matrixWorld,options)),collisionShape};exports.createConeShape=createConeShape;const createSphereShape=function(vertices,matrices,matrixWorld,options={}){let radius;options.type=TYPE.SPHERE,_setOptions(options),radius=options.fit!==FIT.MANUAL||isNaN(options.sphereRadius)?_computeRadius(vertices,matrices,_computeBounds(vertices,matrices)):options.sphereRadius;const collisionShape=new Ammo.btSphereShape(radius);return _finishCollisionShape(collisionShape,options,_computeScale(matrixWorld,options)),collisionShape};exports.createSphereShape=createSphereShape;const createHullShape=exports.createHullShape=function(){const vertex=new THREE.Vector3,center=new THREE.Vector3,matrix=new THREE.Matrix4;return function(vertices,matrices,matrixWorld,options={}){if(options.type=TYPE.HULL,_setOptions(options),options.fit===FIT.MANUAL)return console.warn("cannot use fit: manual with type: hull"),null;const bounds=_computeBounds(vertices,matrices),btVertex=new Ammo.btVector3,originalHull=new Ammo.btConvexHullShape;originalHull.setMargin(options.margin),center.addVectors(bounds.max,bounds.min).multiplyScalar(.5);let vertexCount=0;for(let i=0;i<vertices.length;i++)vertexCount+=vertices[i].length/3;const maxVertices=options.hullMaxVertices||1e5;vertexCount>maxVertices&&console.warn(`too many vertices for hull shape; sampling ~${maxVertices} from ~${vertexCount} vertices`);const p=Math.min(1,maxVertices/vertexCount);for(let i=0;i<vertices.length;i++){const components=vertices[i];matrix.fromArray(matrices[i]);for(let j=0;j<components.length;j+=3){const isLastVertex=i===vertices.length-1&&j===components.length-3;(Math.random()<=p||isLastVertex)&&(vertex.set(components[j],components[j+1],components[j+2]).applyMatrix4(matrix).sub(center),btVertex.setValue(vertex.x,vertex.y,vertex.z),originalHull.addPoint(btVertex,isLastVertex))}}let collisionShape=originalHull;if(originalHull.getNumVertices()>=100){const shapeHull=new Ammo.btShapeHull(originalHull);shapeHull.buildHull(options.margin),Ammo.destroy(originalHull),collisionShape=new Ammo.btConvexHullShape(Ammo.getPointer(shapeHull.getVertexPointer()),shapeHull.numVertices()),Ammo.destroy(shapeHull)}return Ammo.destroy(btVertex),_finishCollisionShape(collisionShape,options,_computeScale(matrixWorld,options)),collisionShape}}(),createHACDShapes=exports.createHACDShapes=function(){const vector=new THREE.Vector3,center=new THREE.Vector3,matrix=new THREE.Matrix4;return function(vertices,matrices,indexes,matrixWorld,options={}){if(options.type=TYPE.HACD,_setOptions(options),options.fit===FIT.MANUAL)return console.warn("cannot use fit: manual with type: hacd"),[];if(!Ammo.hasOwnProperty("HACD"))return console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const bounds=_computeBounds(vertices,matrices),scale=_computeScale(matrixWorld,options);let vertexCount=0,triCount=0;center.addVectors(bounds.max,bounds.min).multiplyScalar(.5);for(let i=0;i<vertices.length;i++)vertexCount+=vertices[i].length/3,indexes&&indexes[i]?triCount+=indexes[i].length/3:triCount+=vertices[i].length/9;const hacd=new Ammo.HACD;options.hasOwnProperty("compacityWeight")&&hacd.SetCompacityWeight(options.compacityWeight),options.hasOwnProperty("volumeWeight")&&hacd.SetVolumeWeight(options.volumeWeight),options.hasOwnProperty("nClusters")&&hacd.SetNClusters(options.nClusters),options.hasOwnProperty("nVerticesPerCH")&&hacd.SetNVerticesPerCH(options.nVerticesPerCH),options.hasOwnProperty("concavity")&&hacd.SetConcavity(options.concavity);const points=Ammo._malloc(3*vertexCount*8),triangles=Ammo._malloc(3*triCount*4);hacd.SetPoints(points),hacd.SetTriangles(triangles),hacd.SetNPoints(vertexCount),hacd.SetNTriangles(triCount);let pptr=points/8,tptr=triangles/4;for(let i=0;i<vertices.length;i++){const components=vertices[i];matrix.fromArray(matrices[i]);for(let j=0;j<components.length;j+=3)vector.set(components[j+0],components[j+1],components[j+2]).applyMatrix4(matrix).sub(center),Ammo.HEAPF64[pptr+0]=vector.x,Ammo.HEAPF64[pptr+1]=vector.y,Ammo.HEAPF64[pptr+2]=vector.z,pptr+=3;if(indexes[i]){const indices=indexes[i];for(let j=0;j<indices.length;j++)Ammo.HEAP32[tptr]=indices[j],tptr++}else for(let j=0;j<components.length/3;j++)Ammo.HEAP32[tptr]=j,tptr++}hacd.Compute(),Ammo._free(points),Ammo._free(triangles);const nClusters=hacd.GetNClusters(),shapes=[];for(let i=0;i<nClusters;i++){const hull=new Ammo.btConvexHullShape;hull.setMargin(options.margin);const nPoints=hacd.GetNPointsCH(i),nTriangles=hacd.GetNTrianglesCH(i),hullPoints=Ammo._malloc(3*nPoints*8),hullTriangles=Ammo._malloc(3*nTriangles*4);hacd.GetCH(i,hullPoints,hullTriangles);const pptr=hullPoints/8;for(let pi=0;pi<nPoints;pi++){const btVertex=new Ammo.btVector3,px=Ammo.HEAPF64[pptr+3*pi+0],py=Ammo.HEAPF64[pptr+3*pi+1],pz=Ammo.HEAPF64[pptr+3*pi+2];btVertex.setValue(px,py,pz),hull.addPoint(btVertex,pi===nPoints-1),Ammo.destroy(btVertex)}_finishCollisionShape(hull,options,scale),shapes.push(hull)}return shapes}}(),createVHACDShapes=exports.createVHACDShapes=function(){const vector=new THREE.Vector3,center=new THREE.Vector3,matrix=new THREE.Matrix4;return function(vertices,matrices,indexes,matrixWorld,options={}){if(options.type=TYPE.VHACD,_setOptions(options),options.fit===FIT.MANUAL)return console.warn("cannot use fit: manual with type: vhacd"),[];if(!Ammo.hasOwnProperty("VHACD"))return console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const bounds=_computeBounds(vertices,matrices),scale=_computeScale(matrixWorld,options);let vertexCount=0,triCount=0;center.addVectors(bounds.max,bounds.min).multiplyScalar(.5);for(let i=0;i<vertices.length;i++)vertexCount+=vertices[i].length/3,indexes&&indexes[i]?triCount+=indexes[i].length/3:triCount+=vertices[i].length/9;const vhacd=new Ammo.VHACD,params=new Ammo.Parameters;options.hasOwnProperty("resolution")&&params.set_m_resolution(options.resolution),options.hasOwnProperty("depth")&&params.set_m_depth(options.depth),options.hasOwnProperty("concavity")&&params.set_m_concavity(options.concavity),options.hasOwnProperty("planeDownsampling")&&params.set_m_planeDownsampling(options.planeDownsampling),options.hasOwnProperty("convexhullDownsampling")&&params.set_m_convexhullDownsampling(options.convexhullDownsampling),options.hasOwnProperty("alpha")&&params.set_m_alpha(options.alpha),options.hasOwnProperty("beta")&&params.set_m_beta(options.beta),options.hasOwnProperty("gamma")&&params.set_m_gamma(options.gamma),options.hasOwnProperty("pca")&&params.set_m_pca(options.pca),options.hasOwnProperty("mode")&&params.set_m_mode(options.mode),options.hasOwnProperty("maxNumVerticesPerCH")&&params.set_m_maxNumVerticesPerCH(options.maxNumVerticesPerCH),options.hasOwnProperty("minVolumePerCH")&&params.set_m_minVolumePerCH(options.minVolumePerCH),options.hasOwnProperty("convexhullApproximation")&&params.set_m_convexhullApproximation(options.convexhullApproximation),options.hasOwnProperty("oclAcceleration")&&params.set_m_oclAcceleration(options.oclAcceleration);const points=Ammo._malloc(3*vertexCount*8+3),triangles=Ammo._malloc(3*triCount*4);let pptr=points/8,tptr=triangles/4;for(let i=0;i<vertices.length;i++){const components=vertices[i];matrix.fromArray(matrices[i]);for(let j=0;j<components.length;j+=3)vector.set(components[j+0],components[j+1],components[j+2]).applyMatrix4(matrix).sub(center),Ammo.HEAPF64[pptr+0]=vector.x,Ammo.HEAPF64[pptr+1]=vector.y,Ammo.HEAPF64[pptr+2]=vector.z,pptr+=3;if(indexes[i]){const indices=indexes[i];for(let j=0;j<indices.length;j++)Ammo.HEAP32[tptr]=indices[j],tptr++}else for(let j=0;j<components.length/3;j++)Ammo.HEAP32[tptr]=j,tptr++}vhacd.Compute(points,3,vertexCount,triangles,3,triCount,params),Ammo._free(points),Ammo._free(triangles);const nHulls=vhacd.GetNConvexHulls(),shapes=[],ch=new Ammo.ConvexHull;for(let i=0;i<nHulls;i++){vhacd.GetConvexHull(i,ch);const nPoints=ch.get_m_nPoints(),hull=(ch.get_m_points(),new Ammo.btConvexHullShape);hull.setMargin(options.margin);for(let pi=0;pi<nPoints;pi++){const btVertex=new Ammo.btVector3,px=ch.get_m_points(3*pi+0),py=ch.get_m_points(3*pi+1),pz=ch.get_m_points(3*pi+2);btVertex.setValue(px,py,pz),hull.addPoint(btVertex,pi===nPoints-1),Ammo.destroy(btVertex)}_finishCollisionShape(hull,options,scale),shapes.push(hull)}return Ammo.destroy(ch),Ammo.destroy(vhacd),shapes}}(),createTriMeshShape=exports.createTriMeshShape=function(){const va=new THREE.Vector3,vb=new THREE.Vector3,vc=new THREE.Vector3,matrix=new THREE.Matrix4;return function(vertices,matrices,indexes,matrixWorld,options={}){if(options.type=TYPE.MESH,_setOptions(options),options.fit===FIT.MANUAL)return console.warn("cannot use fit: manual with type: mesh"),null;const scale=_computeScale(matrixWorld,options),bta=new Ammo.btVector3,btb=new Ammo.btVector3,btc=new Ammo.btVector3,triMesh=new Ammo.btTriangleMesh(!0,!1);for(let i=0;i<vertices.length;i++){const components=vertices[i],index=indexes[i]?indexes[i]:null;if(matrix.fromArray(matrices[i]),index)for(let j=0;j<index.length;j+=3){const ai=3*index[j],bi=3*index[j+1],ci=3*index[j+2];va.set(components[ai],components[ai+1],components[ai+2]).applyMatrix4(matrix),vb.set(components[bi],components[bi+1],components[bi+2]).applyMatrix4(matrix),vc.set(components[ci],components[ci+1],components[ci+2]).applyMatrix4(matrix),bta.setValue(va.x,va.y,va.z),btb.setValue(vb.x,vb.y,vb.z),btc.setValue(vc.x,vc.y,vc.z),triMesh.addTriangle(bta,btb,btc,!1)}else for(let j=0;j<components.length;j+=9)va.set(components[j+0],components[j+1],components[j+2]).applyMatrix4(matrix),vb.set(components[j+3],components[j+4],components[j+5]).applyMatrix4(matrix),vc.set(components[j+6],components[j+7],components[j+8]).applyMatrix4(matrix),bta.setValue(va.x,va.y,va.z),btb.setValue(vb.x,vb.y,vb.z),btc.setValue(vc.x,vc.y,vc.z),triMesh.addTriangle(bta,btb,btc,!1)}const localScale=new Ammo.btVector3(scale.x,scale.y,scale.z);triMesh.setScaling(localScale),Ammo.destroy(localScale);const collisionShape=new Ammo.btBvhTriangleMeshShape(triMesh,!0,!0);return collisionShape.resources=[triMesh],Ammo.destroy(bta),Ammo.destroy(btb),Ammo.destroy(btc),_finishCollisionShape(collisionShape,options),collisionShape}}(),createHeightfieldTerrainShape=function(options={}){if(_setOptions(options),options.fit===FIT.ALL)return console.warn("cannot use fit: all with type: heightfield"),null;const heightfieldDistance=options.heightfieldDistance||1,heightfieldData=options.heightfieldData||[],heightScale=options.heightScale||0,upAxis=options.hasOwnProperty("upAxis")?options.upAxis:1,hdt=(()=>{switch(options.heightDataType){case"short":return Ammo.PHY_SHORT;case"float":default:return Ammo.PHY_FLOAT}})(),flipQuadEdges=!options.hasOwnProperty("flipQuadEdges")||options.flipQuadEdges,heightStickLength=heightfieldData.length,heightStickWidth=heightStickLength>0?heightfieldData[0].length:0,data=Ammo._malloc(heightStickLength*heightStickWidth*4),ptr=data/4;let minHeight=Number.POSITIVE_INFINITY,maxHeight=Number.NEGATIVE_INFINITY,index=0;for(let l=0;l<heightStickLength;l++)for(let w=0;w<heightStickWidth;w++){const height=heightfieldData[l][w];Ammo.HEAPF32[ptr+index]=height,index++,minHeight=Math.min(minHeight,height),maxHeight=Math.max(maxHeight,height)}const collisionShape=new Ammo.btHeightfieldTerrainShape(heightStickWidth,heightStickLength,data,heightScale,minHeight,maxHeight,upAxis,hdt,flipQuadEdges),scale=new Ammo.btVector3(heightfieldDistance,1,heightfieldDistance);return collisionShape.setLocalScaling(scale),Ammo.destroy(scale),collisionShape.heightfieldData=data,_finishCollisionShape(collisionShape,options),collisionShape};function _setOptions(options){options.fit=options.hasOwnProperty("fit")?options.fit:FIT.ALL,options.type=options.type||TYPE.HULL,options.minHalfExtent=options.hasOwnProperty("minHalfExtent")?options.minHalfExtent:0,options.maxHalfExtent=options.hasOwnProperty("maxHalfExtent")?options.maxHalfExtent:Number.POSITIVE_INFINITY,options.cylinderAxis=options.cylinderAxis||"y",options.margin=options.hasOwnProperty("margin")?options.margin:.01,options.includeInvisible=!!options.hasOwnProperty("includeInvisible")&&options.includeInvisible,options.offset||(options.offset=new THREE.Vector3),options.orientation||(options.orientation=new THREE.Quaternion)}exports.createHeightfieldTerrainShape=createHeightfieldTerrainShape;const _finishCollisionShape=function(collisionShape,options,scale){collisionShape.type=options.type,collisionShape.setMargin(options.margin),collisionShape.destroy=(()=>{for(let res of collisionShape.resources||[])Ammo.destroy(res);collisionShape.heightfieldData&&Ammo._free(collisionShape.heightfieldData),Ammo.destroy(collisionShape)});const localTransform=new Ammo.btTransform,rotation=new Ammo.btQuaternion;if(localTransform.setIdentity(),localTransform.getOrigin().setValue(options.offset.x,options.offset.y,options.offset.z),rotation.setValue(options.orientation.x,options.orientation.y,options.orientation.z,options.orientation.w),localTransform.setRotation(rotation),Ammo.destroy(rotation),scale){const localScale=new Ammo.btVector3(scale.x,scale.y,scale.z);collisionShape.setLocalScaling(localScale),Ammo.destroy(localScale)}collisionShape.localTransform=localTransform},_computeScale=(exports.iterateGeometries=function(){const inverse=new THREE.Matrix4;return function(root,options,cb){inverse.copy(root.matrixWorld).invert(),(new THREE.Vector3).setFromMatrixScale(root.matrixWorld),root.traverse(mesh=>{const transform=new THREE.Matrix4;mesh.isMesh&&"Sky"!==mesh.name&&(options.includeInvisible||mesh.el&&mesh.el.object3D.visible||mesh.visible)&&(mesh===root?transform.identity():(mesh.updateWorldMatrix(!0),transform.multiplyMatrices(inverse,mesh.matrixWorld)),cb(mesh.geometry.isBufferGeometry?mesh.geometry.attributes.position.array:mesh.geometry.vertices,transform.elements,mesh.geometry.index?mesh.geometry.index.array:null))})}}(),function(){const matrix=new THREE.Matrix4;return function(matrixWorld,options={}){const scale=new THREE.Vector3(1,1,1);return options.fit===FIT.ALL&&(matrix.fromArray(matrixWorld),scale.setFromMatrixScale(matrix)),scale}}()),_computeRadius=function(){const center=new THREE.Vector3;return function(vertices,matrices,bounds){let maxRadiusSq=0,{x:cx,y:cy,z:cz}=bounds.getCenter(center);return _iterateVertices(vertices,matrices,v=>{const dx=cx-v.x,dy=cy-v.y,dz=cz-v.z;maxRadiusSq=Math.max(maxRadiusSq,dx*dx+dy*dy+dz*dz)}),Math.sqrt(maxRadiusSq)}}(),_computeHalfExtents=function(bounds,minHalfExtent,maxHalfExtent){return(new THREE.Vector3).subVectors(bounds.max,bounds.min).multiplyScalar(.5).clampScalar(minHalfExtent,maxHalfExtent)},_computeBounds=function(vertices,matrices){const bounds=new THREE.Box3;let minX=1/0,minY=1/0,minZ=1/0,maxX=-1/0,maxY=-1/0,maxZ=-1/0;return bounds.min.set(0,0,0),bounds.max.set(0,0,0),_iterateVertices(vertices,matrices,v=>{v.x<minX&&(minX=v.x),v.y<minY&&(minY=v.y),v.z<minZ&&(minZ=v.z),v.x>maxX&&(maxX=v.x),v.y>maxY&&(maxY=v.y),v.z>maxZ&&(maxZ=v.z)}),bounds.min.set(minX,minY,minZ),bounds.max.set(maxX,maxY,maxZ),bounds},_iterateVertices=function(){const vertex=new THREE.Vector3,matrix=new THREE.Matrix4;return function(vertices,matrices,cb){for(let i=0;i<vertices.length;i++){matrix.fromArray(matrices[i]);for(let j=0;j<vertices[i].length;j+=3)vertex.set(vertices[i][j],vertices[i][j+1],vertices[i][j+2]).applyMatrix4(matrix),cb(vertex)}}}()}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],7:[function(require,module,exports){(function(global){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.threeToCannon=exports.getShapeParameters=exports.ShapeType=void 0;var _cannonEs=require("cannon-es"),_three="undefined"!=typeof window?window.THREE:void 0!==global?global.THREE:null,ConvexHull=function(){var line3,plane,closestPoint,triangle,Visible=0,v1=new _three.Vector3;function ConvexHull(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new VertexList,this.unassigned=new VertexList,this.vertices=[]}function Face(){this.normal=new _three.Vector3,this.midpoint=new _three.Vector3,this.area=0,this.constant=0,this.outside=null,this.mark=Visible,this.edge=null}function HalfEdge(vertex,face){this.vertex=vertex,this.prev=null,this.next=null,this.twin=null,this.face=face}function VertexNode(point){this.point=point,this.prev=null,this.next=null,this.face=null}function VertexList(){this.head=null,this.tail=null}return Object.assign(ConvexHull.prototype,{setFromPoints:function(points){!0!==Array.isArray(points)&&console.error("THREE.ConvexHull: Points parameter is not an array."),points.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(var i=0,l=points.length;i<l;i++)this.vertices.push(new VertexNode(points[i]));return this.compute(),this},setFromObject:function(object){var points=[];return object.updateMatrixWorld(!0),object.traverse(function(node){var i,l,point,geometry=node.geometry;if(void 0!==geometry&&(geometry.isGeometry&&(geometry=geometry.toBufferGeometry?geometry.toBufferGeometry():(new _three.BufferGeometry).fromGeometry(geometry)),geometry.isBufferGeometry)){var attribute=geometry.attributes.position;if(void 0!==attribute)for(i=0,l=attribute.count;i<l;i++)(point=new _three.Vector3).fromBufferAttribute(attribute,i).applyMatrix4(node.matrixWorld),points.push(point)}}),this.setFromPoints(points)},containsPoint:function(point){for(var faces=this.faces,i=0,l=faces.length;i<l;i++){if(faces[i].distanceToPoint(point)>this.tolerance)return!1}return!0},intersectRay:function(ray,target){for(var faces=this.faces,tNear=-1/0,tFar=1/0,i=0,l=faces.length;i<l;i++){var face=faces[i],vN=face.distanceToPoint(ray.origin),vD=face.normal.dot(ray.direction);if(vN>0&&vD>=0)return null;var t=0!==vD?-vN/vD:0;if(!(t<=0)&&(vD>0?tFar=Math.min(t,tFar):tNear=Math.max(t,tNear),tNear>tFar))return null}return tNear!==-1/0?ray.at(tNear,target):ray.at(tFar,target),target},intersectsRay:function(ray){return null!==this.intersectRay(ray,v1)},makeEmpty:function(){return this.faces=[],this.vertices=[],this},addVertexToFace:function(vertex,face){return vertex.face=face,null===face.outside?this.assigned.append(vertex):this.assigned.insertBefore(face.outside,vertex),face.outside=vertex,this},removeVertexFromFace:function(vertex,face){return vertex===face.outside&&(null!==vertex.next&&vertex.next.face===face?face.outside=vertex.next:face.outside=null),this.assigned.remove(vertex),this},removeAllVerticesFromFace:function(face){if(null!==face.outside){for(var start=face.outside,end=face.outside;null!==end.next&&end.next.face===face;)end=end.next;return this.assigned.removeSubList(start,end),start.prev=end.next=null,face.outside=null,start}},deleteFaceVertices:function(face,absorbingFace){var faceVertices=this.removeAllVerticesFromFace(face);if(void 0!==faceVertices)if(void 0===absorbingFace)this.unassigned.appendChain(faceVertices);else{var vertex=faceVertices;do{var nextVertex=vertex.next;absorbingFace.distanceToPoint(vertex.point)>this.tolerance?this.addVertexToFace(vertex,absorbingFace):this.unassigned.append(vertex),vertex=nextVertex}while(null!==vertex)}return this},resolveUnassignedPoints:function(newFaces){if(!1===this.unassigned.isEmpty()){var vertex=this.unassigned.first();do{for(var nextVertex=vertex.next,maxDistance=this.tolerance,maxFace=null,i=0;i<newFaces.length;i++){var face=newFaces[i];if(face.mark===Visible){var distance=face.distanceToPoint(vertex.point);if(distance>maxDistance&&(maxDistance=distance,maxFace=face),maxDistance>1e3*this.tolerance)break}}null!==maxFace&&this.addVertexToFace(vertex,maxFace),vertex=nextVertex}while(null!==vertex)}return this},computeExtremes:function(){var i,l,j,min=new _three.Vector3,max=new _three.Vector3,minVertices=[],maxVertices=[];for(i=0;i<3;i++)minVertices[i]=maxVertices[i]=this.vertices[0];for(min.copy(this.vertices[0].point),max.copy(this.vertices[0].point),i=0,l=this.vertices.length;i<l;i++){var vertex=this.vertices[i],point=vertex.point;for(j=0;j<3;j++)point.getComponent(j)<min.getComponent(j)&&(min.setComponent(j,point.getComponent(j)),minVertices[j]=vertex);for(j=0;j<3;j++)point.getComponent(j)>max.getComponent(j)&&(max.setComponent(j,point.getComponent(j)),maxVertices[j]=vertex)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(min.x),Math.abs(max.x))+Math.max(Math.abs(min.y),Math.abs(max.y))+Math.max(Math.abs(min.z),Math.abs(max.z))),{min:minVertices,max:maxVertices}},computeInitialHull:function(){void 0===line3&&(line3=new _three.Line3,plane=new _three.Plane,closestPoint=new _three.Vector3);var vertex,v0,v1,v2,v3,i,l,j,distance,vertices=this.vertices,extremes=this.computeExtremes(),min=extremes.min,max=extremes.max,maxDistance=0,index=0;for(i=0;i<3;i++)(distance=max[i].point.getComponent(i)-min[i].point.getComponent(i))>maxDistance&&(maxDistance=distance,index=i);for(v0=min[index],v1=max[index],maxDistance=0,line3.set(v0.point,v1.point),i=0,l=this.vertices.length;i<l;i++)(vertex=vertices[i])!==v0&&vertex!==v1&&(line3.closestPointToPoint(vertex.point,!0,closestPoint),(distance=closestPoint.distanceToSquared(vertex.point))>maxDistance&&(maxDistance=distance,v2=vertex));for(maxDistance=-1,plane.setFromCoplanarPoints(v0.point,v1.point,v2.point),i=0,l=this.vertices.length;i<l;i++)(vertex=vertices[i])!==v0&&vertex!==v1&&vertex!==v2&&(distance=Math.abs(plane.distanceToPoint(vertex.point)))>maxDistance&&(maxDistance=distance,v3=vertex);var faces=[];if(plane.distanceToPoint(v3.point)<0)for(faces.push(Face.create(v0,v1,v2),Face.create(v3,v1,v0),Face.create(v3,v2,v1),Face.create(v3,v0,v2)),i=0;i<3;i++)j=(i+1)%3,faces[i+1].getEdge(2).setTwin(faces[0].getEdge(j)),faces[i+1].getEdge(1).setTwin(faces[j+1].getEdge(0));else for(faces.push(Face.create(v0,v2,v1),Face.create(v3,v0,v1),Face.create(v3,v1,v2),Face.create(v3,v2,v0)),i=0;i<3;i++)j=(i+1)%3,faces[i+1].getEdge(2).setTwin(faces[0].getEdge((3-i)%3)),faces[i+1].getEdge(0).setTwin(faces[j+1].getEdge(1));for(i=0;i<4;i++)this.faces.push(faces[i]);for(i=0,l=vertices.length;i<l;i++)if((vertex=vertices[i])!==v0&&vertex!==v1&&vertex!==v2&&vertex!==v3){maxDistance=this.tolerance;var maxFace=null;for(j=0;j<4;j++)(distance=this.faces[j].distanceToPoint(vertex.point))>maxDistance&&(maxDistance=distance,maxFace=this.faces[j]);null!==maxFace&&this.addVertexToFace(vertex,maxFace)}return this},reindexFaces:function(){for(var activeFaces=[],i=0;i<this.faces.length;i++){var face=this.faces[i];face.mark===Visible&&activeFaces.push(face)}return this.faces=activeFaces,this},nextVertexToAdd:function(){if(!1===this.assigned.isEmpty()){var eyeVertex,maxDistance=0,eyeFace=this.assigned.first().face,vertex=eyeFace.outside;do{var distance=eyeFace.distanceToPoint(vertex.point);distance>maxDistance&&(maxDistance=distance,eyeVertex=vertex),vertex=vertex.next}while(null!==vertex&&vertex.face===eyeFace);return eyeVertex}},computeHorizon:function(eyePoint,crossEdge,face,horizon){var edge;this.deleteFaceVertices(face),face.mark=1,edge=null===crossEdge?crossEdge=face.getEdge(0):crossEdge.next;do{var twinEdge=edge.twin,oppositeFace=twinEdge.face;oppositeFace.mark===Visible&&(oppositeFace.distanceToPoint(eyePoint)>this.tolerance?this.computeHorizon(eyePoint,twinEdge,oppositeFace,horizon):horizon.push(edge)),edge=edge.next}while(edge!==crossEdge);return this},addAdjoiningFace:function(eyeVertex,horizonEdge){var face=Face.create(eyeVertex,horizonEdge.tail(),horizonEdge.head());return this.faces.push(face),face.getEdge(-1).setTwin(horizonEdge.twin),face.getEdge(0)},addNewFaces:function(eyeVertex,horizon){this.newFaces=[];for(var firstSideEdge=null,previousSideEdge=null,i=0;i<horizon.length;i++){var horizonEdge=horizon[i],sideEdge=this.addAdjoiningFace(eyeVertex,horizonEdge);null===firstSideEdge?firstSideEdge=sideEdge:sideEdge.next.setTwin(previousSideEdge),this.newFaces.push(sideEdge.face),previousSideEdge=sideEdge}return firstSideEdge.next.setTwin(previousSideEdge),this},addVertexToHull:function(eyeVertex){var horizon=[];return this.unassigned.clear(),this.removeVertexFromFace(eyeVertex,eyeVertex.face),this.computeHorizon(eyeVertex.point,null,eyeVertex.face,horizon),this.addNewFaces(eyeVertex,horizon),this.resolveUnassignedPoints(this.newFaces),this},cleanup:function(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this},compute:function(){var vertex;for(this.computeInitialHull();void 0!==(vertex=this.nextVertexToAdd());)this.addVertexToHull(vertex);return this.reindexFaces(),this.cleanup(),this}}),Object.assign(Face,{create:function(a,b,c){var face=new Face,e0=new HalfEdge(a,face),e1=new HalfEdge(b,face),e2=new HalfEdge(c,face);return e0.next=e2.prev=e1,e1.next=e0.prev=e2,e2.next=e1.prev=e0,face.edge=e0,face.compute()}}),Object.assign(Face.prototype,{getEdge:function(i){for(var edge=this.edge;i>0;)edge=edge.next,i--;for(;i<0;)edge=edge.prev,i++;return edge},compute:function(){void 0===triangle&&(triangle=new _three.Triangle);var a=this.edge.tail(),b=this.edge.head(),c=this.edge.next.head();return triangle.set(a.point,b.point,c.point),triangle.getNormal(this.normal),triangle.getMidpoint(this.midpoint),this.area=triangle.getArea(),this.constant=this.normal.dot(this.midpoint),this},distanceToPoint:function(point){return this.normal.dot(point)-this.constant}}),Object.assign(HalfEdge.prototype,{head:function(){return this.vertex},tail:function(){return this.prev?this.prev.vertex:null},length:function(){var head=this.head(),tail=this.tail();return null!==tail?tail.point.distanceTo(head.point):-1},lengthSquared:function(){var head=this.head(),tail=this.tail();return null!==tail?tail.point.distanceToSquared(head.point):-1},setTwin:function(edge){return this.twin=edge,edge.twin=this,this}}),Object.assign(VertexList.prototype,{first:function(){return this.head},last:function(){return this.tail},clear:function(){return this.head=this.tail=null,this},insertBefore:function(target,vertex){return vertex.prev=target.prev,vertex.next=target,null===vertex.prev?this.head=vertex:vertex.prev.next=vertex,target.prev=vertex,this},insertAfter:function(target,vertex){return vertex.prev=target,vertex.next=target.next,null===vertex.next?this.tail=vertex:vertex.next.prev=vertex,target.next=vertex,this},append:function(vertex){return null===this.head?this.head=vertex:this.tail.next=vertex,vertex.prev=this.tail,vertex.next=null,this.tail=vertex,this},appendChain:function(vertex){for(null===this.head?this.head=vertex:this.tail.next=vertex,vertex.prev=this.tail;null!==vertex.next;)vertex=vertex.next;return this.tail=vertex,this},remove:function(vertex){return null===vertex.prev?this.head=vertex.next:vertex.prev.next=vertex.next,null===vertex.next?this.tail=vertex.prev:vertex.next.prev=vertex.prev,this},removeSubList:function(a,b){return null===a.prev?this.head=b.next:a.prev.next=b.next,null===b.next?this.tail=a.prev:b.next.prev=a.prev,this},isEmpty:function(){return null===this.head}}),ConvexHull}();const _v1=new _three.Vector3,_v2=new _three.Vector3,_q1=new _three.Quaternion;function getGeometry(object){const meshes=function(object){const meshes=[];return object.traverse(function(o){o.isMesh&&meshes.push(o)}),meshes}(object);if(0===meshes.length)return null;if(1===meshes.length)return normalizeGeometry(meshes[0]);let mesh;const geometries=[];for(;mesh=meshes.pop();)geometries.push(simplifyGeometry(normalizeGeometry(mesh)));return function(geometries){let vertexCount=0;for(let i=0;i<geometries.length;i++){const position=geometries[i].attributes.position;position&&3===position.itemSize&&(vertexCount+=position.count)}const positionArray=new Float32Array(3*vertexCount);let positionOffset=0;for(let i=0;i<geometries.length;i++){const position=geometries[i].attributes.position;if(position&&3===position.itemSize)for(let j=0;j<position.count;j++)positionArray[positionOffset++]=position.getX(j),positionArray[positionOffset++]=position.getY(j),positionArray[positionOffset++]=position.getZ(j)}return(new _three.BufferGeometry).setAttribute("position",new _three.BufferAttribute(positionArray,3))}(geometries)}function normalizeGeometry(mesh){let geometry=mesh.geometry;return geometry=geometry.toBufferGeometry?geometry.toBufferGeometry():geometry.clone(),mesh.updateMatrixWorld(),mesh.matrixWorld.decompose(_v1,_q1,_v2),geometry.scale(_v2.x,_v2.y,_v2.z),geometry}function getVertices(geometry){const position=geometry.attributes.position,vertices=new Float32Array(3*position.count);for(let i=0;i<position.count;i++)vertices[3*i]=position.getX(i),vertices[3*i+1]=position.getY(i),vertices[3*i+2]=position.getZ(i);return vertices}function getComponent(v,component){switch(component){case"x":return v.x;case"y":return v.y;case"z":return v.z}throw new Error("Unexpected component "+component)}function simplifyGeometry(geometry,tolerance=1e-4){tolerance=Math.max(tolerance,Number.EPSILON);const hashToIndex={},indices=geometry.getIndex(),positions=geometry.getAttribute("position"),vertexCount=indices?indices.count:positions.count;let nextIndex=0;const newIndices=[],newPositions=[],decimalShift=Math.log10(1/tolerance),shiftMultiplier=Math.pow(10,decimalShift);for(let i=0;i<vertexCount;i++){const index=indices?indices.getX(i):i;let hash="";hash+=~~(positions.getX(index)*shiftMultiplier)+",",hash+=~~(positions.getY(index)*shiftMultiplier)+",",(hash+=~~(positions.getZ(index)*shiftMultiplier)+",")in hashToIndex?newIndices.push(hashToIndex[hash]):(newPositions.push(positions.getX(index)),newPositions.push(positions.getY(index)),newPositions.push(positions.getZ(index)),hashToIndex[hash]=nextIndex,newIndices.push(nextIndex),nextIndex++)}const positionAttribute=new _three.BufferAttribute(new Float32Array(newPositions),positions.itemSize,positions.normalized),result=new _three.BufferGeometry;return result.setAttribute("position",positionAttribute),result.setIndex(newIndices),result}const PI_2=Math.PI/2;var ShapeType;!function(ShapeType){ShapeType.BOX="Box",ShapeType.CYLINDER="Cylinder",ShapeType.SPHERE="Sphere",ShapeType.HULL="ConvexPolyhedron",ShapeType.MESH="Trimesh"}(ShapeType||(exports.ShapeType=ShapeType={}));const getShapeParameters=function(object,options={}){let geometry;if(options.type===ShapeType.BOX)return getBoundingBoxParameters(object);if(options.type===ShapeType.CYLINDER)return function(object,options){const axes=["x","y","z"],majorAxis=options.cylinderAxis||"y",minorAxes=axes.splice(axes.indexOf(majorAxis),1)&&axes,box=(new _three.Box3).setFromObject(object);if(!isFinite(box.min.lengthSq()))return null;const height=box.max[majorAxis]-box.min[majorAxis],radius=.5*Math.max(getComponent(box.max,minorAxes[0])-getComponent(box.min,minorAxes[0]),getComponent(box.max,minorAxes[1])-getComponent(box.min,minorAxes[1])),eulerX="y"===majorAxis?PI_2:0,eulerY="z"===majorAxis?PI_2:0;return{type:ShapeType.CYLINDER,params:{radiusTop:radius,radiusBottom:radius,height:height,segments:12},orientation:(new _cannonEs.Quaternion).setFromEuler(eulerX,eulerY,0,"XYZ").normalize()}}(object,options);if(options.type===ShapeType.SPHERE)return function(object,options){if(options.sphereRadius)return{type:ShapeType.SPHERE,params:{radius:options.sphereRadius}};const geometry=getGeometry(object);return geometry?(geometry.computeBoundingSphere(),{type:ShapeType.SPHERE,params:{radius:geometry.boundingSphere.radius}}):null}(object,options);if(options.type===ShapeType.HULL)return function(object){const geometry=getGeometry(object);if(!geometry)return null;for(let i=0;i<geometry.attributes.position.count;i++)geometry.attributes.position.setXYZ(i,geometry.attributes.position.getX(i)+1e-4*(Math.random()-.5),geometry.attributes.position.getY(i)+1e-4*(Math.random()-.5),geometry.attributes.position.getZ(i)+1e-4*(Math.random()-.5));const hullFaces=(new ConvexHull).setFromObject(new _three.Mesh(geometry)).faces,vertices=[],faces=[];let currentFaceVertex=0;for(let i=0;i<hullFaces.length;i++){const hullFace=hullFaces[i],face=[];faces.push(face);let edge=hullFace.edge;do{const point=edge.head().point;vertices.push(point.x,point.y,point.z),face.push(currentFaceVertex),currentFaceVertex++,edge=edge.next}while(edge!==hullFace.edge)}const verticesTypedArray=new Float32Array(vertices.length);return verticesTypedArray.set(vertices),{type:ShapeType.HULL,params:{vertices:verticesTypedArray,faces:faces}}}(object);if(options.type===ShapeType.MESH)return(geometry=getGeometry(object))?function(geometry){const vertices=getVertices(geometry);if(!vertices.length)return null;const indices=new Uint32Array(vertices.length);for(let i=0;i<vertices.length;i++)indices[i]=i;return{type:ShapeType.MESH,params:{vertices:vertices,indices:indices}}}(geometry):null;if(options.type)throw new Error('[CANNON.getShapeParameters] Invalid type "'+options.type+'".');if(!(geometry=getGeometry(object)))return null;switch(geometry.type){case"BoxGeometry":case"BoxBufferGeometry":return getBoxParameters(geometry);case"CylinderGeometry":case"CylinderBufferGeometry":return function(geometry){const params=geometry.parameters;return{type:ShapeType.CYLINDER,params:{radiusTop:params.radiusTop,radiusBottom:params.radiusBottom,height:params.height,segments:params.radialSegments},orientation:(new _cannonEs.Quaternion).setFromEuler(_three.MathUtils.degToRad(-90),0,0,"XYZ").normalize()}}(geometry);case"PlaneGeometry":case"PlaneBufferGeometry":return function(geometry){geometry.computeBoundingBox();const box=geometry.boundingBox;return{type:ShapeType.BOX,params:{x:(box.max.x-box.min.x)/2||.1,y:(box.max.y-box.min.y)/2||.1,z:(box.max.z-box.min.z)/2||.1}}}(geometry);case"SphereGeometry":case"SphereBufferGeometry":return function(geometry){return{type:ShapeType.SPHERE,params:{radius:geometry.parameters.radius}}}(geometry);case"TubeGeometry":case"BufferGeometry":return getBoundingBoxParameters(object);default:return console.warn('Unrecognized geometry: "%s". Using bounding box as shape.',geometry.type),getBoxParameters(geometry)}};exports.getShapeParameters=getShapeParameters;function getBoxParameters(geometry){if(!getVertices(geometry).length)return null;geometry.computeBoundingBox();const box=geometry.boundingBox;return{type:ShapeType.BOX,params:{x:(box.max.x-box.min.x)/2,y:(box.max.y-box.min.y)/2,z:(box.max.z-box.min.z)/2}}}function getBoundingBoxParameters(object){const clone=object.clone();clone.quaternion.set(0,0,0,1),clone.updateMatrixWorld();const box=(new _three.Box3).setFromObject(clone);if(!isFinite(box.min.lengthSq()))return null;const localPosition=box.translate(clone.position.negate()).getCenter(new _three.Vector3);return{type:ShapeType.BOX,params:{x:(box.max.x-box.min.x)/2,y:(box.max.y-box.min.y)/2,z:(box.max.z-box.min.z)/2},offset:localPosition.lengthSq()?new _cannonEs.Vec3(localPosition.x,localPosition.y,localPosition.z):void 0}}exports.threeToCannon=function(object,options={}){const shapeParameters=getShapeParameters(object,options);if(!shapeParameters)return null;const{type:type,params:params,offset:offset,orientation:orientation}=shapeParameters;let shape;return{shape:shape=type===ShapeType.BOX?function(params){const{x:x,y:y,z:z}=params;return new _cannonEs.Box(new _cannonEs.Vec3(x,y,z))}(params):type===ShapeType.CYLINDER?function(params){const{radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,segments:segments}=params,shape=new _cannonEs.Cylinder(radiusTop,radiusBottom,height,segments);return shape.radiusTop=radiusBottom,shape.radiusBottom=radiusBottom,shape.height=height,shape.numSegments=segments,shape}(params):type===ShapeType.SPHERE?function(params){return new _cannonEs.Sphere(params.radius)}(params):type===ShapeType.HULL?function(params){const{faces:faces,vertices:verticesArray}=params,vertices=[];for(let i=0;i<verticesArray.length;i+=3)vertices.push(new _cannonEs.Vec3(verticesArray[i],verticesArray[i+1],verticesArray[i+2]));return new _cannonEs.ConvexPolyhedron({faces:faces,vertices:vertices})}(params):function(params){const{vertices:vertices,indices:indices}=params;return new _cannonEs.Trimesh(vertices,indices)}(params),offset:offset,orientation:orientation}}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"cannon-es":5}],8:[function(require,module,exports){"use strict";var bundleFn=arguments[3],sources=arguments[4],cache=arguments[5],stringify=JSON.stringify;module.exports=function(fn,options){for(var wkey,cacheKeys=Object.keys(cache),i=0,l=cacheKeys.length;i<l;i++){var key=cacheKeys[i],exp=cache[key].exports;if(exp===fn||exp&&exp.default===fn){wkey=key;break}}if(!wkey){wkey=Math.floor(Math.pow(16,8)*Math.random()).toString(16);var wcache={};for(i=0,l=cacheKeys.length;i<l;i++){wcache[key=cacheKeys[i]]=key}sources[wkey]=[Function(["require","module","exports"],"("+fn+")(self)"),wcache]}var skey=Math.floor(Math.pow(16,8)*Math.random()).toString(16),scache={};scache[wkey]=wkey,sources[skey]=[Function(["require"],"var f = require("+stringify(wkey)+");(f.default ? f.default : f)(self);"),scache];var workerSources={};!function resolveSources(key){workerSources[key]=!0;for(var depPath in sources[key][1]){var depKey=sources[key][1][depPath];workerSources[depKey]||resolveSources(depKey)}}(skey);var src="("+bundleFn+")({"+Object.keys(workerSources).map(function(key){return stringify(key)+":["+sources[key][0]+","+stringify(sources[key][1])+"]"}).join(",")+"},{},["+stringify(skey)+"])",URL=window.URL||window.webkitURL||window.mozURL||window.msURL,blob=new Blob([src],{type:"text/javascript"});if(options&&options.bare)return blob;var workerUrl=URL.createObjectURL(blob),worker=new Worker(workerUrl);return worker.objectURL=workerUrl,worker}},{}],9:[function(require,module,exports){const CONSTRAINT=require("../constants").CONSTRAINT;module.exports=AFRAME.registerComponent("ammo-constraint",{multiple:!0,schema:{type:{default:CONSTRAINT.LOCK,oneOf:[CONSTRAINT.LOCK,CONSTRAINT.FIXED,CONSTRAINT.SPRING,CONSTRAINT.SLIDER,CONSTRAINT.HINGE,CONSTRAINT.CONE_TWIST,CONSTRAINT.POINT_TO_POINT]},target:{type:"selector"},pivot:{type:"vec3"},targetPivot:{type:"vec3"},axis:{type:"vec3",default:{x:0,y:0,z:1}},targetAxis:{type:"vec3",default:{x:0,y:0,z:1}},damping:{type:"number",default:1},stiffness:{type:"number",default:100}},init:function(){this.system=this.el.sceneEl.systems.physics,this.constraint=null},remove:function(){this.constraint&&(this.system.removeConstraint(this.constraint),this.constraint=null)},update:function(){const el=this.el,data=this.data;this.remove(),el.body&&data.target.body?(this.constraint=this.createConstraint(),this.system.addConstraint(this.constraint)):(el.body?data.target:el).addEventListener("body-loaded",this.update.bind(this,{}),{once:!0})},createConstraint:function(){let constraint;const data=this.data,body=this.el.body,targetBody=data.target.body,bodyTransform=body.getCenterOfMassTransform().inverse().op_mul(targetBody.getWorldTransform()),targetTransform=new Ammo.btTransform;switch(targetTransform.setIdentity(),data.type){case CONSTRAINT.LOCK:{constraint=new Ammo.btGeneric6DofConstraint(body,targetBody,bodyTransform,targetTransform,!0);const zero=new Ammo.btVector3(0,0,0);constraint.setLinearLowerLimit(zero),constraint.setLinearUpperLimit(zero),constraint.setAngularLowerLimit(zero),constraint.setAngularUpperLimit(zero),Ammo.destroy(zero);break}case CONSTRAINT.FIXED:bodyTransform.setRotation(body.getWorldTransform().getRotation()),targetTransform.setRotation(targetBody.getWorldTransform().getRotation()),constraint=new Ammo.btFixedConstraint(body,targetBody,bodyTransform,targetTransform);break;case CONSTRAINT.SPRING:{for(var i in constraint=new Ammo.btGeneric6DofSpringConstraint(body,targetBody,bodyTransform,targetTransform,!0),[0,1,2,3,4,5])constraint.enableSpring(1,!0),constraint.setStiffness(1,this.data.stiffness),constraint.setDamping(1,this.data.damping);const upper=new Ammo.btVector3(-1,-1,-1),lower=new Ammo.btVector3(1,1,1);constraint.setLinearUpperLimit(upper),constraint.setLinearLowerLimit(lower),Ammo.destroy(upper),Ammo.destroy(lower);break}case CONSTRAINT.SLIDER:(constraint=new Ammo.btSliderConstraint(body,targetBody,bodyTransform,targetTransform,!0)).setLowerLinLimit(-1),constraint.setUpperLinLimit(1);break;case CONSTRAINT.HINGE:{const pivot=new Ammo.btVector3(data.pivot.x,data.pivot.y,data.pivot.z),targetPivot=new Ammo.btVector3(data.targetPivot.x,data.targetPivot.y,data.targetPivot.z),axis=new Ammo.btVector3(data.axis.x,data.axis.y,data.axis.z),targetAxis=new Ammo.btVector3(data.targetAxis.x,data.targetAxis.y,data.targetAxis.z);constraint=new Ammo.btHingeConstraint(body,targetBody,pivot,targetPivot,axis,targetAxis,!0),Ammo.destroy(pivot),Ammo.destroy(targetPivot),Ammo.destroy(axis),Ammo.destroy(targetAxis);break}case CONSTRAINT.CONE_TWIST:{const pivotTransform=new Ammo.btTransform;pivotTransform.setIdentity(),pivotTransform.getOrigin().setValue(data.pivot.x,data.pivot.y,data.pivot.z);const targetPivotTransform=new Ammo.btTransform;targetPivotTransform.setIdentity(),targetPivotTransform.getOrigin().setValue(data.targetPivot.x,data.targetPivot.y,data.targetPivot.z),constraint=new Ammo.btConeTwistConstraint(body,targetBody,pivotTransform,targetPivotTransform),Ammo.destroy(pivotTransform),Ammo.destroy(targetPivotTransform);break}case CONSTRAINT.POINT_TO_POINT:{const pivot=new Ammo.btVector3(data.pivot.x,data.pivot.y,data.pivot.z),targetPivot=new Ammo.btVector3(data.targetPivot.x,data.targetPivot.y,data.targetPivot.z);constraint=new Ammo.btPoint2PointConstraint(body,targetBody,pivot,targetPivot),Ammo.destroy(pivot),Ammo.destroy(targetPivot);break}default:throw new Error("[constraint] Unexpected type: "+data.type)}return Ammo.destroy(targetTransform),constraint}})},{"../constants":20}],10:[function(require,module,exports){require("ammo-debug-drawer");const threeToAmmo=require("three-to-ammo"),CONSTANTS=require("../../constants"),ACTIVATION_STATE=CONSTANTS.ACTIVATION_STATE,COLLISION_FLAG=CONSTANTS.COLLISION_FLAG,SHAPE=CONSTANTS.SHAPE,TYPE=CONSTANTS.TYPE,ACTIVATION_STATES=(CONSTANTS.FIT,[ACTIVATION_STATE.ACTIVE_TAG,ACTIVATION_STATE.ISLAND_SLEEPING,ACTIVATION_STATE.WANTS_DEACTIVATION,ACTIVATION_STATE.DISABLE_DEACTIVATION,ACTIVATION_STATE.DISABLE_SIMULATION]),RIGID_BODY_FLAGS_NONE=0,RIGID_BODY_FLAGS_DISABLE_WORLD_GRAVITY=1;function almostEqualsVector3(epsilon,u,v){return Math.abs(u.x-v.x)<epsilon&&Math.abs(u.y-v.y)<epsilon&&Math.abs(u.z-v.z)<epsilon}let AmmoBody={schema:{loadedEvent:{default:""},mass:{default:1},gravity:{type:"vec3",default:null},linearDamping:{default:.01},angularDamping:{default:.01},linearSleepingThreshold:{default:1.6},angularSleepingThreshold:{default:2.5},angularFactor:{type:"vec3",default:{x:1,y:1,z:1}},activationState:{default:ACTIVATION_STATE.ACTIVE_TAG,oneOf:ACTIVATION_STATES},type:{default:"dynamic",oneOf:[TYPE.STATIC,TYPE.DYNAMIC,TYPE.KINEMATIC]},emitCollisionEvents:{default:!1},disableCollision:{default:!1},collisionFilterGroup:{default:1},collisionFilterMask:{default:1},scaleAutoUpdate:{default:!0},restitution:{default:0}},init:function(){this.system=this.el.sceneEl.systems.physics,this.shapeComponents=[],""===this.data.loadedEvent?this.loadedEventFired=!0:this.el.addEventListener(this.data.loadedEvent,()=>{this.loadedEventFired=!0},{once:!0}),this.system.initialized&&this.loadedEventFired&&this.initBody()},initBody:function(){const pos=new THREE.Vector3,quat=new THREE.Quaternion;new THREE.Box3;return function(){const el=this.el,data=this.data;this.localScaling=new Ammo.btVector3;const obj=this.el.object3D;obj.getWorldPosition(pos),obj.getWorldQuaternion(quat),this.prevScale=new THREE.Vector3(1,1,1),this.prevNumChildShapes=0,this.msTransform=new Ammo.btTransform,this.msTransform.setIdentity(),this.rotation=new Ammo.btQuaternion(quat.x,quat.y,quat.z,quat.w),this.msTransform.getOrigin().setValue(pos.x,pos.y,pos.z),this.msTransform.setRotation(this.rotation),this.motionState=new Ammo.btDefaultMotionState(this.msTransform),this.localInertia=new Ammo.btVector3(0,0,0),this.compoundShape=new Ammo.btCompoundShape(!0),this.rbInfo=new Ammo.btRigidBodyConstructionInfo(data.mass,this.motionState,this.compoundShape,this.localInertia),this.rbInfo.m_restitution=((num,min,max)=>Math.min(Math.max(num,min),max))(this.data.restitution,0,1),this.body=new Ammo.btRigidBody(this.rbInfo),this.body.setActivationState(ACTIVATION_STATES.indexOf(data.activationState)+1),this.body.setSleepingThresholds(data.linearSleepingThreshold,data.angularSleepingThreshold),this.body.setDamping(data.linearDamping,data.angularDamping);const angularFactor=new Ammo.btVector3(data.angularFactor.x,data.angularFactor.y,data.angularFactor.z);this.body.setAngularFactor(angularFactor),Ammo.destroy(angularFactor),this._updateBodyGravity(data.gravity),this.updateCollisionFlags(),this.el.body=this.body,this.body.el=el,this.isLoaded=!0,this.el.emit("body-loaded",{body:this.el.body}),this._addToSystem()}}(),tick:function(){this.system.initialized&&!this.isLoaded&&this.loadedEventFired&&this.initBody()},_updateBodyGravity(gravity){if(void 0!==gravity.x&&void 0!==gravity.y&&void 0!==gravity.z){const gravityBtVec=new Ammo.btVector3(gravity.x,gravity.y,gravity.z);epsilon=.001,u=gravityBtVec,v=this.system.driver.physicsWorld.getGravity(),Math.abs(u.x()-v.x())<epsilon&&Math.abs(u.y()-v.y())<epsilon&&Math.abs(u.z()-v.z())<epsilon?this.body.setFlags(RIGID_BODY_FLAGS_NONE):this.body.setFlags(RIGID_BODY_FLAGS_DISABLE_WORLD_GRAVITY),this.body.setGravity(gravityBtVec),Ammo.destroy(gravityBtVec)}else this.body.setFlags(RIGID_BODY_FLAGS_NONE);var epsilon,u,v},_updateShapes:function(){const needsPolyhedralInitialization=[SHAPE.HULL,SHAPE.HACD,SHAPE.VHACD];return function(){let updated=!1;const obj=this.el.object3D;if(this.data.scaleAutoUpdate&&this.prevScale&&!almostEqualsVector3(.001,obj.scale,this.prevScale)&&(this.prevScale.copy(obj.scale),updated=!0,this.localScaling.setValue(this.prevScale.x,this.prevScale.y,this.prevScale.z),this.compoundShape.setLocalScaling(this.localScaling)),this.shapeComponentsChanged){this.shapeComponentsChanged=!1,updated=!0;for(let i=0;i<this.shapeComponents.length;i++){const shapeComponent=this.shapeComponents[i];0===shapeComponent.getShapes().length&&this._createCollisionShape(shapeComponent);const collisionShapes=shapeComponent.getShapes();for(let j=0;j<collisionShapes.length;j++){const collisionShape=collisionShapes[j];collisionShape.added||(this.compoundShape.addChildShape(collisionShape.localTransform,collisionShape),collisionShape.added=!0)}}this.data.type===TYPE.DYNAMIC&&this.updateMass(),this.system.driver.updateBody(this.body)}if(this.system.debug&&(updated||!this.polyHedralFeaturesInitialized)){for(let i=0;i<this.shapeComponents.length;i++){const collisionShapes=this.shapeComponents[i].getShapes();for(let j=0;j<collisionShapes.length;j++){const collisionShape=collisionShapes[j];-1!==needsPolyhedralInitialization.indexOf(collisionShape.type)&&collisionShape.initializePolyhedralFeatures(0)}}this.polyHedralFeaturesInitialized=!0}}}(),_createCollisionShape:function(shapeComponent){const data=shapeComponent.data,vertices=[],matrices=[],indexes=[],root=shapeComponent.el.object3D,matrixWorld=root.matrixWorld;threeToAmmo.iterateGeometries(root,data,(vertexArray,matrixArray,indexArray)=>{vertices.push(vertexArray),matrices.push(matrixArray),indexes.push(indexArray)});const collisionShapes=threeToAmmo.createCollisionShapes(vertices,matrices,indexes,matrixWorld.elements,data);shapeComponent.addShapes(collisionShapes)},play:function(){this.isLoaded&&this._addToSystem()},_addToSystem:function(){this.addedToSystem||(this.system.addBody(this.body,this.data.collisionFilterGroup,this.data.collisionFilterMask),this.data.emitCollisionEvents&&this.system.driver.addEventListener(this.body),this.system.addComponent(this),this.addedToSystem=!0)},pause:function(){this.addedToSystem&&(this.system.removeComponent(this),this.system.removeBody(this.body),this.addedToSystem=!1)},update:function(prevData){if(this.isLoaded){if(!this.hasUpdated)return void(this.hasUpdated=!0);const data=this.data;if(prevData.type===data.type&&prevData.disableCollision===data.disableCollision||this.updateCollisionFlags(),prevData.activationState!==data.activationState&&(this.body.forceActivationState(ACTIVATION_STATES.indexOf(data.activationState)+1),data.activationState===ACTIVATION_STATE.ACTIVE_TAG&&this.body.activate(!0)),prevData.collisionFilterGroup!==data.collisionFilterGroup||prevData.collisionFilterMask!==data.collisionFilterMask){const broadphaseProxy=this.body.getBroadphaseProxy();broadphaseProxy.set_m_collisionFilterGroup(data.collisionFilterGroup),broadphaseProxy.set_m_collisionFilterMask(data.collisionFilterMask),this.system.driver.broadphase.getOverlappingPairCache().removeOverlappingPairsContainingProxy(broadphaseProxy,this.system.driver.dispatcher)}if(prevData.linearDamping==data.linearDamping&&prevData.angularDamping==data.angularDamping||this.body.setDamping(data.linearDamping,data.angularDamping),almostEqualsVector3(.001,prevData.gravity,data.gravity)||this._updateBodyGravity(data.gravity),prevData.linearSleepingThreshold==data.linearSleepingThreshold&&prevData.angularSleepingThreshold==data.angularSleepingThreshold||this.body.setSleepingThresholds(data.linearSleepingThreshold,data.angularSleepingThreshold),!almostEqualsVector3(.001,prevData.angularFactor,data.angularFactor)){const angularFactor=new Ammo.btVector3(data.angularFactor.x,data.angularFactor.y,data.angularFactor.z);this.body.setAngularFactor(angularFactor),Ammo.destroy(angularFactor)}prevData.restitution!=data.restitution&&console.warn("ammo-body restitution cannot be updated from its initial value.")}},remove:function(){this.triMesh&&Ammo.destroy(this.triMesh),this.localScaling&&Ammo.destroy(this.localScaling),this.compoundShape&&Ammo.destroy(this.compoundShape),this.body&&(Ammo.destroy(this.body),delete this.body),Ammo.destroy(this.rbInfo),Ammo.destroy(this.msTransform),Ammo.destroy(this.motionState),Ammo.destroy(this.localInertia),Ammo.destroy(this.rotation)},beforeStep:function(){this._updateShapes(),this.data.type===TYPE.KINEMATIC&&this.syncToPhysics()},step:function(){this.data.type===TYPE.DYNAMIC&&this.syncFromPhysics()},syncToPhysics:function(){const q=new THREE.Quaternion,v=new THREE.Vector3,q2=new THREE.Vector3,v2=new THREE.Vector3;return function(){const el=this.el,parentEl=el.parentEl;if(!this.body)return;this.motionState.getWorldTransform(this.msTransform),parentEl.isScene?(v.copy(el.object3D.position),q.copy(el.object3D.quaternion)):(el.object3D.getWorldPosition(v),el.object3D.getWorldQuaternion(q));const position=this.msTransform.getOrigin();v2.set(position.x(),position.y(),position.z());const quaternion=this.msTransform.getRotation();q2.set(quaternion.x(),quaternion.y(),quaternion.z(),quaternion.w()),almostEqualsVector3(.001,v,v2)&&function(epsilon,u,v){return Math.abs(u.x-v.x)<epsilon&&Math.abs(u.y-v.y)<epsilon&&Math.abs(u.z-v.z)<epsilon&&Math.abs(u.w-v.w)<epsilon||Math.abs(u.x+v.x)<epsilon&&Math.abs(u.y+v.y)<epsilon&&Math.abs(u.z+v.z)<epsilon&&Math.abs(u.w+v.w)<epsilon}(.001,q,q2)||(this.body.isActive()||this.body.activate(!0),this.msTransform.getOrigin().setValue(v.x,v.y,v.z),this.rotation.setValue(q.x,q.y,q.z,q.w),this.msTransform.setRotation(this.rotation),this.motionState.setWorldTransform(this.msTransform),this.data.type!==TYPE.KINEMATIC&&this.body.setCenterOfMassTransform(this.msTransform))}}(),syncFromPhysics:function(){const v=new THREE.Vector3,q1=new THREE.Quaternion,q2=new THREE.Quaternion;return function(){this.motionState.getWorldTransform(this.msTransform);const position=this.msTransform.getOrigin(),quaternion=this.msTransform.getRotation(),el=this.el,body=this.body,parentEl=el.object3D.parent.el?el.object3D.parent.el:el.parentEl;body&&parentEl&&(parentEl.isScene?(el.object3D.position.set(position.x(),position.y(),position.z()),el.object3D.quaternion.set(quaternion.x(),quaternion.y(),quaternion.z(),quaternion.w())):(q1.set(quaternion.x(),quaternion.y(),quaternion.z(),quaternion.w()),parentEl.object3D.getWorldQuaternion(q2),q1.multiply(q2.invert()),el.object3D.quaternion.copy(q1),v.set(position.x(),position.y(),position.z()),parentEl.object3D.worldToLocal(v),el.object3D.position.copy(v)))}}(),addShapeComponent:function(shapeComponent){shapeComponent.data.type!==SHAPE.MESH||this.data.type===TYPE.STATIC?(this.shapeComponents.push(shapeComponent),this.shapeComponentsChanged=!0):console.warn("non-static mesh colliders not supported")},removeShapeComponent:function(shapeComponent){const index=this.shapeComponents.indexOf(shapeComponent);if(this.compoundShape&&-1!==index&&this.body){const shapes=shapeComponent.getShapes();for(var i=0;i<shapes.length;i++)this.compoundShape.removeChildShape(shapes[i]);this.shapeComponentsChanged=!0,this.shapeComponents.splice(index,1)}},updateMass:function(){const shape=this.body.getCollisionShape(),mass=this.data.type===TYPE.DYNAMIC?this.data.mass:0;shape.calculateLocalInertia(mass,this.localInertia),this.body.setMassProps(mass,this.localInertia),this.body.updateInertiaTensor()},updateCollisionFlags:function(){let flags=this.data.disableCollision?4:0;switch(this.data.type){case TYPE.STATIC:flags|=COLLISION_FLAG.STATIC_OBJECT;break;case TYPE.KINEMATIC:flags|=COLLISION_FLAG.KINEMATIC_OBJECT;break;default:this.body.applyGravity()}this.body.setCollisionFlags(flags),this.updateMass(),this.system.driver.updateBody(this.body)},getVelocity:function(){return this.body.getLinearVelocity()}};module.exports.definition=AmmoBody,module.exports.Component=AFRAME.registerComponent("ammo-body",AmmoBody)},{"../../constants":20,"ammo-debug-drawer":4,"three-to-ammo":6}],11:[function(require,module,exports){var CANNON=require("cannon-es");const{threeToCannon:threeToCannon,ShapeType:ShapeType}=require("three-to-cannon");new THREE.Quaternion;require("../../../lib/CANNON-shape2mesh");var q,v,Body={dependencies:["velocity"],schema:{mass:{default:5,if:{type:"dynamic"}},linearDamping:{default:.01,if:{type:"dynamic"}},angularDamping:{default:.01,if:{type:"dynamic"}},shape:{default:"auto",oneOf:["auto","box","cylinder","sphere","hull","mesh","none"]},cylinderAxis:{default:"y",oneOf:["x","y","z"]},sphereRadius:{default:NaN},type:{default:"dynamic",oneOf:["static","dynamic"]}},init:function(){this.system=this.el.sceneEl.systems.physics,this.el.sceneEl.hasLoaded?this.initBody():this.el.sceneEl.addEventListener("loaded",this.initBody.bind(this))},initBody:function(){var el=this.el,data=this.data,obj=this.el.object3D,pos=obj.position,quat=obj.quaternion;if(this.body=new CANNON.Body({mass:"static"===data.type?0:data.mass||0,material:this.system.getMaterial("defaultMaterial"),position:new CANNON.Vec3(pos.x,pos.y,pos.z),quaternion:new CANNON.Quaternion(quat.x,quat.y,quat.z,quat.w),linearDamping:data.linearDamping,angularDamping:data.angularDamping,type:"dynamic"===data.type?CANNON.Body.DYNAMIC:CANNON.Body.STATIC}),this.el.object3D.updateMatrixWorld(!0),"none"!==data.shape){var options="auto"===data.shape?void 0:AFRAME.utils.extend({},this.data,{type:ShapeType[data.shape.toUpperCase()]});const shapeInfo=function(object,options){return threeToCannon(object,options)}(this.el.object3D,options);let shape,offset,orientation;if(shapeInfo&&({shape:shape,offset:offset,orientation:orientation}=shapeInfo),!shape)return void el.addEventListener("object3dset",this.initBody.bind(this));this.body.addShape(shape,offset,orientation),this.system.debug&&(this.shouldUpdateWireframe=!0),this.hasShape=!0}this.el.body=this.body,this.body.el=el,this.isPlaying&&this._play(),this.hasShape&&this.el.emit("body-loaded",{body:this.el.body})},addShape:function(shape,offset,orientation){"none"===this.data.shape?shape?this.body?(this.body.addShape(shape,offset,orientation),this.system.debug&&(this.shouldUpdateWireframe=!0),this.shouldUpdateBody=!0):console.warn("shape cannot be added before body is loaded"):console.warn("shape cannot be null"):console.warn("shape can only be added if shape property is none")},tick:function(){this.shouldUpdateBody&&(this._pause(),this.hasShape=!0,this._play(),this.el.emit("body-loaded",{body:this.el.body}),this.shouldUpdateBody=!1),this.shouldUpdateWireframe&&(this.createWireframe(this.body),this.shouldUpdateWireframe=!1)},play:function(){this._play()},_play:function(){this.hasShape&&(this.syncToPhysics(),this.system.addComponent(this),this.system.addBody(this.body),this.wireframe&&this.el.sceneEl.object3D.add(this.wireframe))},pause:function(){this._pause()},_pause:function(){this.hasShape&&(this.system.removeComponent(this),this.body&&this.system.removeBody(this.body),this.wireframe&&this.el.sceneEl.object3D.remove(this.wireframe))},update:function(prevData){if(this.body){var data=this.data;void 0!=prevData.type&&data.type!=prevData.type&&(this.body.type="dynamic"===data.type?CANNON.Body.DYNAMIC:CANNON.Body.STATIC),this.body.mass=data.mass||0,"dynamic"===data.type&&(this.body.linearDamping=data.linearDamping,this.body.angularDamping=data.angularDamping),data.mass!==prevData.mass&&this.body.updateMassProperties(),this.body.updateProperties&&this.body.updateProperties()}},remove:function(){this.body&&(delete this.body.el,delete this.body),delete this.el.body,delete this.wireframe},beforeStep:function(){0===this.body.mass&&this.syncToPhysics()},step:function(){0!==this.body.mass&&this.syncFromPhysics()},createWireframe:function(body){var offset,mesh;this.wireframe&&(this.el.sceneEl.object3D.remove(this.wireframe),delete this.wireframe),this.wireframe=new THREE.Object3D,this.el.sceneEl.object3D.add(this.wireframe);for(var orientation=new THREE.Quaternion,i=0;i<this.body.shapes.length;i++){offset=this.body.shapeOffsets[i],orientation.copy(this.body.shapeOrientations[i]),mesh=CANNON.shape2mesh(this.body).children[i];var wireframe=new THREE.LineSegments(new THREE.EdgesGeometry(mesh.geometry),new THREE.LineBasicMaterial({color:16711680}));offset&&wireframe.position.copy(offset),orientation&&wireframe.quaternion.copy(orientation),this.wireframe.add(wireframe)}this.syncWireframe()},syncWireframe:function(){var offset,wireframe=this.wireframe;this.wireframe&&(wireframe.quaternion.copy(this.body.quaternion),wireframe.orientation&&wireframe.quaternion.multiply(wireframe.orientation),wireframe.position.copy(this.body.position),wireframe.offset&&(offset=wireframe.offset.clone().applyQuaternion(wireframe.quaternion),wireframe.position.add(offset)),wireframe.updateMatrix())},syncToPhysics:(q=new THREE.Quaternion,v=new THREE.Vector3,function(){var el=this.el,parentEl=el.parentEl,body=this.body;body&&(el.components.velocity&&body.velocity.copy(el.getAttribute("velocity")),parentEl.isScene?(body.quaternion.copy(el.object3D.quaternion),body.position.copy(el.object3D.position)):(el.object3D.getWorldQuaternion(q),body.quaternion.copy(q),el.object3D.getWorldPosition(v),body.position.copy(v)),this.body.updateProperties&&this.body.updateProperties(),this.wireframe&&this.syncWireframe())}),syncFromPhysics:function(){var v=new THREE.Vector3,q1=new THREE.Quaternion,q2=new THREE.Quaternion;return function(){var el=this.el,parentEl=el.parentEl,body=this.body;body&&parentEl&&(parentEl.isScene?(el.object3D.quaternion.copy(body.quaternion),el.object3D.position.copy(body.position)):(q1.copy(body.quaternion),parentEl.object3D.getWorldQuaternion(q2),q1.premultiply(q2.invert()),el.object3D.quaternion.copy(q1),v.copy(body.position),parentEl.object3D.worldToLocal(v),el.object3D.position.copy(v)),this.wireframe&&this.syncWireframe())}}()};module.exports.definition=Body,module.exports.Component=AFRAME.registerComponent("body",Body)},{"../../../lib/CANNON-shape2mesh":2,"cannon-es":5,"three-to-cannon":7}],12:[function(require,module,exports){var Body=require("./body"),DynamicBody=AFRAME.utils.extend({},Body.definition);module.exports=AFRAME.registerComponent("dynamic-body",DynamicBody)},{"./body":11}],13:[function(require,module,exports){var Body=require("./body"),StaticBody=AFRAME.utils.extend({},Body.definition);StaticBody.schema=AFRAME.utils.extend({},Body.definition.schema,{type:{default:"static",oneOf:["static","dynamic"]},mass:{default:0}}),module.exports=AFRAME.registerComponent("static-body",StaticBody)},{"./body":11}],14:[function(require,module,exports){var CANNON=require("cannon-es");module.exports=AFRAME.registerComponent("constraint",{multiple:!0,schema:{type:{default:"lock",oneOf:["coneTwist","distance","hinge","lock","pointToPoint"]},target:{type:"selector"},maxForce:{default:1e6,min:0},collideConnected:{default:!0},wakeUpBodies:{default:!0},distance:{default:0,min:0},pivot:{type:"vec3"},targetPivot:{type:"vec3"},axis:{type:"vec3",default:{x:0,y:0,z:1}},targetAxis:{type:"vec3",default:{x:0,y:0,z:1}}},init:function(){this.system=this.el.sceneEl.systems.physics,this.constraint=null},remove:function(){this.constraint&&(this.system.removeConstraint(this.constraint),this.constraint=null)},update:function(){var el=this.el,data=this.data;this.remove(),el.body&&data.target.body?(this.constraint=this.createConstraint(),this.system.addConstraint(this.constraint)):(el.body?data.target:el).addEventListener("body-loaded",this.update.bind(this,{}))},createConstraint:function(){var constraint,data=this.data,pivot=new CANNON.Vec3(data.pivot.x,data.pivot.y,data.pivot.z),targetPivot=new CANNON.Vec3(data.targetPivot.x,data.targetPivot.y,data.targetPivot.z),axis=new CANNON.Vec3(data.axis.x,data.axis.y,data.axis.z),targetAxis=new CANNON.Vec3(data.targetAxis.x,data.targetAxis.y,data.targetAxis.z);switch(data.type){case"lock":(constraint=new CANNON.LockConstraint(this.el.body,data.target.body,{maxForce:data.maxForce})).type="LockConstraint";break;case"distance":(constraint=new CANNON.DistanceConstraint(this.el.body,data.target.body,data.distance,data.maxForce)).type="DistanceConstraint";break;case"hinge":(constraint=new CANNON.HingeConstraint(this.el.body,data.target.body,{pivotA:pivot,pivotB:targetPivot,axisA:axis,axisB:targetAxis,maxForce:data.maxForce})).type="HingeConstraint";break;case"coneTwist":(constraint=new CANNON.ConeTwistConstraint(this.el.body,data.target.body,{pivotA:pivot,pivotB:targetPivot,axisA:axis,axisB:targetAxis,maxForce:data.maxForce})).type="ConeTwistConstraint";break;case"pointToPoint":(constraint=new CANNON.PointToPointConstraint(this.el.body,pivot,data.target.body,targetPivot,data.maxForce)).type="PointToPointConstraint";break;default:throw new Error("[constraint] Unexpected type: "+data.type)}return constraint.collideConnected=data.collideConnected,constraint}})},{"cannon-es":5}],15:[function(require,module,exports){module.exports={velocity:require("./velocity"),registerAll:function(AFRAME){this._registered||((AFRAME=AFRAME||window.AFRAME).components.velocity||AFRAME.registerComponent("velocity",this.velocity),this._registered=!0)}}},{"./velocity":16}],16:[function(require,module,exports){module.exports=AFRAME.registerComponent("velocity",{schema:{type:"vec3"},init:function(){this.system=this.el.sceneEl.systems.physics,this.system&&this.system.addComponent(this)},remove:function(){this.system&&this.system.removeComponent(this)},tick:function(t,dt){dt&&(this.system||this.afterStep(t,dt))},afterStep:function(t,dt){if(dt){var physics=this.el.sceneEl.systems.physics||{data:{maxInterval:1/60}},velocity=this.el.getAttribute("velocity")||{x:0,y:0,z:0},position=this.el.object3D.position||{x:0,y:0,z:0};dt=Math.min(dt,1e3*physics.data.maxInterval),this.el.object3D.position.set(position.x+velocity.x*dt/1e3,position.y+velocity.y*dt/1e3,position.z+velocity.z*dt/1e3)}}})},{}],17:[function(require,module,exports){require("three-to-ammo");const CONSTANTS=require("../../constants"),SHAPE=CONSTANTS.SHAPE,FIT=CONSTANTS.FIT;var AmmoShape={schema:{type:{default:SHAPE.HULL,oneOf:[SHAPE.BOX,SHAPE.CYLINDER,SHAPE.SPHERE,SHAPE.CAPSULE,SHAPE.CONE,SHAPE.HULL,SHAPE.HACD,SHAPE.VHACD,SHAPE.MESH,SHAPE.HEIGHTFIELD]},fit:{default:FIT.ALL,oneOf:[FIT.ALL,FIT.MANUAL]},halfExtents:{type:"vec3",default:{x:1,y:1,z:1}},minHalfExtent:{default:0},maxHalfExtent:{default:Number.POSITIVE_INFINITY},sphereRadius:{default:NaN},cylinderAxis:{default:"y",oneOf:["x","y","z"]},margin:{default:.01},offset:{type:"vec3",default:{x:0,y:0,z:0}},orientation:{type:"vec4",default:{x:0,y:0,z:0,w:1}},heightfieldData:{default:[]},heightfieldDistance:{default:1},includeInvisible:{default:!1}},multiple:!0,init:function(){if(this.data.fit!==FIT.MANUAL){if(!this.el.object3DMap.mesh){const self=this;return this.el.addEventListener("object3dset",function(e){"mesh"===e.detail.type&&self.init()}),void console.log("Cannot use FIT.ALL without object3DMap.mesh. Waiting for it to be set.")}this.mesh=this.el.object3DMap.mesh}this.system=this.el.sceneEl.systems.physics,this.collisionShapes=[];let bodyEl=this.el;for(this.body=bodyEl.components["ammo-body"]||null;!this.body&&bodyEl.parentNode!=this.el.sceneEl;)(bodyEl=bodyEl.parentNode).components["ammo-body"]&&(this.body=bodyEl.components["ammo-body"]);this.body?this.body.addShapeComponent(this):console.warn("body not found")},getMesh:function(){return this.mesh||null},addShapes:function(collisionShapes){this.collisionShapes=collisionShapes},getShapes:function(){return this.collisionShapes},remove:function(){if(this.body)for(this.body.removeShapeComponent(this);this.collisionShapes.length>0;){const collisionShape=this.collisionShapes.pop();collisionShape.destroy(),Ammo.destroy(collisionShape.localTransform)}}};module.exports.definition=AmmoShape,module.exports.Component=AFRAME.registerComponent("ammo-shape",AmmoShape)},{"../../constants":20,"three-to-ammo":6}],18:[function(require,module,exports){var CANNON=require("cannon-es"),Shape={schema:{shape:{default:"box",oneOf:["box","sphere","cylinder"]},offset:{type:"vec3",default:{x:0,y:0,z:0}},orientation:{type:"vec4",default:{x:0,y:0,z:0,w:1}},radius:{type:"number",default:1,if:{shape:["sphere"]}},halfExtents:{type:"vec3",default:{x:.5,y:.5,z:.5},if:{shape:["box"]}},radiusTop:{type:"number",default:1,if:{shape:["cylinder"]}},radiusBottom:{type:"number",default:1,if:{shape:["cylinder"]}},height:{type:"number",default:1,if:{shape:["cylinder"]}},numSegments:{type:"int",default:8,if:{shape:["cylinder"]}}},multiple:!0,init:function(){this.el.sceneEl.hasLoaded?this.initShape():this.el.sceneEl.addEventListener("loaded",this.initShape.bind(this))},initShape:function(){this.bodyEl=this.el;for(var bodyType=this._findType(this.bodyEl),data=this.data;!bodyType&&this.bodyEl.parentNode!=this.el.sceneEl;)this.bodyEl=this.bodyEl.parentNode,bodyType=this._findType(this.bodyEl);if(bodyType){var shape,offset,orientation,scale=new THREE.Vector3;switch(this.bodyEl.object3D.getWorldScale(scale),data.hasOwnProperty("offset")&&(offset=new CANNON.Vec3(data.offset.x*scale.x,data.offset.y*scale.y,data.offset.z*scale.z)),data.hasOwnProperty("orientation")&&(orientation=new CANNON.Quaternion).copy(data.orientation),data.shape){case"sphere":shape=new CANNON.Sphere(data.radius*scale.x);break;case"box":var halfExtents=new CANNON.Vec3(data.halfExtents.x*scale.x,data.halfExtents.y*scale.y,data.halfExtents.z*scale.z);shape=new CANNON.Box(halfExtents);break;case"cylinder":shape=new CANNON.Cylinder(data.radiusTop*scale.x,data.radiusBottom*scale.x,data.height*scale.y,data.numSegments);var quat=new CANNON.Quaternion;quat.setFromEuler(90*THREE.MathUtils.DEG2RAD,0,0,"XYZ").normalize(),orientation.mult(quat,orientation);break;default:return void console.warn(data.shape+" shape not supported")}this.bodyEl.body?this.bodyEl.components[bodyType].addShape(shape,offset,orientation):this.bodyEl.addEventListener("body-loaded",function(){this.bodyEl.components[bodyType].addShape(shape,offset,orientation)},{once:!0})}else console.warn("body not found")},_findType:function(el){return el.hasAttribute("body")?"body":el.hasAttribute("dynamic-body")?"dynamic-body":el.hasAttribute("static-body")?"static-body":null},remove:function(){this.bodyEl.parentNode&&console.warn("removing shape component not currently supported")}};module.exports.definition=Shape,module.exports.Component=AFRAME.registerComponent("shape",Shape)},{"cannon-es":5}],19:[function(require,module,exports){var CANNON=require("cannon-es");module.exports=AFRAME.registerComponent("spring",{multiple:!0,schema:{target:{type:"selector"},restLength:{default:1,min:0},stiffness:{default:100,min:0},damping:{default:1,min:0},localAnchorA:{type:"vec3",default:{x:0,y:0,z:0}},localAnchorB:{type:"vec3",default:{x:0,y:0,z:0}}},init:function(){this.system=this.el.sceneEl.systems.physics,this.system.addComponent(this),this.isActive=!0,this.spring=null},update:function(oldData){var el=this.el,data=this.data;data.target?el.body&&data.target.body?(this.createSpring(),this.updateSpring(oldData)):(el.body?data.target:el).addEventListener("body-loaded",this.update.bind(this,{})):console.warn("Spring: invalid target specified.")},updateSpring:function(oldData){if(this.spring){var data=this.data,spring=this.spring;Object.keys(data).forEach(function(attr){if(data[attr]!==oldData[attr]){if("target"===attr)return void(spring.bodyB=data.target.body);spring[attr]=data[attr]}})}else console.warn("Spring: Component attempted to change spring before its created. No changes made.")},createSpring:function(){this.spring||(this.spring=new CANNON.Spring(this.el.body))},step:function(t,dt){return this.spring&&this.isActive?this.spring.applyForce():void 0},play:function(){this.isActive=!0},pause:function(){this.isActive=!1},remove:function(){this.spring&&delete this.spring,this.spring=null}})},{"cannon-es":5}],20:[function(require,module,exports){module.exports={GRAVITY:-9.8,MAX_INTERVAL:4/60,ITERATIONS:10,CONTACT_MATERIAL:{friction:.01,restitution:.3,contactEquationStiffness:1e8,contactEquationRelaxation:3,frictionEquationStiffness:1e8,frictionEquationRegularization:3},ACTIVATION_STATE:{ACTIVE_TAG:"active",ISLAND_SLEEPING:"islandSleeping",WANTS_DEACTIVATION:"wantsDeactivation",DISABLE_DEACTIVATION:"disableDeactivation",DISABLE_SIMULATION:"disableSimulation"},COLLISION_FLAG:{STATIC_OBJECT:1,KINEMATIC_OBJECT:2,NO_CONTACT_RESPONSE:4,CUSTOM_MATERIAL_CALLBACK:8,CHARACTER_OBJECT:16,DISABLE_VISUALIZE_OBJECT:32,DISABLE_SPU_COLLISION_PROCESSING:64},TYPE:{STATIC:"static",DYNAMIC:"dynamic",KINEMATIC:"kinematic"},SHAPE:{BOX:"box",CYLINDER:"cylinder",SPHERE:"sphere",CAPSULE:"capsule",CONE:"cone",HULL:"hull",HACD:"hacd",VHACD:"vhacd",MESH:"mesh",HEIGHTFIELD:"heightfield"},FIT:{ALL:"all",MANUAL:"manual"},CONSTRAINT:{LOCK:"lock",FIXED:"fixed",SPRING:"spring",SLIDER:"slider",HINGE:"hinge",CONE_TWIST:"coneTwist",POINT_TO_POINT:"pointToPoint"}}},{}],21:[function(require,module,exports){const Driver=require("./driver");"undefined"!=typeof window&&(window.AmmoModule=window.Ammo,window.Ammo=null);function AmmoDriver(){this.collisionConfiguration=null,this.dispatcher=null,this.broadphase=null,this.solver=null,this.physicsWorld=null,this.debugDrawer=null,this.els=new Map,this.eventListeners=[],this.collisions=new Map,this.collisionKeys=[],this.currentCollisions=new Map}AmmoDriver.prototype=new Driver,AmmoDriver.prototype.constructor=AmmoDriver,module.exports=AmmoDriver,AmmoDriver.prototype.init=function(worldConfig){return new Promise(resolve=>{AmmoModule().then(result=>{Ammo=result,this.epsilon=worldConfig.epsilon||1e-5,this.debugDrawMode=worldConfig.debugDrawMode||THREE.AmmoDebugConstants.NoDebug,this.maxSubSteps=worldConfig.maxSubSteps||4,this.fixedTimeStep=worldConfig.fixedTimeStep||1/60,this.collisionConfiguration=new Ammo.btDefaultCollisionConfiguration,this.dispatcher=new Ammo.btCollisionDispatcher(this.collisionConfiguration),this.broadphase=new Ammo.btDbvtBroadphase,this.solver=new Ammo.btSequentialImpulseConstraintSolver,this.physicsWorld=new Ammo.btDiscreteDynamicsWorld(this.dispatcher,this.broadphase,this.solver,this.collisionConfiguration),this.physicsWorld.setForceUpdateAllAabbs(!1),this.physicsWorld.setGravity(new Ammo.btVector3(0,worldConfig.hasOwnProperty("gravity")?worldConfig.gravity:-9.8,0)),this.physicsWorld.getSolverInfo().set_m_numIterations(worldConfig.solverIterations),resolve()})})},AmmoDriver.prototype.addBody=function(body,group,mask){this.physicsWorld.addRigidBody(body,group,mask);const bodyptr=Ammo.getPointer(body);this.els.set(bodyptr,body.el),this.collisions.set(bodyptr,[]),this.collisionKeys.push(bodyptr),this.currentCollisions.set(bodyptr,new Set)},AmmoDriver.prototype.removeBody=function(body){this.physicsWorld.removeRigidBody(body),this.removeEventListener(body);const bodyptr=Ammo.getPointer(body);this.els.delete(bodyptr),this.collisions.delete(bodyptr),this.collisionKeys.splice(this.collisionKeys.indexOf(bodyptr),1),this.currentCollisions.delete(bodyptr)},AmmoDriver.prototype.updateBody=function(body){this.els.has(Ammo.getPointer(body))&&this.physicsWorld.updateSingleAabb(body)},AmmoDriver.prototype.step=function(deltaTime){this.physicsWorld.stepSimulation(deltaTime,this.maxSubSteps,this.fixedTimeStep);const numManifolds=this.dispatcher.getNumManifolds();for(let i=0;i<numManifolds;i++){const persistentManifold=this.dispatcher.getManifoldByIndexInternal(i),numContacts=persistentManifold.getNumContacts(),body0ptr=Ammo.getPointer(persistentManifold.getBody0()),body1ptr=Ammo.getPointer(persistentManifold.getBody1());let collided=!1;for(let j=0;j<numContacts;j++){if(persistentManifold.getContactPoint(j).getDistance()<=this.epsilon){collided=!0;break}}collided&&(-1===this.collisions.get(body0ptr).indexOf(body1ptr)&&(this.collisions.get(body0ptr).push(body1ptr),-1!==this.eventListeners.indexOf(body0ptr)&&this.els.get(body0ptr).emit("collidestart",{targetEl:this.els.get(body1ptr)}),-1!==this.eventListeners.indexOf(body1ptr)&&this.els.get(body1ptr).emit("collidestart",{targetEl:this.els.get(body0ptr)})),this.currentCollisions.get(body0ptr).add(body1ptr))}for(let i=0;i<this.collisionKeys.length;i++){const body0ptr=this.collisionKeys[i],body1ptrs=this.collisions.get(body0ptr);for(let j=body1ptrs.length-1;j>=0;j--){const body1ptr=body1ptrs[j];this.currentCollisions.get(body0ptr).has(body1ptr)||(-1!==this.eventListeners.indexOf(body0ptr)&&this.els.get(body0ptr).emit("collideend",{targetEl:this.els.get(body1ptr)}),-1!==this.eventListeners.indexOf(body1ptr)&&this.els.get(body1ptr).emit("collideend",{targetEl:this.els.get(body0ptr)}),body1ptrs.splice(j,1))}this.currentCollisions.get(body0ptr).clear()}this.debugDrawer&&this.debugDrawer.update()},AmmoDriver.prototype.addConstraint=function(constraint){this.physicsWorld.addConstraint(constraint,!1)},AmmoDriver.prototype.removeConstraint=function(constraint){this.physicsWorld.removeConstraint(constraint)},AmmoDriver.prototype.addEventListener=function(body){this.eventListeners.push(Ammo.getPointer(body))},AmmoDriver.prototype.removeEventListener=function(body){const ptr=Ammo.getPointer(body);-1!==this.eventListeners.indexOf(ptr)&&this.eventListeners.splice(this.eventListeners.indexOf(ptr),1)},AmmoDriver.prototype.destroy=function(){Ammo.destroy(this.collisionConfiguration),Ammo.destroy(this.dispatcher),Ammo.destroy(this.broadphase),Ammo.destroy(this.solver),Ammo.destroy(this.physicsWorld),Ammo.destroy(this.debugDrawer)},AmmoDriver.prototype.getDebugDrawer=function(scene,options){return this.debugDrawer||((options=options||{}).debugDrawMode=options.debugDrawMode||this.debugDrawMode,this.debugDrawer=new THREE.AmmoDebugDrawer(scene,this.physicsWorld,options)),this.debugDrawer}},{"./driver":22}],22:[function(require,module,exports){function Driver(){}function abstractMethod(){throw new Error("Method not implemented.")}module.exports=Driver,Driver.prototype.init=abstractMethod,Driver.prototype.step=abstractMethod,Driver.prototype.destroy=abstractMethod,Driver.prototype.addBody=abstractMethod,Driver.prototype.removeBody=abstractMethod,Driver.prototype.applyBodyMethod=abstractMethod,Driver.prototype.updateBodyProperties=abstractMethod,Driver.prototype.addMaterial=abstractMethod,Driver.prototype.addContactMaterial=abstractMethod,Driver.prototype.addConstraint=abstractMethod,Driver.prototype.removeConstraint=abstractMethod,Driver.prototype.getContacts=abstractMethod},{}],23:[function(require,module,exports){module.exports={INIT:"init",STEP:"step",ADD_BODY:"add-body",REMOVE_BODY:"remove-body",APPLY_BODY_METHOD:"apply-body-method",UPDATE_BODY_PROPERTIES:"update-body-properties",ADD_MATERIAL:"add-material",ADD_CONTACT_MATERIAL:"add-contact-material",ADD_CONSTRAINT:"add-constraint",REMOVE_CONSTRAINT:"remove-constraint",COLLIDE:"collide"}},{}],24:[function(require,module,exports){var CANNON=require("cannon-es"),Driver=require("./driver");function LocalDriver(){this.world=null,this.materials={},this.contactMaterial=null}LocalDriver.prototype=new Driver,LocalDriver.prototype.constructor=LocalDriver,module.exports=LocalDriver,LocalDriver.prototype.init=function(worldConfig){var world=new CANNON.World;world.quatNormalizeSkip=worldConfig.quatNormalizeSkip,world.quatNormalizeFast=worldConfig.quatNormalizeFast,world.solver.iterations=worldConfig.solverIterations,world.gravity.set(0,worldConfig.gravity,0),world.broadphase=new CANNON.NaiveBroadphase,this.world=world},LocalDriver.prototype.step=function(deltaMS){this.world.step(deltaMS)},LocalDriver.prototype.destroy=function(){delete this.world,delete this.contactMaterial,this.materials={}},LocalDriver.prototype.addBody=function(body){this.world.addBody(body)},LocalDriver.prototype.removeBody=function(body){this.world.removeBody(body)},LocalDriver.prototype.applyBodyMethod=function(body,methodName,args){body["__"+methodName].apply(body,args)},LocalDriver.prototype.updateBodyProperties=function(){},LocalDriver.prototype.getMaterial=function(name){return this.materials[name]},LocalDriver.prototype.addMaterial=function(materialConfig){this.materials[materialConfig.name]=new CANNON.Material(materialConfig),this.materials[materialConfig.name].name=materialConfig.name},LocalDriver.prototype.addContactMaterial=function(matName1,matName2,contactMaterialConfig){var mat1=this.materials[matName1],mat2=this.materials[matName2];this.contactMaterial=new CANNON.ContactMaterial(mat1,mat2,contactMaterialConfig),this.world.addContactMaterial(this.contactMaterial)},LocalDriver.prototype.addConstraint=function(constraint){constraint.type||(constraint instanceof CANNON.LockConstraint?constraint.type="LockConstraint":constraint instanceof CANNON.DistanceConstraint?constraint.type="DistanceConstraint":constraint instanceof CANNON.HingeConstraint?constraint.type="HingeConstraint":constraint instanceof CANNON.ConeTwistConstraint?constraint.type="ConeTwistConstraint":constraint instanceof CANNON.PointToPointConstraint&&(constraint.type="PointToPointConstraint")),this.world.addConstraint(constraint)},LocalDriver.prototype.removeConstraint=function(constraint){this.world.removeConstraint(constraint)},LocalDriver.prototype.getContacts=function(){return this.world.contacts}},{"./driver":22,"cannon-es":5}],25:[function(require,module,exports){var Driver=require("./driver");function NetworkDriver(){throw new Error("[NetworkDriver] Driver not implemented.")}NetworkDriver.prototype=new Driver,NetworkDriver.prototype.constructor=NetworkDriver,module.exports=NetworkDriver},{"./driver":22}],26:[function(require,module,exports){function EventTarget(){this.listeners=[]}module.exports=function(worker){var targetA=new EventTarget,targetB=new EventTarget;return targetA.setTarget(targetB),targetB.setTarget(targetA),worker(targetA),targetB},EventTarget.prototype.setTarget=function(target){this.target=target},EventTarget.prototype.addEventListener=function(type,fn){this.listeners.push(fn)},EventTarget.prototype.dispatchEvent=function(type,event){for(var i=0;i<this.listeners.length;i++)this.listeners[i](event)},EventTarget.prototype.postMessage=function(msg){this.target.dispatchEvent("message",{data:msg})}},{}],27:[function(require,module,exports){var webworkify=require("webworkify"),webworkifyDebug=require("./webworkify-debug"),Driver=require("./driver"),Event=require("./event"),worker=require("./worker"),protocol=require("../utils/protocol"),ID=protocol.ID;function WorkerDriver(options){this.fps=options.fps,this.engine=options.engine,this.interpolate=options.interpolate,this.interpBufferSize=options.interpolationBufferSize,this.debug=options.debug,this.bodies={},this.contacts=[],this.frameDelay=1e3*this.interpBufferSize/this.fps,this.frameBuffer=[],this.worker=this.debug?webworkifyDebug(worker):webworkify(worker),this.worker.addEventListener("message",this._onMessage.bind(this))}WorkerDriver.prototype=new Driver,WorkerDriver.prototype.constructor=WorkerDriver,module.exports=WorkerDriver,WorkerDriver.prototype.init=function(worldConfig){this.worker.postMessage({type:Event.INIT,worldConfig:worldConfig,fps:this.fps,engine:this.engine})},WorkerDriver.prototype.step=function(){if(this.interpolate){for(var prevFrame=this.frameBuffer[0],nextFrame=this.frameBuffer[1],timestamp=performance.now();prevFrame&&nextFrame&&timestamp-prevFrame.timestamp>this.frameDelay;)this.frameBuffer.shift(),prevFrame=this.frameBuffer[0],nextFrame=this.frameBuffer[1];if(prevFrame&&nextFrame){var mix=(timestamp-prevFrame.timestamp)/this.frameDelay;for(var id in mix=(mix-(1-1/this.interpBufferSize))*this.interpBufferSize,prevFrame.bodies)prevFrame.bodies.hasOwnProperty(id)&&nextFrame.bodies.hasOwnProperty(id)&&protocol.deserializeInterpBodyUpdate(prevFrame.bodies[id],nextFrame.bodies[id],this.bodies[id],mix)}}},WorkerDriver.prototype.destroy=function(){this.worker.terminate(),delete this.worker},WorkerDriver.prototype._onMessage=function(event){if(event.data.type===Event.STEP){var bodies=event.data.bodies;if(this.contacts=event.data.contacts,this.interpolate)this.frameBuffer.push({timestamp:performance.now(),bodies:bodies});else for(var id in bodies)bodies.hasOwnProperty(id)&&protocol.deserializeBodyUpdate(bodies[id],this.bodies[id])}else{if(event.data.type!==Event.COLLIDE)throw new Error("[WorkerDriver] Unexpected message type.");var body=this.bodies[event.data.bodyID],target=this.bodies[event.data.targetID],contact=protocol.deserializeContact(event.data.contact,this.bodies);if(!body._listeners||!body._listeners.collide)return;for(var i=0;i<body._listeners.collide.length;i++)body._listeners.collide[i]({target:target,body:body,contact:contact})}},WorkerDriver.prototype.addBody=function(body){protocol.assignID("body",body),this.bodies[body[ID]]=body,this.worker.postMessage({type:Event.ADD_BODY,body:protocol.serializeBody(body)})},WorkerDriver.prototype.removeBody=function(body){this.worker.postMessage({type:Event.REMOVE_BODY,bodyID:body[ID]}),delete this.bodies[body[ID]]},WorkerDriver.prototype.applyBodyMethod=function(body,methodName,args){switch(methodName){case"applyForce":case"applyImpulse":this.worker.postMessage({type:Event.APPLY_BODY_METHOD,bodyID:body[ID],methodName:methodName,args:[args[0].toArray(),args[1].toArray()]});break;default:throw new Error("Unexpected methodName: %s",methodName)}},WorkerDriver.prototype.updateBodyProperties=function(body){this.worker.postMessage({type:Event.UPDATE_BODY_PROPERTIES,body:protocol.serializeBody(body)})},WorkerDriver.prototype.getMaterial=function(name){},WorkerDriver.prototype.addMaterial=function(materialConfig){this.worker.postMessage({type:Event.ADD_MATERIAL,materialConfig:materialConfig})},WorkerDriver.prototype.addContactMaterial=function(matName1,matName2,contactMaterialConfig){this.worker.postMessage({type:Event.ADD_CONTACT_MATERIAL,materialName1:matName1,materialName2:matName2,contactMaterialConfig:contactMaterialConfig})},WorkerDriver.prototype.addConstraint=function(constraint){constraint.type||(constraint instanceof CANNON.LockConstraint?constraint.type="LockConstraint":constraint instanceof CANNON.DistanceConstraint?constraint.type="DistanceConstraint":constraint instanceof CANNON.HingeConstraint?constraint.type="HingeConstraint":constraint instanceof CANNON.ConeTwistConstraint?constraint.type="ConeTwistConstraint":constraint instanceof CANNON.PointToPointConstraint&&(constraint.type="PointToPointConstraint")),protocol.assignID("constraint",constraint),this.worker.postMessage({type:Event.ADD_CONSTRAINT,constraint:protocol.serializeConstraint(constraint)})},WorkerDriver.prototype.removeConstraint=function(constraint){this.worker.postMessage({type:Event.REMOVE_CONSTRAINT,constraintID:constraint[ID]})},WorkerDriver.prototype.getContacts=function(){var bodies=this.bodies;return this.contacts.map(function(message){return protocol.deserializeContact(message,bodies)})}},{"../utils/protocol":31,"./driver":22,"./event":23,"./webworkify-debug":26,"./worker":28,webworkify:8}],28:[function(require,module,exports){var Event=require("./event"),LocalDriver=require("./local-driver"),AmmoDriver=require("./ammo-driver"),protocol=require("../utils/protocol"),ID=protocol.ID;module.exports=function(self){var stepSize,driver=null,bodies={},constraints={};function step(){driver.step(stepSize);var bodyMessages={};Object.keys(bodies).forEach(function(id){bodyMessages[id]=protocol.serializeBody(bodies[id])}),self.postMessage({type:Event.STEP,bodies:bodyMessages,contacts:driver.getContacts().map(protocol.serializeContact)})}self.addEventListener("message",function(event){var data=event.data;switch(data.type){case Event.INIT:(driver="cannon"===data.engine?new LocalDriver:new AmmoDriver).init(data.worldConfig),stepSize=1/data.fps,setInterval(step,1e3/data.fps);break;case Event.ADD_BODY:var body=protocol.deserializeBody(data.body);body.material=driver.getMaterial("defaultMaterial"),bodies[body[ID]]=body,body.addEventListener("collide",function(evt){var message={type:Event.COLLIDE,bodyID:evt.target[ID],targetID:evt.body[ID],contact:protocol.serializeContact(evt.contact)};self.postMessage(message)}),driver.addBody(body);break;case Event.REMOVE_BODY:driver.removeBody(bodies[data.bodyID]),delete bodies[data.bodyID];break;case Event.APPLY_BODY_METHOD:bodies[data.bodyID][data.methodName](protocol.deserializeVec3(data.args[0]),protocol.deserializeVec3(data.args[1]));break;case Event.UPDATE_BODY_PROPERTIES:protocol.deserializeBodyUpdate(data.body,bodies[data.body.id]);break;case Event.ADD_MATERIAL:driver.addMaterial(data.materialConfig);break;case Event.ADD_CONTACT_MATERIAL:driver.addContactMaterial(data.materialName1,data.materialName2,data.contactMaterialConfig);break;case Event.ADD_CONSTRAINT:var constraint=protocol.deserializeConstraint(data.constraint,bodies);constraints[constraint[ID]]=constraint,driver.addConstraint(constraint);break;case Event.REMOVE_CONSTRAINT:driver.removeConstraint(constraints[data.constraintID]),delete constraints[data.constraintID];break;default:throw new Error("[Worker] Unexpected event type: %s",data.type)}})}},{"../utils/protocol":31,"./ammo-driver":21,"./event":23,"./local-driver":24}],29:[function(require,module,exports){var CANNON=require("cannon-es"),CONSTANTS=require("./constants"),C_GRAV=CONSTANTS.GRAVITY,C_MAT=CONSTANTS.CONTACT_MATERIAL;const{TYPE:TYPE}=require("./constants");var LocalDriver=require("./drivers/local-driver"),WorkerDriver=require("./drivers/worker-driver"),NetworkDriver=require("./drivers/network-driver"),AmmoDriver=require("./drivers/ammo-driver");require("aframe-stats-panel"),module.exports=AFRAME.registerSystem("physics",{schema:{driver:{default:"local",oneOf:["local","worker","network","ammo"]},networkUrl:{default:"",if:{driver:"network"}},workerFps:{default:60,if:{driver:"worker"}},workerInterpolate:{default:!0,if:{driver:"worker"}},workerInterpBufferSize:{default:2,if:{driver:"worker"}},workerEngine:{default:"cannon",if:{driver:"worker"},oneOf:["cannon"]},workerDebug:{default:!1,if:{driver:"worker"}},gravity:{default:C_GRAV},iterations:{default:CONSTANTS.ITERATIONS},friction:{default:C_MAT.friction},restitution:{default:C_MAT.restitution},contactEquationStiffness:{default:C_MAT.contactEquationStiffness},contactEquationRelaxation:{default:C_MAT.contactEquationRelaxation},frictionEquationStiffness:{default:C_MAT.frictionEquationStiffness},frictionEquationRegularization:{default:C_MAT.frictionEquationRegularization},maxInterval:{default:4/60},debug:{default:!1},debugDrawMode:{default:THREE.AmmoDebugConstants.NoDebug},maxSubSteps:{default:4},fixedTimeStep:{default:1/60},stats:{type:"array",default:[]}},async init(){var data=this.data;switch(this.debug=data.debug,this.initStats(),this.callbacks={beforeStep:[],step:[],afterStep:[]},this.listeners={},this.driver=null,data.driver){case"local":this.driver=new LocalDriver;break;case"ammo":this.driver=new AmmoDriver;break;case"network":this.driver=new NetworkDriver(data.networkUrl);break;case"worker":this.driver=new WorkerDriver({fps:data.workerFps,engine:data.workerEngine,interpolate:data.workerInterpolate,interpolationBufferSize:data.workerInterpBufferSize,debug:data.workerDebug});break;default:throw new Error('[physics] Driver not recognized: "%s".',data.driver)}"ammo"!==data.driver?(await this.driver.init({quatNormalizeSkip:0,quatNormalizeFast:!1,solverIterations:data.iterations,gravity:data.gravity}),this.driver.addMaterial({name:"defaultMaterial"}),this.driver.addMaterial({name:"staticMaterial"}),this.driver.addContactMaterial("defaultMaterial","defaultMaterial",{friction:data.friction,restitution:data.restitution,contactEquationStiffness:data.contactEquationStiffness,contactEquationRelaxation:data.contactEquationRelaxation,frictionEquationStiffness:data.frictionEquationStiffness,frictionEquationRegularization:data.frictionEquationRegularization}),this.driver.addContactMaterial("staticMaterial","defaultMaterial",{friction:1,restitution:0,contactEquationStiffness:data.contactEquationStiffness,contactEquationRelaxation:data.contactEquationRelaxation,frictionEquationStiffness:data.frictionEquationStiffness,frictionEquationRegularization:data.frictionEquationRegularization})):await this.driver.init({gravity:data.gravity,debugDrawMode:data.debugDrawMode,solverIterations:data.iterations,maxSubSteps:data.maxSubSteps,fixedTimeStep:data.fixedTimeStep}),this.initialized=!0,this.debug&&this.setDebug(!0)},initStats(){if(this.statsToConsole=this.data.stats.includes("console"),this.statsToEvents=this.data.stats.includes("events"),this.statsToPanel=this.data.stats.includes("panel"),this.statsToConsole||this.statsToEvents||this.statsToPanel){this.trackPerf=!0,this.tickCounter=0,this.statsTickData={},this.statsBodyData={},this.countBodies={ammo:()=>this.countBodiesAmmo(),local:()=>this.countBodiesCannon(!1),worker:()=>this.countBodiesCannon(!0)},this.bodyTypeToStatsPropertyMap={ammo:{[TYPE.STATIC]:"staticBodies",[TYPE.KINEMATIC]:"kinematicBodies",[TYPE.DYNAMIC]:"dynamicBodies"},cannon:{[CANNON.Body.STATIC]:"staticBodies",[CANNON.Body.DYNAMIC]:"dynamicBodies"}},this.el.sceneEl.setAttribute("stats-collector","inEvent: physics-tick-data;\n                                             properties: before, after, engine, total;\n                                             outputFrequency: 100;\n                                             outEvent: physics-tick-summary;\n                                             outputs: percentile__50, percentile__90, max")}if(this.statsToPanel){const scene=this.el.sceneEl,space="&nbsp&nbsp&nbsp";scene.setAttribute("stats-panel",""),scene.setAttribute("stats-group__bodies","label: Physics Bodies"),scene.setAttribute("stats-row__b1","group: bodies;\n                                           event:physics-body-data;\n                                           properties: staticBodies;\n                                           label: Static"),scene.setAttribute("stats-row__b2","group: bodies;\n                                           event:physics-body-data;\n                                           properties: dynamicBodies;\n                                           label: Dynamic"),"local"===this.data.driver||"worker"===this.data.driver?scene.setAttribute("stats-row__b3","group: bodies;\n                                             event:physics-body-data;\n                                             properties: contacts;\n                                             label: Contacts"):"ammo"===this.data.driver&&(scene.setAttribute("stats-row__b3","group: bodies;\n                                             event:physics-body-data;\n                                             properties: kinematicBodies;\n                                             label: Kinematic"),scene.setAttribute("stats-row__b4","group: bodies;\n                                             event: physics-body-data;\n                                             properties: manifolds;\n                                             label: Manifolds"),scene.setAttribute("stats-row__b5","group: bodies;\n                                             event: physics-body-data;\n                                             properties: manifoldContacts;\n                                             label: Contacts"),scene.setAttribute("stats-row__b6","group: bodies;\n                                             event: physics-body-data;\n                                             properties: collisions;\n                                             label: Collisions"),scene.setAttribute("stats-row__b7","group: bodies;\n                                             event: physics-body-data;\n                                             properties: collisionKeys;\n                                             label: Coll Keys")),scene.setAttribute("stats-group__tick",`label: Physics Ticks: Median${space}90th%${space}99th%`),scene.setAttribute("stats-row__1","group: tick;\n                                          event:physics-tick-summary;\n                                          properties: before.percentile__50, \n                                                      before.percentile__90, \n                                                      before.max;\n                                          label: Before"),scene.setAttribute("stats-row__2","group: tick;\n                                          event:physics-tick-summary;\n                                          properties: after.percentile__50, \n                                                      after.percentile__90, \n                                                      after.max; \n                                          label: After"),scene.setAttribute("stats-row__3","group: tick; \n                                          event:physics-tick-summary; \n                                          properties: engine.percentile__50, \n                                                      engine.percentile__90, \n                                                      engine.max;\n                                          label: Engine"),scene.setAttribute("stats-row__4","group: tick;\n                                          event:physics-tick-summary;\n                                          properties: total.percentile__50, \n                                                      total.percentile__90, \n                                                      total.max;\n                                          label: Total")}},tick:function(t,dt){if(!this.initialized||!dt)return;const beforeStartTime=performance.now();var i,callbacks=this.callbacks;for(i=0;i<this.callbacks.beforeStep.length;i++)this.callbacks.beforeStep[i].beforeStep(t,dt);const engineStartTime=performance.now();this.driver.step(Math.min(dt/1e3,this.data.maxInterval));const engineEndTime=performance.now();for(i=0;i<callbacks.step.length;i++)callbacks.step[i].step(t,dt);for(i=0;i<callbacks.afterStep.length;i++)callbacks.afterStep[i].afterStep(t,dt);if(this.trackPerf){const afterEndTime=performance.now();this.statsTickData.before=engineStartTime-beforeStartTime,this.statsTickData.engine=engineEndTime-engineStartTime,this.statsTickData.after=afterEndTime-engineEndTime,this.statsTickData.total=afterEndTime-beforeStartTime,this.el.emit("physics-tick-data",this.statsTickData),this.tickCounter++,100===this.tickCounter&&(this.countBodies[this.data.driver](),this.statsToConsole&&console.log("Physics body stats:",this.statsBodyData),(this.statsToEvents||this.statsToPanel)&&this.el.emit("physics-body-data",this.statsBodyData),this.tickCounter=0)}},countBodiesAmmo(){const statsData=this.statsBodyData;statsData.manifolds=this.driver.dispatcher.getNumManifolds(),statsData.manifoldContacts=0;for(let i=0;i<statsData.manifolds;i++){const manifold=this.driver.dispatcher.getManifoldByIndexInternal(i);statsData.manifoldContacts+=manifold.getNumContacts()}var el;statsData.collisions=this.driver.collisions.size,statsData.collisionKeys=this.driver.collisionKeys.length,statsData.staticBodies=0,statsData.kinematicBodies=0,statsData.dynamicBodies=0,this.driver.els.forEach(el=>{const property=this.bodyTypeToStatsPropertyMap.ammo[(el=el,el.components["ammo-body"].data.type)];statsData[property]++})},countBodiesCannon(worker){const statsData=this.statsBodyData;statsData.contacts=worker?this.driver.contacts.length:this.driver.world.contacts.length,statsData.staticBodies=0,statsData.dynamicBodies=0,(worker?Object.values(this.driver.bodies):this.driver.world.bodies).forEach(body=>{const property=this.bodyTypeToStatsPropertyMap.cannon[body.type];statsData[property]++})},setDebug:function(debug){this.debug=debug,"ammo"===this.data.driver&&this.initialized&&(debug&&!this.debugDrawer?(this.debugDrawer=this.driver.getDebugDrawer(this.el.object3D),this.debugDrawer.enable()):this.debugDrawer&&(this.debugDrawer.disable(),this.debugDrawer=null))},addBody:function(body,group,mask){var driver=this.driver;"local"===this.data.driver&&(body.__applyImpulse=body.applyImpulse,body.applyImpulse=function(){driver.applyBodyMethod(body,"applyImpulse",arguments)},body.__applyForce=body.applyForce,body.applyForce=function(){driver.applyBodyMethod(body,"applyForce",arguments)},body.updateProperties=function(){driver.updateBodyProperties(body)},this.listeners[body.id]=function(e){body.el.emit("collide",e)},body.addEventListener("collide",this.listeners[body.id])),this.driver.addBody(body,group,mask)},removeBody:function(body){this.driver.removeBody(body),"local"!==this.data.driver&&"worker"!==this.data.driver||(body.removeEventListener("collide",this.listeners[body.id]),delete this.listeners[body.id],body.applyImpulse=body.__applyImpulse,delete body.__applyImpulse,body.applyForce=body.__applyForce,delete body.__applyForce,delete body.updateProperties)},addConstraint:function(constraint){this.driver.addConstraint(constraint)},removeConstraint:function(constraint){this.driver.removeConstraint(constraint)},addComponent:function(component){var callbacks=this.callbacks;component.beforeStep&&callbacks.beforeStep.push(component),component.step&&callbacks.step.push(component),component.afterStep&&callbacks.afterStep.push(component)},removeComponent:function(component){var callbacks=this.callbacks;component.beforeStep&&callbacks.beforeStep.splice(callbacks.beforeStep.indexOf(component),1),component.step&&callbacks.step.splice(callbacks.step.indexOf(component),1),component.afterStep&&callbacks.afterStep.splice(callbacks.afterStep.indexOf(component),1)},getContacts:function(){return this.driver.getContacts()},getMaterial:function(name){return this.driver.getMaterial(name)}})},{"./constants":20,"./drivers/ammo-driver":21,"./drivers/local-driver":24,"./drivers/network-driver":25,"./drivers/worker-driver":27,"aframe-stats-panel":3,"cannon-es":5}],30:[function(require,module,exports){module.exports.slerp=function(a,b,t){if(t<=0)return a;if(t>=1)return b;var x=a[0],y=a[1],z=a[2],w=a[3],cosHalfTheta=w*b[3]+x*b[0]+y*b[1]+z*b[2];if(!(cosHalfTheta<0))return b;if((a=a.slice())[3]=-b[3],a[0]=-b[0],a[1]=-b[1],a[2]=-b[2],(cosHalfTheta=-cosHalfTheta)>=1)return a[3]=w,a[0]=x,a[1]=y,a[2]=z,this;var sinHalfTheta=Math.sqrt(1-cosHalfTheta*cosHalfTheta);if(Math.abs(sinHalfTheta)<.001)return a[3]=.5*(w+a[3]),a[0]=.5*(x+a[0]),a[1]=.5*(y+a[1]),a[2]=.5*(z+a[2]),this;var halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta),ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;return a[3]=w*ratioA+a[3]*ratioB,a[0]=x*ratioA+a[0]*ratioB,a[1]=y*ratioA+a[1]*ratioB,a[2]=z*ratioA+a[2]*ratioB,a}},{}],31:[function(require,module,exports){var CANNON=require("cannon-es"),mathUtils=require("./math"),ID="__id";module.exports.ID=ID;var nextID={};function serializeShape(shape){var shapeMsg={type:shape.type};if(shape.type===CANNON.Shape.types.BOX)shapeMsg.halfExtents=serializeVec3(shape.halfExtents);else if(shape.type===CANNON.Shape.types.SPHERE)shapeMsg.radius=shape.radius;else{if(shape._type!==CANNON.Shape.types.CYLINDER)throw new Error("Unimplemented shape type: %s",shape.type);shapeMsg.type=CANNON.Shape.types.CYLINDER,shapeMsg.radiusTop=shape.radiusTop,shapeMsg.radiusBottom=shape.radiusBottom,shapeMsg.height=shape.height,shapeMsg.numSegments=shape.numSegments}return shapeMsg}function deserializeShape(message){var shape;if(message.type===CANNON.Shape.types.BOX)shape=new CANNON.Box(deserializeVec3(message.halfExtents));else if(message.type===CANNON.Shape.types.SPHERE)shape=new CANNON.Sphere(message.radius);else{if(message.type!==CANNON.Shape.types.CYLINDER)throw new Error("Unimplemented shape type: %s",message.type);(shape=new CANNON.Cylinder(message.radiusTop,message.radiusBottom,message.height,message.numSegments))._type=CANNON.Shape.types.CYLINDER}return shape}function serializeVec3(vec3){return vec3.toArray()}function deserializeVec3(message){return new CANNON.Vec3(message[0],message[1],message[2])}function serializeQuaternion(quat){return quat.toArray()}function deserializeQuaternion(message){return new CANNON.Quaternion(message[0],message[1],message[2],message[3])}module.exports.assignID=function(prefix,object){object[ID]||(nextID[prefix]=nextID[prefix]||1,object[ID]=prefix+"_"+nextID[prefix]++)},module.exports.serializeBody=function(body){return{shapes:body.shapes.map(serializeShape),shapeOffsets:body.shapeOffsets.map(serializeVec3),shapeOrientations:body.shapeOrientations.map(serializeQuaternion),position:serializeVec3(body.position),quaternion:body.quaternion.toArray(),velocity:serializeVec3(body.velocity),angularVelocity:serializeVec3(body.angularVelocity),id:body[ID],mass:body.mass,linearDamping:body.linearDamping,angularDamping:body.angularDamping,fixedRotation:body.fixedRotation,allowSleep:body.allowSleep,sleepSpeedLimit:body.sleepSpeedLimit,sleepTimeLimit:body.sleepTimeLimit}},module.exports.deserializeBodyUpdate=function(message,body){return body.position.set(message.position[0],message.position[1],message.position[2]),body.quaternion.set(message.quaternion[0],message.quaternion[1],message.quaternion[2],message.quaternion[3]),body.velocity.set(message.velocity[0],message.velocity[1],message.velocity[2]),body.angularVelocity.set(message.angularVelocity[0],message.angularVelocity[1],message.angularVelocity[2]),body.linearDamping=message.linearDamping,body.angularDamping=message.angularDamping,body.fixedRotation=message.fixedRotation,body.allowSleep=message.allowSleep,body.sleepSpeedLimit=message.sleepSpeedLimit,body.sleepTimeLimit=message.sleepTimeLimit,body.mass!==message.mass&&(body.mass=message.mass,body.updateMassProperties()),body},module.exports.deserializeInterpBodyUpdate=function(message1,message2,body,mix){var weight1=1-mix,weight2=mix;body.position.set(message1.position[0]*weight1+message2.position[0]*weight2,message1.position[1]*weight1+message2.position[1]*weight2,message1.position[2]*weight1+message2.position[2]*weight2);var quaternion=mathUtils.slerp(message1.quaternion,message2.quaternion,mix);return body.quaternion.set(quaternion[0],quaternion[1],quaternion[2],quaternion[3]),body.velocity.set(message1.velocity[0]*weight1+message2.velocity[0]*weight2,message1.velocity[1]*weight1+message2.velocity[1]*weight2,message1.velocity[2]*weight1+message2.velocity[2]*weight2),body.angularVelocity.set(message1.angularVelocity[0]*weight1+message2.angularVelocity[0]*weight2,message1.angularVelocity[1]*weight1+message2.angularVelocity[1]*weight2,message1.angularVelocity[2]*weight1+message2.angularVelocity[2]*weight2),body.linearDamping=message2.linearDamping,body.angularDamping=message2.angularDamping,body.fixedRotation=message2.fixedRotation,body.allowSleep=message2.allowSleep,body.sleepSpeedLimit=message2.sleepSpeedLimit,body.sleepTimeLimit=message2.sleepTimeLimit,body.mass!==message2.mass&&(body.mass=message2.mass,body.updateMassProperties()),body},module.exports.deserializeBody=function(message){for(var shapeMsg,body=new CANNON.Body({mass:message.mass,position:deserializeVec3(message.position),quaternion:deserializeQuaternion(message.quaternion),velocity:deserializeVec3(message.velocity),angularVelocity:deserializeVec3(message.angularVelocity),linearDamping:message.linearDamping,angularDamping:message.angularDamping,fixedRotation:message.fixedRotation,allowSleep:message.allowSleep,sleepSpeedLimit:message.sleepSpeedLimit,sleepTimeLimit:message.sleepTimeLimit}),i=0;shapeMsg=message.shapes[i];i++)body.addShape(deserializeShape(shapeMsg),deserializeVec3(message.shapeOffsets[i]),deserializeQuaternion(message.shapeOrientations[i]));return body[ID]=message.id,body},module.exports.serializeShape=serializeShape,module.exports.deserializeShape=deserializeShape,module.exports.serializeConstraint=function(constraint){var message={id:constraint[ID],type:constraint.type,maxForce:constraint.maxForce,bodyA:constraint.bodyA[ID],bodyB:constraint.bodyB[ID]};switch(constraint.type){case"LockConstraint":break;case"DistanceConstraint":message.distance=constraint.distance;break;case"HingeConstraint":case"ConeTwistConstraint":message.axisA=serializeVec3(constraint.axisA),message.axisB=serializeVec3(constraint.axisB),message.pivotA=serializeVec3(constraint.pivotA),message.pivotB=serializeVec3(constraint.pivotB);break;case"PointToPointConstraint":message.pivotA=serializeVec3(constraint.pivotA),message.pivotB=serializeVec3(constraint.pivotB);break;default:throw new Error("Unexpected constraint type: "+constraint.type+'. You may need to manually set `constraint.type = "FooConstraint";`.')}return message},module.exports.deserializeConstraint=function(message,bodies){var constraint,TypedConstraint=CANNON[message.type],bodyA=bodies[message.bodyA],bodyB=bodies[message.bodyB];switch(message.type){case"LockConstraint":constraint=new CANNON.LockConstraint(bodyA,bodyB,message);break;case"DistanceConstraint":constraint=new CANNON.DistanceConstraint(bodyA,bodyB,message.distance,message.maxForce);break;case"HingeConstraint":case"ConeTwistConstraint":constraint=new TypedConstraint(bodyA,bodyB,{pivotA:deserializeVec3(message.pivotA),pivotB:deserializeVec3(message.pivotB),axisA:deserializeVec3(message.axisA),axisB:deserializeVec3(message.axisB),maxForce:message.maxForce});break;case"PointToPointConstraint":constraint=new CANNON.PointToPointConstraint(bodyA,deserializeVec3(message.pivotA),bodyB,deserializeVec3(message.pivotB),message.maxForce);break;default:throw new Error("Unexpected constraint type: "+message.type)}return constraint[ID]=message.id,constraint},module.exports.serializeContact=function(contact){return{bi:contact.bi[ID],bj:contact.bj[ID],ni:serializeVec3(contact.ni),ri:serializeVec3(contact.ri),rj:serializeVec3(contact.rj)}},module.exports.deserializeContact=function(message,bodies){return{bi:bodies[message.bi],bj:bodies[message.bj],ni:deserializeVec3(message.ni),ri:deserializeVec3(message.ri),rj:deserializeVec3(message.rj)}},module.exports.serializeVec3=serializeVec3,module.exports.deserializeVec3=deserializeVec3,module.exports.serializeQuaternion=serializeQuaternion,module.exports.deserializeQuaternion=deserializeQuaternion},{"./math":30,"cannon-es":5}]},{},[1]);